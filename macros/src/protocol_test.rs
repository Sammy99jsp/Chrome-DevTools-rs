//!
//! # Chrome DevTools Protocol
//! Version: `V1.3`
//!
//! Autogenerated Rust bindings for the Chrome DevTools Protocol.
//!
#![allow(deprecated)]
#![allow(clippy::enum_variant_names)]
pub mod accessibility {
    ///Unique accessibility node identifier.
    pub type AxNodeId = String;
    ///Enum of possible property types.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AxValueType {
        #[serde(rename = "boolean")]
        Boolean,
        #[serde(rename = "tristate")]
        Tristate,
        #[serde(rename = "booleanOrUndefined")]
        BooleanOrUndefined,
        #[serde(rename = "idref")]
        Idref,
        #[serde(rename = "idrefList")]
        IdrefList,
        #[serde(rename = "integer")]
        Integer,
        #[serde(rename = "node")]
        Node,
        #[serde(rename = "nodeList")]
        NodeList,
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "computedString")]
        ComputedString,
        #[serde(rename = "token")]
        Token,
        #[serde(rename = "tokenList")]
        TokenList,
        #[serde(rename = "domRelation")]
        DomRelation,
        #[serde(rename = "role")]
        Role,
        #[serde(rename = "internalRole")]
        InternalRole,
        #[serde(rename = "valueUndefined")]
        ValueUndefined,
    }
    ///Enum of possible property sources.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AxValueSourceType {
        #[serde(rename = "attribute")]
        Attribute,
        #[serde(rename = "implicit")]
        Implicit,
        #[serde(rename = "style")]
        Style,
        #[serde(rename = "contents")]
        Contents,
        #[serde(rename = "placeholder")]
        Placeholder,
        #[serde(rename = "relatedElement")]
        RelatedElement,
    }
    ///Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AxValueNativeSourceType {
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "figcaption")]
        Figcaption,
        #[serde(rename = "label")]
        Label,
        #[serde(rename = "labelfor")]
        Labelfor,
        #[serde(rename = "labelwrapped")]
        Labelwrapped,
        #[serde(rename = "legend")]
        Legend,
        #[serde(rename = "rubyannotation")]
        Rubyannotation,
        #[serde(rename = "tablecaption")]
        Tablecaption,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "other")]
        Other,
    }
    ///A single source for a computed AX property.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AxValueSource {
        ///What type of source this is.
        #[serde(rename = "type")]
        pub type_: AxValueSourceType,
        ///The value of this property source.
        #[serde(rename = "value")]
        pub value: Option<AxValue>,
        ///The name of the relevant attribute, if any.
        #[serde(rename = "attribute")]
        pub attribute: Option<String>,
        ///The value of the relevant attribute, if any.
        #[serde(rename = "attributeValue")]
        pub attribute_value: Option<AxValue>,
        ///Whether this source is superseded by a higher priority source.
        #[serde(rename = "superseded")]
        pub superseded: Option<bool>,
        ///The native markup source for this value, e.g. a `<label>` element.
        #[serde(rename = "nativeSource")]
        pub native_source: Option<AxValueNativeSourceType>,
        ///The value, such as a node or node list, of the native source.
        #[serde(rename = "nativeSourceValue")]
        pub native_source_value: Option<AxValue>,
        ///Whether the value for this property is invalid.
        #[serde(rename = "invalid")]
        pub invalid: Option<bool>,
        ///Reason for the value being invalid, if it is.
        #[serde(rename = "invalidReason")]
        pub invalid_reason: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AxRelatedNode {
        ///The BackendNodeId of the related DOM node.
        #[serde(rename = "backendDOMNodeId")]
        pub backend_dom_node_id: crate::protocol_test::dom::BackendNodeId,
        ///The IDRef value provided, if any.
        #[serde(rename = "idref")]
        pub idref: Option<String>,
        ///The text alternative of this node in the current context.
        #[serde(rename = "text")]
        pub text: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AxProperty {
        ///The name of this property.
        #[serde(rename = "name")]
        pub name: AxPropertyName,
        ///The value of this property.
        #[serde(rename = "value")]
        pub value: AxValue,
    }
    ///A single computed AX property.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AxValue {
        ///The type of this value.
        #[serde(rename = "type")]
        pub type_: AxValueType,
        ///The computed value of this property.
        #[serde(rename = "value")]
        pub value: Option<serde_json::Value>,
        ///One or more related nodes, if applicable.
        #[serde(rename = "relatedNodes")]
        pub related_nodes: Option<Vec<AxRelatedNode>>,
        ///The sources which contributed to the computation of this property.
        #[serde(rename = "sources")]
        pub sources: Option<Vec<AxValueSource>>,
    }
    ///Values of AXProperty name:
    ///- from 'busy' to 'roledescription': states which apply to every AX node
    ///- from 'live' to 'root': attributes which apply to nodes in live regions
    ///- from 'autocomplete' to 'valuetext': attributes which apply to widgets
    ///- from 'checked' to 'selected': states which apply to widgets
    ///- from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AxPropertyName {
        #[serde(rename = "busy")]
        Busy,
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "editable")]
        Editable,
        #[serde(rename = "focusable")]
        Focusable,
        #[serde(rename = "focused")]
        Focused,
        #[serde(rename = "hidden")]
        Hidden,
        #[serde(rename = "hiddenRoot")]
        HiddenRoot,
        #[serde(rename = "invalid")]
        Invalid,
        #[serde(rename = "keyshortcuts")]
        Keyshortcuts,
        #[serde(rename = "settable")]
        Settable,
        #[serde(rename = "roledescription")]
        Roledescription,
        #[serde(rename = "live")]
        Live,
        #[serde(rename = "atomic")]
        Atomic,
        #[serde(rename = "relevant")]
        Relevant,
        #[serde(rename = "root")]
        Root,
        #[serde(rename = "autocomplete")]
        Autocomplete,
        #[serde(rename = "hasPopup")]
        HasPopup,
        #[serde(rename = "level")]
        Level,
        #[serde(rename = "multiselectable")]
        Multiselectable,
        #[serde(rename = "orientation")]
        Orientation,
        #[serde(rename = "multiline")]
        Multiline,
        #[serde(rename = "readonly")]
        Readonly,
        #[serde(rename = "required")]
        Required,
        #[serde(rename = "valuemin")]
        Valuemin,
        #[serde(rename = "valuemax")]
        Valuemax,
        #[serde(rename = "valuetext")]
        Valuetext,
        #[serde(rename = "checked")]
        Checked,
        #[serde(rename = "expanded")]
        Expanded,
        #[serde(rename = "modal")]
        Modal,
        #[serde(rename = "pressed")]
        Pressed,
        #[serde(rename = "selected")]
        Selected,
        #[serde(rename = "activedescendant")]
        Activedescendant,
        #[serde(rename = "controls")]
        Controls,
        #[serde(rename = "describedby")]
        Describedby,
        #[serde(rename = "details")]
        Details,
        #[serde(rename = "errormessage")]
        Errormessage,
        #[serde(rename = "flowto")]
        Flowto,
        #[serde(rename = "labelledby")]
        Labelledby,
        #[serde(rename = "owns")]
        Owns,
    }
    ///A node in the accessibility tree.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AxNode {
        ///Unique identifier for this node.
        #[serde(rename = "nodeId")]
        pub node_id: AxNodeId,
        ///Whether this node is ignored for accessibility
        #[serde(rename = "ignored")]
        pub ignored: bool,
        ///Collection of reasons why this node is hidden.
        #[serde(rename = "ignoredReasons")]
        pub ignored_reasons: Option<Vec<AxProperty>>,
        ///This `Node`'s role, whether explicit or implicit.
        #[serde(rename = "role")]
        pub role: Option<AxValue>,
        ///This `Node`'s Chrome raw role.
        #[serde(rename = "chromeRole")]
        pub chrome_role: Option<AxValue>,
        ///The accessible name for this `Node`.
        #[serde(rename = "name")]
        pub name: Option<AxValue>,
        ///The accessible description for this `Node`.
        #[serde(rename = "description")]
        pub description: Option<AxValue>,
        ///The value for this `Node`.
        #[serde(rename = "value")]
        pub value: Option<AxValue>,
        ///All other properties
        #[serde(rename = "properties")]
        pub properties: Option<Vec<AxProperty>>,
        ///ID for this node's parent.
        #[serde(rename = "parentId")]
        pub parent_id: Option<AxNodeId>,
        ///IDs for each of this node's child nodes.
        #[serde(rename = "childIds")]
        pub child_ids: Option<Vec<AxNodeId>>,
        ///The backend ID for the associated DOM node, if any.
        #[serde(rename = "backendDOMNodeId")]
        pub backend_dom_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///The frame ID for the frame associated with this nodes document.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
    }
    ///Disables the accessibility domain.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
    ///This turns on accessibility for the page, which can impact performance until accessibility is disabled.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [GetPartialAxTree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPartialAxTreeParams {
        ///Identifier of the node to get the partial accessibility tree for.
        #[serde(rename = "nodeId")]
        pub node_id: Option<crate::protocol_test::dom::NodeId>,
        ///Identifier of the backend node to get the partial accessibility tree for.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///JavaScript object id of the node wrapper to get the partial accessibility tree for.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
        ///Whether to fetch this node's ancestors, siblings and children. Defaults to true.
        #[serde(rename = "fetchRelatives")]
        pub fetch_relatives: Option<bool>,
    }
    ///
    /// Return value for [GetPartialAxTree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPartialAxTreeReturns {
        ///The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and
        ///children, if requested.
        #[serde(rename = "nodes")]
        pub nodes: Vec<AxNode>,
    }
    ///Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
    ///---
    ///Parameter Type: [GetPartialAxTreeParams]
    ///Return Type: [GetPartialAxTreeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPartialAxTree;
    impl crate::util::Command for GetPartialAxTree {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getPartialAXTree"
        }
    }
    ///
    /// Parameter value for [GetFullAxTree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFullAxTreeParams {
        ///The maximum depth at which descendants of the root node should be retrieved.
        ///If omitted, the full tree is returned.
        #[serde(rename = "depth")]
        pub depth: Option<i64>,
        ///The frame for whose document the AX tree should be retrieved.
        ///If omited, the root frame is used.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
    }
    ///
    /// Return value for [GetFullAxTree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFullAxTreeReturns {
        #[serde(rename = "nodes")]
        pub nodes: Vec<AxNode>,
    }
    ///Fetches the entire accessibility tree for the root Document
    ///---
    ///Parameter Type: [GetFullAxTreeParams]
    ///Return Type: [GetFullAxTreeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFullAxTree;
    impl crate::util::Command for GetFullAxTree {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getFullAXTree"
        }
    }
    ///
    /// Parameter value for [GetRootAxNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRootAxNodeParams {
        ///The frame in whose document the node resides.
        ///If omitted, the root frame is used.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
    }
    ///
    /// Return value for [GetRootAxNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRootAxNodeReturns {
        #[serde(rename = "node")]
        pub node: AxNode,
    }
    ///Fetches the root node.
    ///Requires `enable()` to have been called previously.
    ///---
    ///Parameter Type: [GetRootAxNodeParams]
    ///Return Type: [GetRootAxNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRootAxNode;
    impl crate::util::Command for GetRootAxNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getRootAXNode"
        }
    }
    ///
    /// Parameter value for [GetAxNodeAndAncestors].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAxNodeAndAncestorsParams {
        ///Identifier of the node to get.
        #[serde(rename = "nodeId")]
        pub node_id: Option<crate::protocol_test::dom::NodeId>,
        ///Identifier of the backend node to get.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///JavaScript object id of the node wrapper to get.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
    }
    ///
    /// Return value for [GetAxNodeAndAncestors].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAxNodeAndAncestorsReturns {
        #[serde(rename = "nodes")]
        pub nodes: Vec<AxNode>,
    }
    ///Fetches a node and all ancestors up to and including the root.
    ///Requires `enable()` to have been called previously.
    ///---
    ///Parameter Type: [GetAxNodeAndAncestorsParams]
    ///Return Type: [GetAxNodeAndAncestorsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAxNodeAndAncestors;
    impl crate::util::Command for GetAxNodeAndAncestors {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getAXNodeAndAncestors"
        }
    }
    ///
    /// Parameter value for [GetChildAxNodes].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetChildAxNodesParams {
        #[serde(rename = "id")]
        pub id: AxNodeId,
        ///The frame in whose document the node resides.
        ///If omitted, the root frame is used.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
    }
    ///
    /// Return value for [GetChildAxNodes].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetChildAxNodesReturns {
        #[serde(rename = "nodes")]
        pub nodes: Vec<AxNode>,
    }
    ///Fetches a particular accessibility node by AXNodeId.
    ///Requires `enable()` to have been called previously.
    ///---
    ///Parameter Type: [GetChildAxNodesParams]
    ///Return Type: [GetChildAxNodesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetChildAxNodes;
    impl crate::util::Command for GetChildAxNodes {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getChildAXNodes"
        }
    }
    ///
    /// Parameter value for [QueryAxTree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QueryAxTreeParams {
        ///Identifier of the node for the root to query.
        #[serde(rename = "nodeId")]
        pub node_id: Option<crate::protocol_test::dom::NodeId>,
        ///Identifier of the backend node for the root to query.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///JavaScript object id of the node wrapper for the root to query.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
        ///Find nodes with this computed name.
        #[serde(rename = "accessibleName")]
        pub accessible_name: Option<String>,
        ///Find nodes with this computed role.
        #[serde(rename = "role")]
        pub role: Option<String>,
    }
    ///
    /// Return value for [QueryAxTree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QueryAxTreeReturns {
        ///A list of `Accessibility.AXNode` matching the specified attributes,
        ///including nodes that are ignored for accessibility.
        #[serde(rename = "nodes")]
        pub nodes: Vec<AxNode>,
    }
    ///Query a DOM node's accessibility subtree for accessible name and role.
    ///This command computes the name and role for all nodes in the subtree, including those that are
    ///ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
    ///node is specified, or the DOM node does not exist, the command returns an error. If neither
    ///`accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
    ///---
    ///Parameter Type: [QueryAxTreeParams]
    ///Return Type: [QueryAxTreeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QueryAxTree;
    impl crate::util::Command for QueryAxTree {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "queryAXTree"
        }
    }
    ///The loadComplete event mirrors the load complete event sent by the browser to assistive
    ///technology when the web page has finished loading.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadCompleteEvent {
        ///New document root node.
        #[serde(rename = "root")]
        pub root: AxNode,
    }
    ///The nodesUpdated event is sent every time a previously requested node has changed the in tree.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NodesUpdatedEvent {
        ///Updated node data.
        #[serde(rename = "nodes")]
        pub nodes: Vec<AxNode>,
    }
}
pub mod animation {
    ///
    /// Enum for [Animation]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AnimationType {
        #[serde(rename = "CSSTransition")]
        CssTransition,
        #[serde(rename = "CSSAnimation")]
        CssAnimation,
        #[serde(rename = "WebAnimation")]
        WebAnimation,
    }
    ///Animation instance.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Animation {
        ///`Animation`'s id.
        #[serde(rename = "id")]
        pub id: String,
        ///`Animation`'s name.
        #[serde(rename = "name")]
        pub name: String,
        ///`Animation`'s internal paused state.
        #[serde(rename = "pausedState")]
        pub paused_state: bool,
        ///`Animation`'s play state.
        #[serde(rename = "playState")]
        pub play_state: String,
        ///`Animation`'s playback rate.
        #[serde(rename = "playbackRate")]
        pub playback_rate: f64,
        ///`Animation`'s start time.
        #[serde(rename = "startTime")]
        pub start_time: f64,
        ///`Animation`'s current time.
        #[serde(rename = "currentTime")]
        pub current_time: f64,
        ///Animation type of `Animation`.
        #[serde(rename = "type")]
        pub type_: AnimationType,
        ///`Animation`'s source animation node.
        #[serde(rename = "source")]
        pub source: Option<AnimationEffect>,
        ///A unique ID for `Animation` representing the sources that triggered this CSS
        ///animation/transition.
        #[serde(rename = "cssId")]
        pub css_id: Option<String>,
    }
    ///AnimationEffect instance
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AnimationEffect {
        ///`AnimationEffect`'s delay.
        #[serde(rename = "delay")]
        pub delay: f64,
        ///`AnimationEffect`'s end delay.
        #[serde(rename = "endDelay")]
        pub end_delay: f64,
        ///`AnimationEffect`'s iteration start.
        #[serde(rename = "iterationStart")]
        pub iteration_start: f64,
        ///`AnimationEffect`'s iterations.
        #[serde(rename = "iterations")]
        pub iterations: f64,
        ///`AnimationEffect`'s iteration duration.
        #[serde(rename = "duration")]
        pub duration: f64,
        ///`AnimationEffect`'s playback direction.
        #[serde(rename = "direction")]
        pub direction: String,
        ///`AnimationEffect`'s fill mode.
        #[serde(rename = "fill")]
        pub fill: String,
        ///`AnimationEffect`'s target node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///`AnimationEffect`'s keyframes.
        #[serde(rename = "keyframesRule")]
        pub keyframes_rule: Option<KeyframesRule>,
        ///`AnimationEffect`'s timing function.
        #[serde(rename = "easing")]
        pub easing: String,
    }
    ///Keyframes Rule
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct KeyframesRule {
        ///CSS keyframed animation's name.
        #[serde(rename = "name")]
        pub name: Option<String>,
        ///List of animation keyframes.
        #[serde(rename = "keyframes")]
        pub keyframes: Vec<KeyframeStyle>,
    }
    ///Keyframe Style
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct KeyframeStyle {
        ///Keyframe's time offset.
        #[serde(rename = "offset")]
        pub offset: String,
        ///`AnimationEffect`'s timing function.
        #[serde(rename = "easing")]
        pub easing: String,
    }
    ///Disables animation domain notifications.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables animation domain notifications.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [GetCurrentTime].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCurrentTimeParams {
        ///Id of animation.
        #[serde(rename = "id")]
        pub id: String,
    }
    ///
    /// Return value for [GetCurrentTime].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCurrentTimeReturns {
        ///Current time of the page.
        #[serde(rename = "currentTime")]
        pub current_time: f64,
    }
    ///Returns the current time of the an animation.
    ///---
    ///Parameter Type: [GetCurrentTimeParams]
    ///Return Type: [GetCurrentTimeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCurrentTime;
    impl crate::util::Command for GetCurrentTime {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getCurrentTime"
        }
    }
    ///
    /// Return value for [GetPlaybackRate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPlaybackRateReturns {
        ///Playback rate for animations on page.
        #[serde(rename = "playbackRate")]
        pub playback_rate: f64,
    }
    ///Gets the playback rate of the document timeline.
    ///---
    ///Return Type: [GetPlaybackRateReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPlaybackRate;
    impl crate::util::Command for GetPlaybackRate {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getPlaybackRate"
        }
    }
    ///
    /// Parameter value for [ReleaseAnimations].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReleaseAnimationsParams {
        ///List of animation ids to seek.
        #[serde(rename = "animations")]
        pub animations: Vec<String>,
    }
    ///Releases a set of animations to no longer be manipulated.
    ///---
    ///Parameter Type: [ReleaseAnimationsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReleaseAnimations;
    impl crate::util::Command for ReleaseAnimations {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "releaseAnimations"
        }
    }
    ///
    /// Parameter value for [ResolveAnimation].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveAnimationParams {
        ///Animation id.
        #[serde(rename = "animationId")]
        pub animation_id: String,
    }
    ///
    /// Return value for [ResolveAnimation].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveAnimationReturns {
        ///Corresponding remote object.
        #[serde(rename = "remoteObject")]
        pub remote_object: crate::protocol_test::runtime::RemoteObject,
    }
    ///Gets the remote object of the Animation.
    ///---
    ///Parameter Type: [ResolveAnimationParams]
    ///Return Type: [ResolveAnimationReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveAnimation;
    impl crate::util::Command for ResolveAnimation {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resolveAnimation"
        }
    }
    ///
    /// Parameter value for [SeekAnimations].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SeekAnimationsParams {
        ///List of animation ids to seek.
        #[serde(rename = "animations")]
        pub animations: Vec<String>,
        ///Set the current time of each animation.
        #[serde(rename = "currentTime")]
        pub current_time: f64,
    }
    ///Seek a set of animations to a particular time within each animation.
    ///---
    ///Parameter Type: [SeekAnimationsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SeekAnimations;
    impl crate::util::Command for SeekAnimations {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "seekAnimations"
        }
    }
    ///
    /// Parameter value for [SetPaused].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPausedParams {
        ///Animations to set the pause state of.
        #[serde(rename = "animations")]
        pub animations: Vec<String>,
        ///Paused state to set to.
        #[serde(rename = "paused")]
        pub paused: bool,
    }
    ///Sets the paused state of a set of animations.
    ///---
    ///Parameter Type: [SetPausedParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPaused;
    impl crate::util::Command for SetPaused {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setPaused"
        }
    }
    ///
    /// Parameter value for [SetPlaybackRate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPlaybackRateParams {
        ///Playback rate for animations on page
        #[serde(rename = "playbackRate")]
        pub playback_rate: f64,
    }
    ///Sets the playback rate of the document timeline.
    ///---
    ///Parameter Type: [SetPlaybackRateParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPlaybackRate;
    impl crate::util::Command for SetPlaybackRate {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setPlaybackRate"
        }
    }
    ///
    /// Parameter value for [SetTiming].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTimingParams {
        ///Animation id.
        #[serde(rename = "animationId")]
        pub animation_id: String,
        ///Duration of the animation.
        #[serde(rename = "duration")]
        pub duration: f64,
        ///Delay of the animation.
        #[serde(rename = "delay")]
        pub delay: f64,
    }
    ///Sets the timing of an animation node.
    ///---
    ///Parameter Type: [SetTimingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTiming;
    impl crate::util::Command for SetTiming {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setTiming"
        }
    }
    ///Event for when an animation has been cancelled.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AnimationCanceledEvent {
        ///Id of the animation that was cancelled.
        #[serde(rename = "id")]
        pub id: String,
    }
    ///Event for each animation that has been created.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AnimationCreatedEvent {
        ///Id of the animation that was created.
        #[serde(rename = "id")]
        pub id: String,
    }
    ///Event for animation that has been started.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AnimationStartedEvent {
        ///Animation that was started.
        #[serde(rename = "animation")]
        pub animation: Animation,
    }
}
///Audits domain allows investigation of page violations and possible improvements.
pub mod audits {
    ///Information about a cookie that is affected by an inspector issue.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AffectedCookie {
        ///The following three properties uniquely identify a cookie
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "path")]
        pub path: String,
        #[serde(rename = "domain")]
        pub domain: String,
    }
    ///Information about a request that is affected by an inspector issue.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AffectedRequest {
        ///The unique request id.
        #[serde(rename = "requestId")]
        pub request_id: crate::protocol_test::network::RequestId,
        #[serde(rename = "url")]
        pub url: Option<String>,
    }
    ///Information about the frame affected by an inspector issue.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AffectedFrame {
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CookieExclusionReason {
        #[serde(rename = "ExcludeSameSiteUnspecifiedTreatedAsLax")]
        ExcludeSameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "ExcludeSameSiteNoneInsecure")]
        ExcludeSameSiteNoneInsecure,
        #[serde(rename = "ExcludeSameSiteLax")]
        ExcludeSameSiteLax,
        #[serde(rename = "ExcludeSameSiteStrict")]
        ExcludeSameSiteStrict,
        #[serde(rename = "ExcludeInvalidSameParty")]
        ExcludeInvalidSameParty,
        #[serde(rename = "ExcludeSamePartyCrossPartyContext")]
        ExcludeSamePartyCrossPartyContext,
        #[serde(rename = "ExcludeDomainNonASCII")]
        ExcludeDomainNonAscii,
        #[serde(rename = "ExcludeThirdPartyCookieBlockedInFirstPartySet")]
        ExcludeThirdPartyCookieBlockedInFirstPartySet,
        #[serde(rename = "ExcludeThirdPartyPhaseout")]
        ExcludeThirdPartyPhaseout,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CookieWarningReason {
        #[serde(rename = "WarnSameSiteUnspecifiedCrossSiteContext")]
        WarnSameSiteUnspecifiedCrossSiteContext,
        #[serde(rename = "WarnSameSiteNoneInsecure")]
        WarnSameSiteNoneInsecure,
        #[serde(rename = "WarnSameSiteUnspecifiedLaxAllowUnsafe")]
        WarnSameSiteUnspecifiedLaxAllowUnsafe,
        #[serde(rename = "WarnSameSiteStrictLaxDowngradeStrict")]
        WarnSameSiteStrictLaxDowngradeStrict,
        #[serde(rename = "WarnSameSiteStrictCrossDowngradeStrict")]
        WarnSameSiteStrictCrossDowngradeStrict,
        #[serde(rename = "WarnSameSiteStrictCrossDowngradeLax")]
        WarnSameSiteStrictCrossDowngradeLax,
        #[serde(rename = "WarnSameSiteLaxCrossDowngradeStrict")]
        WarnSameSiteLaxCrossDowngradeStrict,
        #[serde(rename = "WarnSameSiteLaxCrossDowngradeLax")]
        WarnSameSiteLaxCrossDowngradeLax,
        #[serde(rename = "WarnAttributeValueExceedsMaxSize")]
        WarnAttributeValueExceedsMaxSize,
        #[serde(rename = "WarnDomainNonASCII")]
        WarnDomainNonAscii,
        #[serde(rename = "WarnThirdPartyPhaseout")]
        WarnThirdPartyPhaseout,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CookieOperation {
        #[serde(rename = "SetCookie")]
        SetCookie,
        #[serde(rename = "ReadCookie")]
        ReadCookie,
    }
    ///This information is currently necessary, as the front-end has a difficult
    ///time finding a specific cookie. With this, we can convey specific error
    ///information without the cookie.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CookieIssueDetails {
        ///If AffectedCookie is not set then rawCookieLine contains the raw
        ///Set-Cookie header string. This hints at a problem where the
        ///cookie line is syntactically or semantically malformed in a way
        ///that no valid cookie could be created.
        #[serde(rename = "cookie")]
        pub cookie: Option<AffectedCookie>,
        #[serde(rename = "rawCookieLine")]
        pub raw_cookie_line: Option<String>,
        #[serde(rename = "cookieWarningReasons")]
        pub cookie_warning_reasons: Vec<CookieWarningReason>,
        #[serde(rename = "cookieExclusionReasons")]
        pub cookie_exclusion_reasons: Vec<CookieExclusionReason>,
        ///Optionally identifies the site-for-cookies and the cookie url, which
        ///may be used by the front-end as additional context.
        #[serde(rename = "operation")]
        pub operation: CookieOperation,
        #[serde(rename = "siteForCookies")]
        pub site_for_cookies: Option<String>,
        #[serde(rename = "cookieUrl")]
        pub cookie_url: Option<String>,
        #[serde(rename = "request")]
        pub request: Option<AffectedRequest>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum MixedContentResolutionStatus {
        #[serde(rename = "MixedContentBlocked")]
        MixedContentBlocked,
        #[serde(rename = "MixedContentAutomaticallyUpgraded")]
        MixedContentAutomaticallyUpgraded,
        #[serde(rename = "MixedContentWarning")]
        MixedContentWarning,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum MixedContentResourceType {
        #[serde(rename = "AttributionSrc")]
        AttributionSrc,
        #[serde(rename = "Audio")]
        Audio,
        #[serde(rename = "Beacon")]
        Beacon,
        #[serde(rename = "CSPReport")]
        CspReport,
        #[serde(rename = "Download")]
        Download,
        #[serde(rename = "EventSource")]
        EventSource,
        #[serde(rename = "Favicon")]
        Favicon,
        #[serde(rename = "Font")]
        Font,
        #[serde(rename = "Form")]
        Form,
        #[serde(rename = "Frame")]
        Frame,
        #[serde(rename = "Image")]
        Image,
        #[serde(rename = "Import")]
        Import,
        #[serde(rename = "Manifest")]
        Manifest,
        #[serde(rename = "Ping")]
        Ping,
        #[serde(rename = "PluginData")]
        PluginData,
        #[serde(rename = "PluginResource")]
        PluginResource,
        #[serde(rename = "Prefetch")]
        Prefetch,
        #[serde(rename = "Resource")]
        Resource,
        #[serde(rename = "Script")]
        Script,
        #[serde(rename = "ServiceWorker")]
        ServiceWorker,
        #[serde(rename = "SharedWorker")]
        SharedWorker,
        #[serde(rename = "Stylesheet")]
        Stylesheet,
        #[serde(rename = "Track")]
        Track,
        #[serde(rename = "Video")]
        Video,
        #[serde(rename = "Worker")]
        Worker,
        #[serde(rename = "XMLHttpRequest")]
        XmlHttpRequest,
        #[serde(rename = "XSLT")]
        Xslt,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MixedContentIssueDetails {
        ///The type of resource causing the mixed content issue (css, js, iframe,
        ///form,...). Marked as optional because it is mapped to from
        ///blink::mojom::RequestContextType, which will be replaced
        ///by network::mojom::RequestDestination
        #[serde(rename = "resourceType")]
        pub resource_type: Option<MixedContentResourceType>,
        ///The way the mixed content issue is being resolved.
        #[serde(rename = "resolutionStatus")]
        pub resolution_status: MixedContentResolutionStatus,
        ///The unsafe http url causing the mixed content issue.
        #[serde(rename = "insecureURL")]
        pub insecure_url: String,
        ///The url responsible for the call to an unsafe url.
        #[serde(rename = "mainResourceURL")]
        pub main_resource_url: String,
        ///The mixed content request.
        ///Does not always exist (e.g. for unsafe form submission urls).
        #[serde(rename = "request")]
        pub request: Option<AffectedRequest>,
        ///Optional because not every mixed content issue is necessarily linked to a frame.
        #[serde(rename = "frame")]
        pub frame: Option<AffectedFrame>,
    }
    ///Enum indicating the reason a response has been blocked. These reasons are
    ///refinements of the net error BLOCKED_BY_RESPONSE.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum BlockedByResponseReason {
        #[serde(rename = "CoepFrameResourceNeedsCoepHeader")]
        CoepFrameResourceNeedsCoepHeader,
        #[serde(rename = "CoopSandboxedIFrameCannotNavigateToCoopPage")]
        CoopSandboxedIFrameCannotNavigateToCoopPage,
        #[serde(rename = "CorpNotSameOrigin")]
        CorpNotSameOrigin,
        #[serde(rename = "CorpNotSameOriginAfterDefaultedToSameOriginByCoep")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        #[serde(rename = "CorpNotSameSite")]
        CorpNotSameSite,
    }
    ///Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
    ///code. Currently only used for COEP/COOP, but may be extended to include
    ///some CSP errors in the future.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BlockedByResponseIssueDetails {
        #[serde(rename = "request")]
        pub request: AffectedRequest,
        #[serde(rename = "parentFrame")]
        pub parent_frame: Option<AffectedFrame>,
        #[serde(rename = "blockedFrame")]
        pub blocked_frame: Option<AffectedFrame>,
        #[serde(rename = "reason")]
        pub reason: BlockedByResponseReason,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum HeavyAdResolutionStatus {
        #[serde(rename = "HeavyAdBlocked")]
        HeavyAdBlocked,
        #[serde(rename = "HeavyAdWarning")]
        HeavyAdWarning,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum HeavyAdReason {
        #[serde(rename = "NetworkTotalLimit")]
        NetworkTotalLimit,
        #[serde(rename = "CpuTotalLimit")]
        CpuTotalLimit,
        #[serde(rename = "CpuPeakLimit")]
        CpuPeakLimit,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HeavyAdIssueDetails {
        ///The resolution status, either blocking the content or warning.
        #[serde(rename = "resolution")]
        pub resolution: HeavyAdResolutionStatus,
        ///The reason the ad was blocked, total network or cpu or peak cpu.
        #[serde(rename = "reason")]
        pub reason: HeavyAdReason,
        ///The frame that was blocked.
        #[serde(rename = "frame")]
        pub frame: AffectedFrame,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ContentSecurityPolicyViolationType {
        #[serde(rename = "kInlineViolation")]
        KInlineViolation,
        #[serde(rename = "kEvalViolation")]
        KEvalViolation,
        #[serde(rename = "kURLViolation")]
        KUrlViolation,
        #[serde(rename = "kTrustedTypesSinkViolation")]
        KTrustedTypesSinkViolation,
        #[serde(rename = "kTrustedTypesPolicyViolation")]
        KTrustedTypesPolicyViolation,
        #[serde(rename = "kWasmEvalViolation")]
        KWasmEvalViolation,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SourceCodeLocation {
        #[serde(rename = "scriptId")]
        pub script_id: Option<crate::protocol_test::runtime::ScriptId>,
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContentSecurityPolicyIssueDetails {
        ///The url not included in allowed sources.
        #[serde(rename = "blockedURL")]
        pub blocked_url: Option<String>,
        ///Specific directive that is violated, causing the CSP issue.
        #[serde(rename = "violatedDirective")]
        pub violated_directive: String,
        #[serde(rename = "isReportOnly")]
        pub is_report_only: bool,
        #[serde(rename = "contentSecurityPolicyViolationType")]
        pub content_security_policy_violation_type: ContentSecurityPolicyViolationType,
        #[serde(rename = "frameAncestor")]
        pub frame_ancestor: Option<AffectedFrame>,
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: Option<SourceCodeLocation>,
        #[serde(rename = "violatingNodeId")]
        pub violating_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SharedArrayBufferIssueType {
        #[serde(rename = "TransferIssue")]
        TransferIssue,
        #[serde(rename = "CreationIssue")]
        CreationIssue,
    }
    ///Details for a issue arising from an SAB being instantiated in, or
    ///transferred to a context that is not cross-origin isolated.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SharedArrayBufferIssueDetails {
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        #[serde(rename = "isWarning")]
        pub is_warning: bool,
        #[serde(rename = "type")]
        pub type_: SharedArrayBufferIssueType,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LowTextContrastIssueDetails {
        #[serde(rename = "violatingNodeId")]
        pub violating_node_id: crate::protocol_test::dom::BackendNodeId,
        #[serde(rename = "violatingNodeSelector")]
        pub violating_node_selector: String,
        #[serde(rename = "contrastRatio")]
        pub contrast_ratio: f64,
        #[serde(rename = "thresholdAA")]
        pub threshold_aa: f64,
        #[serde(rename = "thresholdAAA")]
        pub threshold_aaa: f64,
        #[serde(rename = "fontSize")]
        pub font_size: String,
        #[serde(rename = "fontWeight")]
        pub font_weight: String,
    }
    ///Details for a CORS related issue, e.g. a warning or error related to
    ///CORS RFC1918 enforcement.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CorsIssueDetails {
        #[serde(rename = "corsErrorStatus")]
        pub cors_error_status: crate::protocol_test::network::CorsErrorStatus,
        #[serde(rename = "isWarning")]
        pub is_warning: bool,
        #[serde(rename = "request")]
        pub request: AffectedRequest,
        #[serde(rename = "location")]
        pub location: Option<SourceCodeLocation>,
        #[serde(rename = "initiatorOrigin")]
        pub initiator_origin: Option<String>,
        #[serde(rename = "resourceIPAddressSpace")]
        pub resource_ip_address_space: Option<
            crate::protocol_test::network::IpAddressSpace,
        >,
        #[serde(rename = "clientSecurityState")]
        pub client_security_state: Option<
            crate::protocol_test::network::ClientSecurityState,
        >,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AttributionReportingIssueType {
        #[serde(rename = "PermissionPolicyDisabled")]
        PermissionPolicyDisabled,
        #[serde(rename = "UntrustworthyReportingOrigin")]
        UntrustworthyReportingOrigin,
        #[serde(rename = "InsecureContext")]
        InsecureContext,
        #[serde(rename = "InvalidHeader")]
        InvalidHeader,
        #[serde(rename = "InvalidRegisterTriggerHeader")]
        InvalidRegisterTriggerHeader,
        #[serde(rename = "SourceAndTriggerHeaders")]
        SourceAndTriggerHeaders,
        #[serde(rename = "SourceIgnored")]
        SourceIgnored,
        #[serde(rename = "TriggerIgnored")]
        TriggerIgnored,
        #[serde(rename = "OsSourceIgnored")]
        OsSourceIgnored,
        #[serde(rename = "OsTriggerIgnored")]
        OsTriggerIgnored,
        #[serde(rename = "InvalidRegisterOsSourceHeader")]
        InvalidRegisterOsSourceHeader,
        #[serde(rename = "InvalidRegisterOsTriggerHeader")]
        InvalidRegisterOsTriggerHeader,
        #[serde(rename = "WebAndOsHeaders")]
        WebAndOsHeaders,
        #[serde(rename = "NoWebOrOsSupport")]
        NoWebOrOsSupport,
        #[serde(rename = "NavigationRegistrationWithoutTransientUserActivation")]
        NavigationRegistrationWithoutTransientUserActivation,
    }
    ///Details for issues around "Attribution Reporting API" usage.
    ///Explainer: https://github.com/WICG/attribution-reporting-api
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttributionReportingIssueDetails {
        #[serde(rename = "violationType")]
        pub violation_type: AttributionReportingIssueType,
        #[serde(rename = "request")]
        pub request: Option<AffectedRequest>,
        #[serde(rename = "violatingNodeId")]
        pub violating_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        #[serde(rename = "invalidParameter")]
        pub invalid_parameter: Option<String>,
    }
    ///Details for issues about documents in Quirks Mode
    ///or Limited Quirks Mode that affects page layouting.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QuirksModeIssueDetails {
        ///If false, it means the document's mode is "quirks"
        ///instead of "limited-quirks".
        #[serde(rename = "isLimitedQuirksMode")]
        pub is_limited_quirks_mode: bool,
        #[serde(rename = "documentNodeId")]
        pub document_node_id: crate::protocol_test::dom::BackendNodeId,
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        #[serde(rename = "loaderId")]
        pub loader_id: crate::protocol_test::network::LoaderId,
    }
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NavigatorUserAgentIssueDetails {
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "location")]
        pub location: Option<SourceCodeLocation>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum GenericIssueErrorType {
        #[serde(rename = "CrossOriginPortalPostMessageError")]
        CrossOriginPortalPostMessageError,
        #[serde(rename = "FormLabelForNameError")]
        FormLabelForNameError,
        #[serde(rename = "FormDuplicateIdForInputError")]
        FormDuplicateIdForInputError,
        #[serde(rename = "FormInputWithNoLabelError")]
        FormInputWithNoLabelError,
        #[serde(rename = "FormAutocompleteAttributeEmptyError")]
        FormAutocompleteAttributeEmptyError,
        #[serde(rename = "FormEmptyIdAndNameAttributesForInputError")]
        FormEmptyIdAndNameAttributesForInputError,
        #[serde(rename = "FormAriaLabelledByToNonExistingId")]
        FormAriaLabelledByToNonExistingId,
        #[serde(rename = "FormInputAssignedAutocompleteValueToIdOrNameAttributeError")]
        FormInputAssignedAutocompleteValueToIdOrNameAttributeError,
        #[serde(rename = "FormLabelHasNeitherForNorNestedInput")]
        FormLabelHasNeitherForNorNestedInput,
        #[serde(rename = "FormLabelForMatchesNonExistingIdError")]
        FormLabelForMatchesNonExistingIdError,
        #[serde(rename = "FormInputHasWrongButWellIntendedAutocompleteValueError")]
        FormInputHasWrongButWellIntendedAutocompleteValueError,
        #[serde(rename = "ResponseWasBlockedByORB")]
        ResponseWasBlockedByOrb,
    }
    ///Depending on the concrete errorType, different properties are set.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GenericIssueDetails {
        ///Issues with the same errorType are aggregated in the frontend.
        #[serde(rename = "errorType")]
        pub error_type: GenericIssueErrorType,
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
        #[serde(rename = "violatingNodeId")]
        pub violating_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        #[serde(rename = "violatingNodeAttribute")]
        pub violating_node_attribute: Option<String>,
        #[serde(rename = "request")]
        pub request: Option<AffectedRequest>,
    }
    ///This issue tracks information needed to print a deprecation message.
    ///https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeprecationIssueDetails {
        #[serde(rename = "affectedFrame")]
        pub affected_frame: Option<AffectedFrame>,
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        ///One of the deprecation names from third_party/blink/renderer/core/frame/deprecation/deprecation.json5
        #[serde(rename = "type")]
        pub type_: String,
    }
    ///This issue warns about sites in the redirect chain of a finished navigation
    ///that may be flagged as trackers and have their state cleared if they don't
    ///receive a user interaction. Note that in this context 'site' means eTLD+1.
    ///For example, if the URL `https://example.test:80/bounce` was in the
    ///redirect chain, the site reported would be `example.test`.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BounceTrackingIssueDetails {
        #[serde(rename = "trackingSites")]
        pub tracking_sites: Vec<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ClientHintIssueReason {
        #[serde(rename = "MetaTagAllowListInvalidOrigin")]
        MetaTagAllowListInvalidOrigin,
        #[serde(rename = "MetaTagModifiedHTML")]
        MetaTagModifiedHtml,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FederatedAuthRequestIssueDetails {
        #[serde(rename = "federatedAuthRequestIssueReason")]
        pub federated_auth_request_issue_reason: FederatedAuthRequestIssueReason,
    }
    ///Represents the failure reason when a federated authentication reason fails.
    ///Should be updated alongside RequestIdTokenStatus in
    ///third_party/blink/public/mojom/devtools/inspector_issue.mojom to include
    ///all cases except for success.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum FederatedAuthRequestIssueReason {
        #[serde(rename = "ShouldEmbargo")]
        ShouldEmbargo,
        #[serde(rename = "TooManyRequests")]
        TooManyRequests,
        #[serde(rename = "WellKnownHttpNotFound")]
        WellKnownHttpNotFound,
        #[serde(rename = "WellKnownNoResponse")]
        WellKnownNoResponse,
        #[serde(rename = "WellKnownInvalidResponse")]
        WellKnownInvalidResponse,
        #[serde(rename = "WellKnownListEmpty")]
        WellKnownListEmpty,
        #[serde(rename = "WellKnownInvalidContentType")]
        WellKnownInvalidContentType,
        #[serde(rename = "ConfigNotInWellKnown")]
        ConfigNotInWellKnown,
        #[serde(rename = "WellKnownTooBig")]
        WellKnownTooBig,
        #[serde(rename = "ConfigHttpNotFound")]
        ConfigHttpNotFound,
        #[serde(rename = "ConfigNoResponse")]
        ConfigNoResponse,
        #[serde(rename = "ConfigInvalidResponse")]
        ConfigInvalidResponse,
        #[serde(rename = "ConfigInvalidContentType")]
        ConfigInvalidContentType,
        #[serde(rename = "ClientMetadataHttpNotFound")]
        ClientMetadataHttpNotFound,
        #[serde(rename = "ClientMetadataNoResponse")]
        ClientMetadataNoResponse,
        #[serde(rename = "ClientMetadataInvalidResponse")]
        ClientMetadataInvalidResponse,
        #[serde(rename = "ClientMetadataInvalidContentType")]
        ClientMetadataInvalidContentType,
        #[serde(rename = "DisabledInSettings")]
        DisabledInSettings,
        #[serde(rename = "ErrorFetchingSignin")]
        ErrorFetchingSignin,
        #[serde(rename = "InvalidSigninResponse")]
        InvalidSigninResponse,
        #[serde(rename = "AccountsHttpNotFound")]
        AccountsHttpNotFound,
        #[serde(rename = "AccountsNoResponse")]
        AccountsNoResponse,
        #[serde(rename = "AccountsInvalidResponse")]
        AccountsInvalidResponse,
        #[serde(rename = "AccountsListEmpty")]
        AccountsListEmpty,
        #[serde(rename = "AccountsInvalidContentType")]
        AccountsInvalidContentType,
        #[serde(rename = "IdTokenHttpNotFound")]
        IdTokenHttpNotFound,
        #[serde(rename = "IdTokenNoResponse")]
        IdTokenNoResponse,
        #[serde(rename = "IdTokenInvalidResponse")]
        IdTokenInvalidResponse,
        #[serde(rename = "IdTokenInvalidRequest")]
        IdTokenInvalidRequest,
        #[serde(rename = "IdTokenInvalidContentType")]
        IdTokenInvalidContentType,
        #[serde(rename = "ErrorIdToken")]
        ErrorIdToken,
        #[serde(rename = "Canceled")]
        Canceled,
        #[serde(rename = "RpPageNotVisible")]
        RpPageNotVisible,
        #[serde(rename = "SilentMediationFailure")]
        SilentMediationFailure,
        #[serde(rename = "ThirdPartyCookiesBlocked")]
        ThirdPartyCookiesBlocked,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FederatedAuthUserInfoRequestIssueDetails {
        #[serde(rename = "federatedAuthUserInfoRequestIssueReason")]
        pub federated_auth_user_info_request_issue_reason: FederatedAuthUserInfoRequestIssueReason,
    }
    ///Represents the failure reason when a getUserInfo() call fails.
    ///Should be updated alongside FederatedAuthUserInfoRequestResult in
    ///third_party/blink/public/mojom/devtools/inspector_issue.mojom.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum FederatedAuthUserInfoRequestIssueReason {
        #[serde(rename = "NotSameOrigin")]
        NotSameOrigin,
        #[serde(rename = "NotIframe")]
        NotIframe,
        #[serde(rename = "NotPotentiallyTrustworthy")]
        NotPotentiallyTrustworthy,
        #[serde(rename = "NoApiPermission")]
        NoApiPermission,
        #[serde(rename = "NotSignedInWithIdp")]
        NotSignedInWithIdp,
        #[serde(rename = "NoAccountSharingPermission")]
        NoAccountSharingPermission,
        #[serde(rename = "InvalidConfigOrWellKnown")]
        InvalidConfigOrWellKnown,
        #[serde(rename = "InvalidAccountsResponse")]
        InvalidAccountsResponse,
        #[serde(rename = "NoReturningUserFromFetchedAccounts")]
        NoReturningUserFromFetchedAccounts,
    }
    ///This issue tracks client hints related issues. It's used to deprecate old
    ///features, encourage the use of new ones, and provide general guidance.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClientHintIssueDetails {
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        #[serde(rename = "clientHintIssueReason")]
        pub client_hint_issue_reason: ClientHintIssueReason,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FailedRequestInfo {
        ///The URL that failed to load.
        #[serde(rename = "url")]
        pub url: String,
        ///The failure message for the failed request.
        #[serde(rename = "failureMessage")]
        pub failure_message: String,
        #[serde(rename = "requestId")]
        pub request_id: Option<crate::protocol_test::network::RequestId>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum StyleSheetLoadingIssueReason {
        #[serde(rename = "LateImportRule")]
        LateImportRule,
        #[serde(rename = "RequestFailed")]
        RequestFailed,
    }
    ///This issue warns when a referenced stylesheet couldn't be loaded.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StylesheetLoadingIssueDetails {
        ///Source code position that referenced the failing stylesheet.
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        ///Reason why the stylesheet couldn't be loaded.
        #[serde(rename = "styleSheetLoadingIssueReason")]
        pub style_sheet_loading_issue_reason: StyleSheetLoadingIssueReason,
        ///Contains additional info when the failure was due to a request.
        #[serde(rename = "failedRequestInfo")]
        pub failed_request_info: Option<FailedRequestInfo>,
    }
    ///A unique identifier for the type of issue. Each type may use one of the
    ///optional fields in InspectorIssueDetails to convey more specific
    ///information about the kind of issue.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum InspectorIssueCode {
        #[serde(rename = "CookieIssue")]
        CookieIssue,
        #[serde(rename = "MixedContentIssue")]
        MixedContentIssue,
        #[serde(rename = "BlockedByResponseIssue")]
        BlockedByResponseIssue,
        #[serde(rename = "HeavyAdIssue")]
        HeavyAdIssue,
        #[serde(rename = "ContentSecurityPolicyIssue")]
        ContentSecurityPolicyIssue,
        #[serde(rename = "SharedArrayBufferIssue")]
        SharedArrayBufferIssue,
        #[serde(rename = "LowTextContrastIssue")]
        LowTextContrastIssue,
        #[serde(rename = "CorsIssue")]
        CorsIssue,
        #[serde(rename = "AttributionReportingIssue")]
        AttributionReportingIssue,
        #[serde(rename = "QuirksModeIssue")]
        QuirksModeIssue,
        #[serde(rename = "NavigatorUserAgentIssue")]
        NavigatorUserAgentIssue,
        #[serde(rename = "GenericIssue")]
        GenericIssue,
        #[serde(rename = "DeprecationIssue")]
        DeprecationIssue,
        #[serde(rename = "ClientHintIssue")]
        ClientHintIssue,
        #[serde(rename = "FederatedAuthRequestIssue")]
        FederatedAuthRequestIssue,
        #[serde(rename = "BounceTrackingIssue")]
        BounceTrackingIssue,
        #[serde(rename = "StylesheetLoadingIssue")]
        StylesheetLoadingIssue,
        #[serde(rename = "FederatedAuthUserInfoRequestIssue")]
        FederatedAuthUserInfoRequestIssue,
    }
    ///This struct holds a list of optional fields with additional information
    ///specific to the kind of issue. When adding a new issue code, please also
    ///add a new optional field to this type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InspectorIssueDetails {
        #[serde(rename = "cookieIssueDetails")]
        pub cookie_issue_details: Option<CookieIssueDetails>,
        #[serde(rename = "mixedContentIssueDetails")]
        pub mixed_content_issue_details: Option<MixedContentIssueDetails>,
        #[serde(rename = "blockedByResponseIssueDetails")]
        pub blocked_by_response_issue_details: Option<BlockedByResponseIssueDetails>,
        #[serde(rename = "heavyAdIssueDetails")]
        pub heavy_ad_issue_details: Option<HeavyAdIssueDetails>,
        #[serde(rename = "contentSecurityPolicyIssueDetails")]
        pub content_security_policy_issue_details: Option<
            ContentSecurityPolicyIssueDetails,
        >,
        #[serde(rename = "sharedArrayBufferIssueDetails")]
        pub shared_array_buffer_issue_details: Option<SharedArrayBufferIssueDetails>,
        #[serde(rename = "lowTextContrastIssueDetails")]
        pub low_text_contrast_issue_details: Option<LowTextContrastIssueDetails>,
        #[serde(rename = "corsIssueDetails")]
        pub cors_issue_details: Option<CorsIssueDetails>,
        #[serde(rename = "attributionReportingIssueDetails")]
        pub attribution_reporting_issue_details: Option<
            AttributionReportingIssueDetails,
        >,
        #[serde(rename = "quirksModeIssueDetails")]
        pub quirks_mode_issue_details: Option<QuirksModeIssueDetails>,
        #[deprecated]
        #[serde(rename = "navigatorUserAgentIssueDetails")]
        pub navigator_user_agent_issue_details: Option<NavigatorUserAgentIssueDetails>,
        #[serde(rename = "genericIssueDetails")]
        pub generic_issue_details: Option<GenericIssueDetails>,
        #[serde(rename = "deprecationIssueDetails")]
        pub deprecation_issue_details: Option<DeprecationIssueDetails>,
        #[serde(rename = "clientHintIssueDetails")]
        pub client_hint_issue_details: Option<ClientHintIssueDetails>,
        #[serde(rename = "federatedAuthRequestIssueDetails")]
        pub federated_auth_request_issue_details: Option<
            FederatedAuthRequestIssueDetails,
        >,
        #[serde(rename = "bounceTrackingIssueDetails")]
        pub bounce_tracking_issue_details: Option<BounceTrackingIssueDetails>,
        #[serde(rename = "stylesheetLoadingIssueDetails")]
        pub stylesheet_loading_issue_details: Option<StylesheetLoadingIssueDetails>,
        #[serde(rename = "federatedAuthUserInfoRequestIssueDetails")]
        pub federated_auth_user_info_request_issue_details: Option<
            FederatedAuthUserInfoRequestIssueDetails,
        >,
    }
    ///A unique id for a DevTools inspector issue. Allows other entities (e.g.
    ///exceptions, CDP message, console messages, etc.) to reference an issue.
    pub type IssueId = String;
    ///An inspector issue reported from the back-end.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InspectorIssue {
        #[serde(rename = "code")]
        pub code: InspectorIssueCode,
        #[serde(rename = "details")]
        pub details: InspectorIssueDetails,
        ///A unique id for this issue. May be omitted if no other entity (e.g.
        ///exception, CDP message, etc.) is referencing this issue.
        #[serde(rename = "issueId")]
        pub issue_id: Option<IssueId>,
    }
    ///
    /// Enum for [GetEncodedResponse]'s `encoding`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum GetEncodedResponseEncoding {
        #[serde(rename = "webp")]
        Webp,
        #[serde(rename = "jpeg")]
        Jpeg,
        #[serde(rename = "png")]
        Png,
    }
    ///
    /// Parameter value for [GetEncodedResponse].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetEncodedResponseParams {
        ///Identifier of the network request to get content for.
        #[serde(rename = "requestId")]
        pub request_id: crate::protocol_test::network::RequestId,
        ///The encoding to use.
        #[serde(rename = "encoding")]
        pub encoding: GetEncodedResponseEncoding,
        ///The quality of the encoding (0-1). (defaults to 1)
        #[serde(rename = "quality")]
        pub quality: Option<f64>,
        ///Whether to only return the size information (defaults to false).
        #[serde(rename = "sizeOnly")]
        pub size_only: Option<bool>,
    }
    ///
    /// Return value for [GetEncodedResponse].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetEncodedResponseReturns {
        ///The encoded body as a base64 string. Omitted if sizeOnly is true. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "body")]
        pub body: Option<String>,
        ///Size before re-encoding.
        #[serde(rename = "originalSize")]
        pub original_size: i64,
        ///Size after re-encoding.
        #[serde(rename = "encodedSize")]
        pub encoded_size: i64,
    }
    ///Returns the response body and size if it were re-encoded with the specified settings. Only
    ///applies to images.
    ///---
    ///Parameter Type: [GetEncodedResponseParams]
    ///Return Type: [GetEncodedResponseReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetEncodedResponse;
    impl crate::util::Command for GetEncodedResponse {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getEncodedResponse"
        }
    }
    ///Disables issues domain, prevents further issues from being reported to the client.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables issues domain, sends the issues collected so far to the client by means of the
    ///`issueAdded` event.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [CheckContrast].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CheckContrastParams {
        ///Whether to report WCAG AAA level issues. Default is false.
        #[serde(rename = "reportAAA")]
        pub report_aaa: Option<bool>,
    }
    ///Runs the contrast check for the target page. Found issues are reported
    ///using Audits.issueAdded event.
    ///---
    ///Parameter Type: [CheckContrastParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CheckContrast;
    impl crate::util::Command for CheckContrast {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "checkContrast"
        }
    }
    ///
    /// Return value for [CheckFormsIssues].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CheckFormsIssuesReturns {
        #[serde(rename = "formIssues")]
        pub form_issues: Vec<GenericIssueDetails>,
    }
    ///Runs the form issues check for the target page. Found issues are reported
    ///using Audits.issueAdded event.
    ///---
    ///Return Type: [CheckFormsIssuesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CheckFormsIssues;
    impl crate::util::Command for CheckFormsIssues {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "checkFormsIssues"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct IssueAddedEvent {
        #[serde(rename = "issue")]
        pub issue: InspectorIssue,
    }
}
///Defines commands and events for Autofill.
pub mod autofill {
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreditCard {
        ///16-digit credit card number.
        #[serde(rename = "number")]
        pub number: String,
        ///Name of the credit card owner.
        #[serde(rename = "name")]
        pub name: String,
        ///2-digit expiry month.
        #[serde(rename = "expiryMonth")]
        pub expiry_month: String,
        ///4-digit expiry year.
        #[serde(rename = "expiryYear")]
        pub expiry_year: String,
        ///3-digit card verification code.
        #[serde(rename = "cvc")]
        pub cvc: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddressField {
        ///address field name, for example GIVEN_NAME.
        #[serde(rename = "name")]
        pub name: String,
        ///address field name, for example Jon Doe.
        #[serde(rename = "value")]
        pub value: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Address {
        ///fields and values defining a test address.
        #[serde(rename = "fields")]
        pub fields: Vec<AddressField>,
    }
    ///
    /// Parameter value for [Trigger].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TriggerParams {
        ///Identifies a field that serves as an anchor for autofill.
        #[serde(rename = "fieldId")]
        pub field_id: crate::protocol_test::dom::BackendNodeId,
        ///Identifies the frame that field belongs to.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
        ///Credit card information to fill out the form. Credit card data is not saved.
        #[serde(rename = "card")]
        pub card: CreditCard,
    }
    ///Trigger autofill on a form identified by the fieldId.
    ///If the field and related form cannot be autofilled, returns an error.
    ///---
    ///Parameter Type: [TriggerParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Trigger;
    impl crate::util::Command for Trigger {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "trigger"
        }
    }
    ///
    /// Parameter value for [SetAddresses].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAddressesParams {
        #[serde(rename = "addresses")]
        pub addresses: Vec<Address>,
    }
    ///Set addresses so that developers can verify their forms implementation.
    ///---
    ///Parameter Type: [SetAddressesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAddresses;
    impl crate::util::Command for SetAddresses {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAddresses"
        }
    }
}
///Defines events for background web platform features.
pub mod background_service {
    ///The Background Service that will be associated with the commands/events.
    ///Every Background Service operates independently, but they share the same
    ///API.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ServiceName {
        #[serde(rename = "backgroundFetch")]
        BackgroundFetch,
        #[serde(rename = "backgroundSync")]
        BackgroundSync,
        #[serde(rename = "pushMessaging")]
        PushMessaging,
        #[serde(rename = "notifications")]
        Notifications,
        #[serde(rename = "paymentHandler")]
        PaymentHandler,
        #[serde(rename = "periodicBackgroundSync")]
        PeriodicBackgroundSync,
    }
    ///A key-value pair for additional event information to pass along.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EventMetadata {
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "value")]
        pub value: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BackgroundServiceEvent {
        ///Timestamp of the event (in seconds).
        #[serde(rename = "timestamp")]
        pub timestamp: crate::protocol_test::network::TimeSinceEpoch,
        ///The origin this event belongs to.
        #[serde(rename = "origin")]
        pub origin: String,
        ///The Service Worker ID that initiated the event.
        #[serde(rename = "serviceWorkerRegistrationId")]
        pub service_worker_registration_id: crate::protocol_test::service_worker::RegistrationId,
        ///The Background Service this event belongs to.
        #[serde(rename = "service")]
        pub service: ServiceName,
        ///A description of the event.
        #[serde(rename = "eventName")]
        pub event_name: String,
        ///An identifier that groups related events together.
        #[serde(rename = "instanceId")]
        pub instance_id: String,
        ///A list of event-specific information.
        #[serde(rename = "eventMetadata")]
        pub event_metadata: Vec<EventMetadata>,
        ///Storage key this event belongs to.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
    }
    ///
    /// Parameter value for [StartObserving].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartObservingParams {
        #[serde(rename = "service")]
        pub service: ServiceName,
    }
    ///Enables event updates for the service.
    ///---
    ///Parameter Type: [StartObservingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartObserving;
    impl crate::util::Command for StartObserving {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startObserving"
        }
    }
    ///
    /// Parameter value for [StopObserving].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopObservingParams {
        #[serde(rename = "service")]
        pub service: ServiceName,
    }
    ///Disables event updates for the service.
    ///---
    ///Parameter Type: [StopObservingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopObserving;
    impl crate::util::Command for StopObserving {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopObserving"
        }
    }
    ///
    /// Parameter value for [SetRecording].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRecordingParams {
        #[serde(rename = "shouldRecord")]
        pub should_record: bool,
        #[serde(rename = "service")]
        pub service: ServiceName,
    }
    ///Set the recording state for the service.
    ///---
    ///Parameter Type: [SetRecordingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRecording;
    impl crate::util::Command for SetRecording {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setRecording"
        }
    }
    ///
    /// Parameter value for [ClearEvents].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearEventsParams {
        #[serde(rename = "service")]
        pub service: ServiceName,
    }
    ///Clears all stored data for the service.
    ///---
    ///Parameter Type: [ClearEventsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearEvents;
    impl crate::util::Command for ClearEvents {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearEvents"
        }
    }
    ///Called when the recording state for the service has been updated.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RecordingStateChangedEvent {
        #[serde(rename = "isRecording")]
        pub is_recording: bool,
        #[serde(rename = "service")]
        pub service: ServiceName,
    }
    ///Called with all existing backgroundServiceEvents when enabled, and all new
    ///events afterwards if enabled and recording.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BackgroundServiceEventReceivedEvent {
        #[serde(rename = "backgroundServiceEvent")]
        pub background_service_event: BackgroundServiceEvent,
    }
}
///The Browser domain defines methods and events for browser managing.
pub mod browser {
    pub type BrowserContextId = String;
    pub type WindowId = i64;
    ///The state of the browser window.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum WindowState {
        #[serde(rename = "normal")]
        Normal,
        #[serde(rename = "minimized")]
        Minimized,
        #[serde(rename = "maximized")]
        Maximized,
        #[serde(rename = "fullscreen")]
        Fullscreen,
    }
    ///Browser window bounds information
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Bounds {
        ///The offset from the left edge of the screen to the window in pixels.
        #[serde(rename = "left")]
        pub left: Option<i64>,
        ///The offset from the top edge of the screen to the window in pixels.
        #[serde(rename = "top")]
        pub top: Option<i64>,
        ///The window width in pixels.
        #[serde(rename = "width")]
        pub width: Option<i64>,
        ///The window height in pixels.
        #[serde(rename = "height")]
        pub height: Option<i64>,
        ///The window state. Default to normal.
        #[serde(rename = "windowState")]
        pub window_state: Option<WindowState>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PermissionType {
        #[serde(rename = "accessibilityEvents")]
        AccessibilityEvents,
        #[serde(rename = "audioCapture")]
        AudioCapture,
        #[serde(rename = "backgroundSync")]
        BackgroundSync,
        #[serde(rename = "backgroundFetch")]
        BackgroundFetch,
        #[serde(rename = "clipboardReadWrite")]
        ClipboardReadWrite,
        #[serde(rename = "clipboardSanitizedWrite")]
        ClipboardSanitizedWrite,
        #[serde(rename = "displayCapture")]
        DisplayCapture,
        #[serde(rename = "durableStorage")]
        DurableStorage,
        #[serde(rename = "flash")]
        Flash,
        #[serde(rename = "geolocation")]
        Geolocation,
        #[serde(rename = "idleDetection")]
        IdleDetection,
        #[serde(rename = "localFonts")]
        LocalFonts,
        #[serde(rename = "midi")]
        Midi,
        #[serde(rename = "midiSysex")]
        MidiSysex,
        #[serde(rename = "nfc")]
        Nfc,
        #[serde(rename = "notifications")]
        Notifications,
        #[serde(rename = "paymentHandler")]
        PaymentHandler,
        #[serde(rename = "periodicBackgroundSync")]
        PeriodicBackgroundSync,
        #[serde(rename = "protectedMediaIdentifier")]
        ProtectedMediaIdentifier,
        #[serde(rename = "sensors")]
        Sensors,
        #[serde(rename = "storageAccess")]
        StorageAccess,
        #[serde(rename = "topLevelStorageAccess")]
        TopLevelStorageAccess,
        #[serde(rename = "videoCapture")]
        VideoCapture,
        #[serde(rename = "videoCapturePanTiltZoom")]
        VideoCapturePanTiltZoom,
        #[serde(rename = "wakeLockScreen")]
        WakeLockScreen,
        #[serde(rename = "wakeLockSystem")]
        WakeLockSystem,
        #[serde(rename = "windowManagement")]
        WindowManagement,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PermissionSetting {
        #[serde(rename = "granted")]
        Granted,
        #[serde(rename = "denied")]
        Denied,
        #[serde(rename = "prompt")]
        Prompt,
    }
    ///Definition of PermissionDescriptor defined in the Permissions API:
    ///https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PermissionDescriptor {
        ///Name of permission.
        ///See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
        #[serde(rename = "name")]
        pub name: String,
        ///For "midi" permission, may also specify sysex control.
        #[serde(rename = "sysex")]
        pub sysex: Option<bool>,
        ///For "push" permission, may specify userVisibleOnly.
        ///Note that userVisibleOnly = true is the only currently supported type.
        #[serde(rename = "userVisibleOnly")]
        pub user_visible_only: Option<bool>,
        ///For "clipboard" permission, may specify allowWithoutSanitization.
        #[serde(rename = "allowWithoutSanitization")]
        pub allow_without_sanitization: Option<bool>,
        ///For "camera" permission, may specify panTiltZoom.
        #[serde(rename = "panTiltZoom")]
        pub pan_tilt_zoom: Option<bool>,
    }
    ///Browser command ids used by executeBrowserCommand.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum BrowserCommandId {
        #[serde(rename = "openTabSearch")]
        OpenTabSearch,
        #[serde(rename = "closeTabSearch")]
        CloseTabSearch,
    }
    ///Chrome histogram bucket.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Bucket {
        ///Minimum value (inclusive).
        #[serde(rename = "low")]
        pub low: i64,
        ///Maximum value (exclusive).
        #[serde(rename = "high")]
        pub high: i64,
        ///Number of samples.
        #[serde(rename = "count")]
        pub count: i64,
    }
    ///Chrome histogram.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Histogram {
        ///Name.
        #[serde(rename = "name")]
        pub name: String,
        ///Sum of sample values.
        #[serde(rename = "sum")]
        pub sum: i64,
        ///Total number of samples.
        #[serde(rename = "count")]
        pub count: i64,
        ///Buckets.
        #[serde(rename = "buckets")]
        pub buckets: Vec<Bucket>,
    }
    ///
    /// Parameter value for [SetPermission].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPermissionParams {
        ///Descriptor of permission to override.
        #[serde(rename = "permission")]
        pub permission: PermissionDescriptor,
        ///Setting of the permission.
        #[serde(rename = "setting")]
        pub setting: PermissionSetting,
        ///Origin the permission applies to, all origins if not specified.
        #[serde(rename = "origin")]
        pub origin: Option<String>,
        ///Context to override. When omitted, default browser context is used.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<BrowserContextId>,
    }
    ///Set permission settings for given origin.
    ///---
    ///Parameter Type: [SetPermissionParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPermission;
    impl crate::util::Command for SetPermission {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setPermission"
        }
    }
    ///
    /// Parameter value for [GrantPermissions].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GrantPermissionsParams {
        #[serde(rename = "permissions")]
        pub permissions: Vec<PermissionType>,
        ///Origin the permission applies to, all origins if not specified.
        #[serde(rename = "origin")]
        pub origin: Option<String>,
        ///BrowserContext to override permissions. When omitted, default browser context is used.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<BrowserContextId>,
    }
    ///Grant specific permissions to the given origin and reject all others.
    ///---
    ///Parameter Type: [GrantPermissionsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GrantPermissions;
    impl crate::util::Command for GrantPermissions {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "grantPermissions"
        }
    }
    ///
    /// Parameter value for [ResetPermissions].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResetPermissionsParams {
        ///BrowserContext to reset permissions. When omitted, default browser context is used.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<BrowserContextId>,
    }
    ///Reset all permission management for all origins.
    ///---
    ///Parameter Type: [ResetPermissionsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResetPermissions;
    impl crate::util::Command for ResetPermissions {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resetPermissions"
        }
    }
    ///
    /// Enum for [SetDownloadBehavior]'s `behavior`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetDownloadBehaviorBehavior {
        #[serde(rename = "deny")]
        Deny,
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "allowAndName")]
        AllowAndName,
        #[serde(rename = "default")]
        Default,
    }
    ///
    /// Parameter value for [SetDownloadBehavior].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDownloadBehaviorParams {
        ///Whether to allow all or deny all download requests, or use default Chrome behavior if
        ///available (otherwise deny). |allowAndName| allows download and names files according to
        ///their dowmload guids.
        #[serde(rename = "behavior")]
        pub behavior: SetDownloadBehaviorBehavior,
        ///BrowserContext to set download behavior. When omitted, default browser context is used.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<BrowserContextId>,
        ///The default path to save downloaded files to. This is required if behavior is set to 'allow'
        ///or 'allowAndName'.
        #[serde(rename = "downloadPath")]
        pub download_path: Option<String>,
        ///Whether to emit download events (defaults to false).
        #[serde(rename = "eventsEnabled")]
        pub events_enabled: Option<bool>,
    }
    ///Set the behavior when downloading a file.
    ///---
    ///Parameter Type: [SetDownloadBehaviorParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDownloadBehavior;
    impl crate::util::Command for SetDownloadBehavior {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDownloadBehavior"
        }
    }
    ///
    /// Parameter value for [CancelDownload].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CancelDownloadParams {
        ///Global unique identifier of the download.
        #[serde(rename = "guid")]
        pub guid: String,
        ///BrowserContext to perform the action in. When omitted, default browser context is used.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<BrowserContextId>,
    }
    ///Cancel a download if in progress
    ///---
    ///Parameter Type: [CancelDownloadParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CancelDownload;
    impl crate::util::Command for CancelDownload {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "cancelDownload"
        }
    }
    ///Close browser gracefully.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Close;
    impl crate::util::Command for Close {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "close"
        }
    }
    ///Crashes browser on the main thread.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Crash;
    impl crate::util::Command for Crash {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "crash"
        }
    }
    ///Crashes GPU process.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CrashGpuProcess;
    impl crate::util::Command for CrashGpuProcess {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "crashGpuProcess"
        }
    }
    ///
    /// Return value for [GetVersion].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetVersionReturns {
        ///Protocol version.
        #[serde(rename = "protocolVersion")]
        pub protocol_version: String,
        ///Product name.
        #[serde(rename = "product")]
        pub product: String,
        ///Product revision.
        #[serde(rename = "revision")]
        pub revision: String,
        ///User-Agent.
        #[serde(rename = "userAgent")]
        pub user_agent: String,
        ///V8 version.
        #[serde(rename = "jsVersion")]
        pub js_version: String,
    }
    ///Returns version information.
    ///---
    ///Return Type: [GetVersionReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetVersion;
    impl crate::util::Command for GetVersion {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getVersion"
        }
    }
    ///
    /// Return value for [GetBrowserCommandLine].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBrowserCommandLineReturns {
        ///Commandline parameters
        #[serde(rename = "arguments")]
        pub arguments: Vec<String>,
    }
    ///Returns the command line switches for the browser process if, and only if
    ///--enable-automation is on the commandline.
    ///---
    ///Return Type: [GetBrowserCommandLineReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBrowserCommandLine;
    impl crate::util::Command for GetBrowserCommandLine {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getBrowserCommandLine"
        }
    }
    ///
    /// Parameter value for [GetHistograms].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHistogramsParams {
        ///Requested substring in name. Only histograms which have query as a
        ///substring in their name are extracted. An empty or absent query returns
        ///all histograms.
        #[serde(rename = "query")]
        pub query: Option<String>,
        ///If true, retrieve delta since last delta call.
        #[serde(rename = "delta")]
        pub delta: Option<bool>,
    }
    ///
    /// Return value for [GetHistograms].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHistogramsReturns {
        ///Histograms.
        #[serde(rename = "histograms")]
        pub histograms: Vec<Histogram>,
    }
    ///Get Chrome histograms.
    ///---
    ///Parameter Type: [GetHistogramsParams]
    ///Return Type: [GetHistogramsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHistograms;
    impl crate::util::Command for GetHistograms {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getHistograms"
        }
    }
    ///
    /// Parameter value for [GetHistogram].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHistogramParams {
        ///Requested histogram name.
        #[serde(rename = "name")]
        pub name: String,
        ///If true, retrieve delta since last delta call.
        #[serde(rename = "delta")]
        pub delta: Option<bool>,
    }
    ///
    /// Return value for [GetHistogram].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHistogramReturns {
        ///Histogram.
        #[serde(rename = "histogram")]
        pub histogram: Histogram,
    }
    ///Get a Chrome histogram by name.
    ///---
    ///Parameter Type: [GetHistogramParams]
    ///Return Type: [GetHistogramReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHistogram;
    impl crate::util::Command for GetHistogram {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getHistogram"
        }
    }
    ///
    /// Parameter value for [GetWindowBounds].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWindowBoundsParams {
        ///Browser window id.
        #[serde(rename = "windowId")]
        pub window_id: WindowId,
    }
    ///
    /// Return value for [GetWindowBounds].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWindowBoundsReturns {
        ///Bounds information of the window. When window state is 'minimized', the restored window
        ///position and size are returned.
        #[serde(rename = "bounds")]
        pub bounds: Bounds,
    }
    ///Get position and size of the browser window.
    ///---
    ///Parameter Type: [GetWindowBoundsParams]
    ///Return Type: [GetWindowBoundsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWindowBounds;
    impl crate::util::Command for GetWindowBounds {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getWindowBounds"
        }
    }
    ///
    /// Parameter value for [GetWindowForTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWindowForTargetParams {
        ///Devtools agent host id. If called as a part of the session, associated targetId is used.
        #[serde(rename = "targetId")]
        pub target_id: Option<crate::protocol_test::target::TargetId>,
    }
    ///
    /// Return value for [GetWindowForTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWindowForTargetReturns {
        ///Browser window id.
        #[serde(rename = "windowId")]
        pub window_id: WindowId,
        ///Bounds information of the window. When window state is 'minimized', the restored window
        ///position and size are returned.
        #[serde(rename = "bounds")]
        pub bounds: Bounds,
    }
    ///Get the browser window that contains the devtools target.
    ///---
    ///Parameter Type: [GetWindowForTargetParams]
    ///Return Type: [GetWindowForTargetReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWindowForTarget;
    impl crate::util::Command for GetWindowForTarget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getWindowForTarget"
        }
    }
    ///
    /// Parameter value for [SetWindowBounds].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetWindowBoundsParams {
        ///Browser window id.
        #[serde(rename = "windowId")]
        pub window_id: WindowId,
        ///New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined
        ///with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
        #[serde(rename = "bounds")]
        pub bounds: Bounds,
    }
    ///Set position and/or size of the browser window.
    ///---
    ///Parameter Type: [SetWindowBoundsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetWindowBounds;
    impl crate::util::Command for SetWindowBounds {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setWindowBounds"
        }
    }
    ///
    /// Parameter value for [SetDockTile].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDockTileParams {
        #[serde(rename = "badgeLabel")]
        pub badge_label: Option<String>,
        ///Png encoded image. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "image")]
        pub image: Option<String>,
    }
    ///Set dock tile details, platform-specific.
    ///---
    ///Parameter Type: [SetDockTileParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDockTile;
    impl crate::util::Command for SetDockTile {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDockTile"
        }
    }
    ///
    /// Parameter value for [ExecuteBrowserCommand].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecuteBrowserCommandParams {
        #[serde(rename = "commandId")]
        pub command_id: BrowserCommandId,
    }
    ///Invoke custom browser commands used by telemetry.
    ///---
    ///Parameter Type: [ExecuteBrowserCommandParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecuteBrowserCommand;
    impl crate::util::Command for ExecuteBrowserCommand {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "executeBrowserCommand"
        }
    }
    ///
    /// Parameter value for [AddPrivacySandboxEnrollmentOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddPrivacySandboxEnrollmentOverrideParams {
        #[serde(rename = "url")]
        pub url: String,
    }
    ///Allows a site to use privacy sandbox features that require enrollment
    ///without the site actually being enrolled. Only supported on page targets.
    ///---
    ///Parameter Type: [AddPrivacySandboxEnrollmentOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddPrivacySandboxEnrollmentOverride;
    impl crate::util::Command for AddPrivacySandboxEnrollmentOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addPrivacySandboxEnrollmentOverride"
        }
    }
    ///Fired when page is about to start a download.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DownloadWillBeginEvent {
        ///Id of the frame that caused the download to begin.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        ///Global unique identifier of the download.
        #[serde(rename = "guid")]
        pub guid: String,
        ///URL of the resource being downloaded.
        #[serde(rename = "url")]
        pub url: String,
        ///Suggested file name of the resource (the actual name of the file saved on disk may differ).
        #[serde(rename = "suggestedFilename")]
        pub suggested_filename: String,
    }
    ///
    /// Enum for [DownloadProgressEvent]'s `state`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DownloadProgressEventState {
        #[serde(rename = "inProgress")]
        InProgress,
        #[serde(rename = "completed")]
        Completed,
        #[serde(rename = "canceled")]
        Canceled,
    }
    ///Fired when download makes progress. Last call has |done| == true.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DownloadProgressEvent {
        ///Global unique identifier of the download.
        #[serde(rename = "guid")]
        pub guid: String,
        ///Total expected bytes to download.
        #[serde(rename = "totalBytes")]
        pub total_bytes: f64,
        ///Total bytes received.
        #[serde(rename = "receivedBytes")]
        pub received_bytes: f64,
        ///Download status.
        #[serde(rename = "state")]
        pub state: DownloadProgressEventState,
    }
}
///This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
///have an associated `id` used in subsequent operations on the related object. Each object type has
///a specific `id` structure, and those are not interchangeable between objects of different kinds.
///CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
///can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
///subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods.
pub mod css {
    pub type StyleSheetId = String;
    ///Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
    ///stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
    ///inspector" rules), "regular" for regular stylesheets.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum StyleSheetOrigin {
        #[serde(rename = "injected")]
        Injected,
        #[serde(rename = "user-agent")]
        UserAgent,
        #[serde(rename = "inspector")]
        Inspector,
        #[serde(rename = "regular")]
        Regular,
    }
    ///CSS rule collection for a single pseudo style.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PseudoElementMatches {
        ///Pseudo element type.
        #[serde(rename = "pseudoType")]
        pub pseudo_type: crate::protocol_test::dom::PseudoType,
        ///Pseudo element custom ident.
        #[serde(rename = "pseudoIdentifier")]
        pub pseudo_identifier: Option<String>,
        ///Matches of CSS rules applicable to the pseudo style.
        #[serde(rename = "matches")]
        pub matches: Vec<RuleMatch>,
    }
    ///Inherited CSS rule collection from ancestor node.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InheritedStyleEntry {
        ///The ancestor node's inline style, if any, in the style inheritance chain.
        #[serde(rename = "inlineStyle")]
        pub inline_style: Option<CssStyle>,
        ///Matches of CSS rules matching the ancestor node in the style inheritance chain.
        #[serde(rename = "matchedCSSRules")]
        pub matched_css_rules: Vec<RuleMatch>,
    }
    ///Inherited pseudo element matches from pseudos of an ancestor node.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InheritedPseudoElementMatches {
        ///Matches of pseudo styles from the pseudos of an ancestor node.
        #[serde(rename = "pseudoElements")]
        pub pseudo_elements: Vec<PseudoElementMatches>,
    }
    ///Match data for a CSS rule.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RuleMatch {
        ///CSS rule in the match.
        #[serde(rename = "rule")]
        pub rule: CssRule,
        ///Matching selector indices in the rule's selectorList selectors (0-based).
        #[serde(rename = "matchingSelectors")]
        pub matching_selectors: Vec<i64>,
    }
    ///Data for a simple selector (these are delimited by commas in a selector list).
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Value {
        ///Value text.
        #[serde(rename = "text")]
        pub text: String,
        ///Value range in the underlying resource (if available).
        #[serde(rename = "range")]
        pub range: Option<SourceRange>,
        ///Specificity of the selector.
        #[serde(rename = "specificity")]
        pub specificity: Option<Specificity>,
    }
    ///Specificity:
    ///https://drafts.csswg.org/selectors/#specificity-rules
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Specificity {
        ///The a component, which represents the number of ID selectors.
        #[serde(rename = "a")]
        pub a: i64,
        ///The b component, which represents the number of class selectors, attributes selectors, and
        ///pseudo-classes.
        #[serde(rename = "b")]
        pub b: i64,
        ///The c component, which represents the number of type selectors and pseudo-elements.
        #[serde(rename = "c")]
        pub c: i64,
    }
    ///Selector list data.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SelectorList {
        ///Selectors in the list.
        #[serde(rename = "selectors")]
        pub selectors: Vec<Value>,
        ///Rule selector text.
        #[serde(rename = "text")]
        pub text: String,
    }
    ///CSS stylesheet metainformation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssStyleSheetHeader {
        ///The stylesheet identifier.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        ///Owner frame identifier.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        ///Stylesheet resource URL. Empty if this is a constructed stylesheet created using
        ///new CSSStyleSheet() (but non-empty if this is a constructed sylesheet imported
        ///as a CSS module script).
        #[serde(rename = "sourceURL")]
        pub source_url: String,
        ///URL of source map associated with the stylesheet (if any).
        #[serde(rename = "sourceMapURL")]
        pub source_map_url: Option<String>,
        ///Stylesheet origin.
        #[serde(rename = "origin")]
        pub origin: StyleSheetOrigin,
        ///Stylesheet title.
        #[serde(rename = "title")]
        pub title: String,
        ///The backend id for the owner node of the stylesheet.
        #[serde(rename = "ownerNode")]
        pub owner_node: Option<crate::protocol_test::dom::BackendNodeId>,
        ///Denotes whether the stylesheet is disabled.
        #[serde(rename = "disabled")]
        pub disabled: bool,
        ///Whether the sourceURL field value comes from the sourceURL comment.
        #[serde(rename = "hasSourceURL")]
        pub has_source_url: Option<bool>,
        ///Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
        ///document.written STYLE tags.
        #[serde(rename = "isInline")]
        pub is_inline: bool,
        ///Whether this stylesheet is mutable. Inline stylesheets become mutable
        ///after they have been modified via CSSOM API.
        ///`<link>` element's stylesheets become mutable only if DevTools modifies them.
        ///Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
        #[serde(rename = "isMutable")]
        pub is_mutable: bool,
        ///True if this stylesheet is created through new CSSStyleSheet() or imported as a
        ///CSS module script.
        #[serde(rename = "isConstructed")]
        pub is_constructed: bool,
        ///Line offset of the stylesheet within the resource (zero based).
        #[serde(rename = "startLine")]
        pub start_line: f64,
        ///Column offset of the stylesheet within the resource (zero based).
        #[serde(rename = "startColumn")]
        pub start_column: f64,
        ///Size of the content (in characters).
        #[serde(rename = "length")]
        pub length: f64,
        ///Line offset of the end of the stylesheet within the resource (zero based).
        #[serde(rename = "endLine")]
        pub end_line: f64,
        ///Column offset of the end of the stylesheet within the resource (zero based).
        #[serde(rename = "endColumn")]
        pub end_column: f64,
        ///If the style sheet was loaded from a network resource, this indicates when the resource failed to load
        #[serde(rename = "loadingFailed")]
        pub loading_failed: Option<bool>,
    }
    ///CSS rule representation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssRule {
        ///The css style sheet identifier (absent for user agent stylesheet and user-specified
        ///stylesheet rules) this rule came from.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
        ///Rule selector data.
        #[serde(rename = "selectorList")]
        pub selector_list: SelectorList,
        ///Array of selectors from ancestor style rules, sorted by distance from the current rule.
        #[serde(rename = "nestingSelectors")]
        pub nesting_selectors: Option<Vec<String>>,
        ///Parent stylesheet's origin.
        #[serde(rename = "origin")]
        pub origin: StyleSheetOrigin,
        ///Associated style declaration.
        #[serde(rename = "style")]
        pub style: CssStyle,
        ///Media list array (for rules involving media queries). The array enumerates media queries
        ///starting with the innermost one, going outwards.
        #[serde(rename = "media")]
        pub media: Option<Vec<CssMedia>>,
        ///Container query list array (for rules involving container queries).
        ///The array enumerates container queries starting with the innermost one, going outwards.
        #[serde(rename = "containerQueries")]
        pub container_queries: Option<Vec<CssContainerQuery>>,
        ///@supports CSS at-rule array.
        ///The array enumerates @supports at-rules starting with the innermost one, going outwards.
        #[serde(rename = "supports")]
        pub supports: Option<Vec<CssSupports>>,
        ///Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
        ///with the innermost layer and going outwards.
        #[serde(rename = "layers")]
        pub layers: Option<Vec<CssLayer>>,
        ///@scope CSS at-rule array.
        ///The array enumerates @scope at-rules starting with the innermost one, going outwards.
        #[serde(rename = "scopes")]
        pub scopes: Option<Vec<CssScope>>,
        ///The array keeps the types of ancestor CSSRules from the innermost going outwards.
        #[serde(rename = "ruleTypes")]
        pub rule_types: Option<Vec<CssRuleType>>,
    }
    ///Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors.
    ///This list only contains rule types that are collected during the ancestor rule collection.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CssRuleType {
        #[serde(rename = "MediaRule")]
        MediaRule,
        #[serde(rename = "SupportsRule")]
        SupportsRule,
        #[serde(rename = "ContainerRule")]
        ContainerRule,
        #[serde(rename = "LayerRule")]
        LayerRule,
        #[serde(rename = "ScopeRule")]
        ScopeRule,
        #[serde(rename = "StyleRule")]
        StyleRule,
    }
    ///CSS coverage information.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RuleUsage {
        ///The css style sheet identifier (absent for user agent stylesheet and user-specified
        ///stylesheet rules) this rule came from.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        ///Offset of the start of the rule (including selector) from the beginning of the stylesheet.
        #[serde(rename = "startOffset")]
        pub start_offset: f64,
        ///Offset of the end of the rule body from the beginning of the stylesheet.
        #[serde(rename = "endOffset")]
        pub end_offset: f64,
        ///Indicates whether the rule was actually used by some element in the page.
        #[serde(rename = "used")]
        pub used: bool,
    }
    ///Text range within a resource. All numbers are zero-based.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SourceRange {
        ///Start line of range.
        #[serde(rename = "startLine")]
        pub start_line: i64,
        ///Start column of range (inclusive).
        #[serde(rename = "startColumn")]
        pub start_column: i64,
        ///End line of range
        #[serde(rename = "endLine")]
        pub end_line: i64,
        ///End column of range (exclusive).
        #[serde(rename = "endColumn")]
        pub end_column: i64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ShorthandEntry {
        ///Shorthand name.
        #[serde(rename = "name")]
        pub name: String,
        ///Shorthand value.
        #[serde(rename = "value")]
        pub value: String,
        ///Whether the property has "!important" annotation (implies `false` if absent).
        #[serde(rename = "important")]
        pub important: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssComputedStyleProperty {
        ///Computed style property name.
        #[serde(rename = "name")]
        pub name: String,
        ///Computed style property value.
        #[serde(rename = "value")]
        pub value: String,
    }
    ///CSS style representation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssStyle {
        ///The css style sheet identifier (absent for user agent stylesheet and user-specified
        ///stylesheet rules) this rule came from.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
        ///CSS properties in the style.
        #[serde(rename = "cssProperties")]
        pub css_properties: Vec<CssProperty>,
        ///Computed values for all shorthands found in the style.
        #[serde(rename = "shorthandEntries")]
        pub shorthand_entries: Vec<ShorthandEntry>,
        ///Style declaration text (if available).
        #[serde(rename = "cssText")]
        pub css_text: Option<String>,
        ///Style declaration range in the enclosing stylesheet (if available).
        #[serde(rename = "range")]
        pub range: Option<SourceRange>,
    }
    ///CSS property declaration data.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssProperty {
        ///The property name.
        #[serde(rename = "name")]
        pub name: String,
        ///The property value.
        #[serde(rename = "value")]
        pub value: String,
        ///Whether the property has "!important" annotation (implies `false` if absent).
        #[serde(rename = "important")]
        pub important: Option<bool>,
        ///Whether the property is implicit (implies `false` if absent).
        #[serde(rename = "implicit")]
        pub implicit: Option<bool>,
        ///The full property text as specified in the style.
        #[serde(rename = "text")]
        pub text: Option<String>,
        ///Whether the property is understood by the browser (implies `true` if absent).
        #[serde(rename = "parsedOk")]
        pub parsed_ok: Option<bool>,
        ///Whether the property is disabled by the user (present for source-based properties only).
        #[serde(rename = "disabled")]
        pub disabled: Option<bool>,
        ///The entire property range in the enclosing style declaration (if available).
        #[serde(rename = "range")]
        pub range: Option<SourceRange>,
        ///Parsed longhand components of this property if it is a shorthand.
        ///This field will be empty if the given property is not a shorthand.
        #[serde(rename = "longhandProperties")]
        pub longhand_properties: Option<Vec<CssProperty>>,
    }
    ///
    /// Enum for [CssMedia]'s `source`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CssMediaSource {
        #[serde(rename = "mediaRule")]
        MediaRule,
        #[serde(rename = "importRule")]
        ImportRule,
        #[serde(rename = "linkedSheet")]
        LinkedSheet,
        #[serde(rename = "inlineSheet")]
        InlineSheet,
    }
    ///CSS media rule descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssMedia {
        ///Media query text.
        #[serde(rename = "text")]
        pub text: String,
        ///Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
        ///specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
        ///stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
        ///stylesheet's STYLE tag.
        #[serde(rename = "source")]
        pub source: CssMediaSource,
        ///URL of the document containing the media query description.
        #[serde(rename = "sourceURL")]
        pub source_url: Option<String>,
        ///The associated rule (@media or @import) header range in the enclosing stylesheet (if
        ///available).
        #[serde(rename = "range")]
        pub range: Option<SourceRange>,
        ///Identifier of the stylesheet containing this object (if exists).
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
        ///Array of media queries.
        #[serde(rename = "mediaList")]
        pub media_list: Option<Vec<MediaQuery>>,
    }
    ///Media query descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MediaQuery {
        ///Array of media query expressions.
        #[serde(rename = "expressions")]
        pub expressions: Vec<MediaQueryExpression>,
        ///Whether the media query condition is satisfied.
        #[serde(rename = "active")]
        pub active: bool,
    }
    ///Media query expression descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MediaQueryExpression {
        ///Media query expression value.
        #[serde(rename = "value")]
        pub value: f64,
        ///Media query expression units.
        #[serde(rename = "unit")]
        pub unit: String,
        ///Media query expression feature.
        #[serde(rename = "feature")]
        pub feature: String,
        ///The associated range of the value text in the enclosing stylesheet (if available).
        #[serde(rename = "valueRange")]
        pub value_range: Option<SourceRange>,
        ///Computed length of media query expression (if applicable).
        #[serde(rename = "computedLength")]
        pub computed_length: Option<f64>,
    }
    ///CSS container query rule descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssContainerQuery {
        ///Container query text.
        #[serde(rename = "text")]
        pub text: String,
        ///The associated rule header range in the enclosing stylesheet (if
        ///available).
        #[serde(rename = "range")]
        pub range: Option<SourceRange>,
        ///Identifier of the stylesheet containing this object (if exists).
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
        ///Optional name for the container.
        #[serde(rename = "name")]
        pub name: Option<String>,
        ///Optional physical axes queried for the container.
        #[serde(rename = "physicalAxes")]
        pub physical_axes: Option<crate::protocol_test::dom::PhysicalAxes>,
        ///Optional logical axes queried for the container.
        #[serde(rename = "logicalAxes")]
        pub logical_axes: Option<crate::protocol_test::dom::LogicalAxes>,
    }
    ///CSS Supports at-rule descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssSupports {
        ///Supports rule text.
        #[serde(rename = "text")]
        pub text: String,
        ///Whether the supports condition is satisfied.
        #[serde(rename = "active")]
        pub active: bool,
        ///The associated rule header range in the enclosing stylesheet (if
        ///available).
        #[serde(rename = "range")]
        pub range: Option<SourceRange>,
        ///Identifier of the stylesheet containing this object (if exists).
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
    }
    ///CSS Scope at-rule descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssScope {
        ///Scope rule text.
        #[serde(rename = "text")]
        pub text: String,
        ///The associated rule header range in the enclosing stylesheet (if
        ///available).
        #[serde(rename = "range")]
        pub range: Option<SourceRange>,
        ///Identifier of the stylesheet containing this object (if exists).
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
    }
    ///CSS Layer at-rule descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssLayer {
        ///Layer name.
        #[serde(rename = "text")]
        pub text: String,
        ///The associated rule header range in the enclosing stylesheet (if
        ///available).
        #[serde(rename = "range")]
        pub range: Option<SourceRange>,
        ///Identifier of the stylesheet containing this object (if exists).
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
    }
    ///CSS Layer data.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssLayerData {
        ///Layer name.
        #[serde(rename = "name")]
        pub name: String,
        ///Direct sub-layers
        #[serde(rename = "subLayers")]
        pub sub_layers: Option<Vec<CssLayerData>>,
        ///Layer order. The order determines the order of the layer in the cascade order.
        ///A higher number has higher priority in the cascade order.
        #[serde(rename = "order")]
        pub order: f64,
    }
    ///Information about amount of glyphs that were rendered with given font.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlatformFontUsage {
        ///Font's family name reported by platform.
        #[serde(rename = "familyName")]
        pub family_name: String,
        ///Indicates if the font was downloaded or resolved locally.
        #[serde(rename = "isCustomFont")]
        pub is_custom_font: bool,
        ///Amount of glyphs that were rendered with this font.
        #[serde(rename = "glyphCount")]
        pub glyph_count: f64,
    }
    ///Information about font variation axes for variable fonts
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FontVariationAxis {
        ///The font-variation-setting tag (a.k.a. "axis tag").
        #[serde(rename = "tag")]
        pub tag: String,
        ///Human-readable variation name in the default language (normally, "en").
        #[serde(rename = "name")]
        pub name: String,
        ///The minimum value (inclusive) the font supports for this tag.
        #[serde(rename = "minValue")]
        pub min_value: f64,
        ///The maximum value (inclusive) the font supports for this tag.
        #[serde(rename = "maxValue")]
        pub max_value: f64,
        ///The default value.
        #[serde(rename = "defaultValue")]
        pub default_value: f64,
    }
    ///Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
    ///and additional information such as platformFontFamily and fontVariationAxes.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FontFace {
        ///The font-family.
        #[serde(rename = "fontFamily")]
        pub font_family: String,
        ///The font-style.
        #[serde(rename = "fontStyle")]
        pub font_style: String,
        ///The font-variant.
        #[serde(rename = "fontVariant")]
        pub font_variant: String,
        ///The font-weight.
        #[serde(rename = "fontWeight")]
        pub font_weight: String,
        ///The font-stretch.
        #[serde(rename = "fontStretch")]
        pub font_stretch: String,
        ///The font-display.
        #[serde(rename = "fontDisplay")]
        pub font_display: String,
        ///The unicode-range.
        #[serde(rename = "unicodeRange")]
        pub unicode_range: String,
        ///The src.
        #[serde(rename = "src")]
        pub src: String,
        ///The resolved platform font family
        #[serde(rename = "platformFontFamily")]
        pub platform_font_family: String,
        ///Available variation settings (a.k.a. "axes").
        #[serde(rename = "fontVariationAxes")]
        pub font_variation_axes: Option<Vec<FontVariationAxis>>,
    }
    ///CSS try rule representation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssTryRule {
        ///The css style sheet identifier (absent for user agent stylesheet and user-specified
        ///stylesheet rules) this rule came from.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
        ///Parent stylesheet's origin.
        #[serde(rename = "origin")]
        pub origin: StyleSheetOrigin,
        ///Associated style declaration.
        #[serde(rename = "style")]
        pub style: CssStyle,
    }
    ///CSS position-fallback rule representation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssPositionFallbackRule {
        #[serde(rename = "name")]
        pub name: Value,
        ///List of keyframes.
        #[serde(rename = "tryRules")]
        pub try_rules: Vec<CssTryRule>,
    }
    ///CSS keyframes rule representation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssKeyframesRule {
        ///Animation name.
        #[serde(rename = "animationName")]
        pub animation_name: Value,
        ///List of keyframes.
        #[serde(rename = "keyframes")]
        pub keyframes: Vec<CssKeyframeRule>,
    }
    ///CSS keyframe rule representation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssKeyframeRule {
        ///The css style sheet identifier (absent for user agent stylesheet and user-specified
        ///stylesheet rules) this rule came from.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<StyleSheetId>,
        ///Parent stylesheet's origin.
        #[serde(rename = "origin")]
        pub origin: StyleSheetOrigin,
        ///Associated key text.
        #[serde(rename = "keyText")]
        pub key_text: Value,
        ///Associated style declaration.
        #[serde(rename = "style")]
        pub style: CssStyle,
    }
    ///A descriptor of operation to mutate style declaration text.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StyleDeclarationEdit {
        ///The css style sheet identifier.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        ///The range of the style text in the enclosing stylesheet.
        #[serde(rename = "range")]
        pub range: SourceRange,
        ///New style text.
        #[serde(rename = "text")]
        pub text: String,
    }
    ///
    /// Parameter value for [AddRule].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddRuleParams {
        ///The css style sheet identifier where a new rule should be inserted.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        ///The text of a new rule.
        #[serde(rename = "ruleText")]
        pub rule_text: String,
        ///Text position of a new rule in the target style sheet.
        #[serde(rename = "location")]
        pub location: SourceRange,
    }
    ///
    /// Return value for [AddRule].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddRuleReturns {
        ///The newly created rule.
        #[serde(rename = "rule")]
        pub rule: CssRule,
    }
    ///Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
    ///position specified by `location`.
    ///---
    ///Parameter Type: [AddRuleParams]
    ///Return Type: [AddRuleReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddRule;
    impl crate::util::Command for AddRule {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addRule"
        }
    }
    ///
    /// Parameter value for [CollectClassNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CollectClassNamesParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
    }
    ///
    /// Return value for [CollectClassNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CollectClassNamesReturns {
        ///Class name list.
        #[serde(rename = "classNames")]
        pub class_names: Vec<String>,
    }
    ///Returns all class names from specified stylesheet.
    ///---
    ///Parameter Type: [CollectClassNamesParams]
    ///Return Type: [CollectClassNamesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CollectClassNames;
    impl crate::util::Command for CollectClassNames {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "collectClassNames"
        }
    }
    ///
    /// Parameter value for [CreateStyleSheet].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateStyleSheetParams {
        ///Identifier of the frame where "via-inspector" stylesheet should be created.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
    }
    ///
    /// Return value for [CreateStyleSheet].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateStyleSheetReturns {
        ///Identifier of the created "via-inspector" stylesheet.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
    }
    ///Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
    ///---
    ///Parameter Type: [CreateStyleSheetParams]
    ///Return Type: [CreateStyleSheetReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateStyleSheet;
    impl crate::util::Command for CreateStyleSheet {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "createStyleSheet"
        }
    }
    ///Disables the CSS agent for the given page.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
    ///enabled until the result of this command is received.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [ForcePseudoState].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ForcePseudoStateParams {
        ///The element id for which to force the pseudo state.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
        ///Element pseudo classes to force when computing the element's style.
        #[serde(rename = "forcedPseudoClasses")]
        pub forced_pseudo_classes: Vec<String>,
    }
    ///Ensures that the given node will have specified pseudo-classes whenever its style is computed by
    ///the browser.
    ///---
    ///Parameter Type: [ForcePseudoStateParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ForcePseudoState;
    impl crate::util::Command for ForcePseudoState {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "forcePseudoState"
        }
    }
    ///
    /// Parameter value for [GetBackgroundColors].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBackgroundColorsParams {
        ///Id of the node to get background colors for.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///
    /// Return value for [GetBackgroundColors].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBackgroundColorsReturns {
        ///The range of background colors behind this element, if it contains any visible text. If no
        ///visible text is present, this will be undefined. In the case of a flat background color,
        ///this will consist of simply that color. In the case of a gradient, this will consist of each
        ///of the color stops. For anything more complicated, this will be an empty array. Images will
        ///be ignored (as if the image had failed to load).
        #[serde(rename = "backgroundColors")]
        pub background_colors: Option<Vec<String>>,
        ///The computed font size for this node, as a CSS computed value string (e.g. '12px').
        #[serde(rename = "computedFontSize")]
        pub computed_font_size: Option<String>,
        ///The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or
        ///'100').
        #[serde(rename = "computedFontWeight")]
        pub computed_font_weight: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBackgroundColors;
    impl crate::util::Command for GetBackgroundColors {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getBackgroundColors"
        }
    }
    ///
    /// Parameter value for [GetComputedStyleForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetComputedStyleForNodeParams {
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///
    /// Return value for [GetComputedStyleForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetComputedStyleForNodeReturns {
        ///Computed style for the specified DOM node.
        #[serde(rename = "computedStyle")]
        pub computed_style: Vec<CssComputedStyleProperty>,
    }
    ///Returns the computed style for a DOM node identified by `nodeId`.
    ///---
    ///Parameter Type: [GetComputedStyleForNodeParams]
    ///Return Type: [GetComputedStyleForNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetComputedStyleForNode;
    impl crate::util::Command for GetComputedStyleForNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getComputedStyleForNode"
        }
    }
    ///
    /// Parameter value for [GetInlineStylesForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInlineStylesForNodeParams {
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///
    /// Return value for [GetInlineStylesForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInlineStylesForNodeReturns {
        ///Inline style for the specified DOM node.
        #[serde(rename = "inlineStyle")]
        pub inline_style: Option<CssStyle>,
        ///Attribute-defined element style (e.g. resulting from "width=20 height=100%").
        #[serde(rename = "attributesStyle")]
        pub attributes_style: Option<CssStyle>,
    }
    ///Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
    ///attributes) for a DOM node identified by `nodeId`.
    ///---
    ///Parameter Type: [GetInlineStylesForNodeParams]
    ///Return Type: [GetInlineStylesForNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInlineStylesForNode;
    impl crate::util::Command for GetInlineStylesForNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getInlineStylesForNode"
        }
    }
    ///
    /// Parameter value for [GetMatchedStylesForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMatchedStylesForNodeParams {
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///
    /// Return value for [GetMatchedStylesForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMatchedStylesForNodeReturns {
        ///Inline style for the specified DOM node.
        #[serde(rename = "inlineStyle")]
        pub inline_style: Option<CssStyle>,
        ///Attribute-defined element style (e.g. resulting from "width=20 height=100%").
        #[serde(rename = "attributesStyle")]
        pub attributes_style: Option<CssStyle>,
        ///CSS rules matching this node, from all applicable stylesheets.
        #[serde(rename = "matchedCSSRules")]
        pub matched_css_rules: Option<Vec<RuleMatch>>,
        ///Pseudo style matches for this node.
        #[serde(rename = "pseudoElements")]
        pub pseudo_elements: Option<Vec<PseudoElementMatches>>,
        ///A chain of inherited styles (from the immediate node parent up to the DOM tree root).
        #[serde(rename = "inherited")]
        pub inherited: Option<Vec<InheritedStyleEntry>>,
        ///A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
        #[serde(rename = "inheritedPseudoElements")]
        pub inherited_pseudo_elements: Option<Vec<InheritedPseudoElementMatches>>,
        ///A list of CSS keyframed animations matching this node.
        #[serde(rename = "cssKeyframesRules")]
        pub css_keyframes_rules: Option<Vec<CssKeyframesRule>>,
        ///A list of CSS position fallbacks matching this node.
        #[serde(rename = "cssPositionFallbackRules")]
        pub css_position_fallback_rules: Option<Vec<CssPositionFallbackRule>>,
        ///Id of the first parent element that does not have display: contents.
        #[serde(rename = "parentLayoutNodeId")]
        pub parent_layout_node_id: Option<crate::protocol_test::dom::NodeId>,
    }
    ///Returns requested styles for a DOM node identified by `nodeId`.
    ///---
    ///Parameter Type: [GetMatchedStylesForNodeParams]
    ///Return Type: [GetMatchedStylesForNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMatchedStylesForNode;
    impl crate::util::Command for GetMatchedStylesForNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getMatchedStylesForNode"
        }
    }
    ///
    /// Return value for [GetMediaQueries].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMediaQueriesReturns {
        #[serde(rename = "medias")]
        pub medias: Vec<CssMedia>,
    }
    ///Returns all media queries parsed by the rendering engine.
    ///---
    ///Return Type: [GetMediaQueriesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMediaQueries;
    impl crate::util::Command for GetMediaQueries {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getMediaQueries"
        }
    }
    ///
    /// Parameter value for [GetPlatformFontsForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPlatformFontsForNodeParams {
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///
    /// Return value for [GetPlatformFontsForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPlatformFontsForNodeReturns {
        ///Usage statistics for every employed platform font.
        #[serde(rename = "fonts")]
        pub fonts: Vec<PlatformFontUsage>,
    }
    ///Requests information about platform fonts which we used to render child TextNodes in the given
    ///node.
    ///---
    ///Parameter Type: [GetPlatformFontsForNodeParams]
    ///Return Type: [GetPlatformFontsForNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPlatformFontsForNode;
    impl crate::util::Command for GetPlatformFontsForNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getPlatformFontsForNode"
        }
    }
    ///
    /// Parameter value for [GetStyleSheetText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStyleSheetTextParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
    }
    ///
    /// Return value for [GetStyleSheetText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStyleSheetTextReturns {
        ///The stylesheet text.
        #[serde(rename = "text")]
        pub text: String,
    }
    ///Returns the current textual content for a stylesheet.
    ///---
    ///Parameter Type: [GetStyleSheetTextParams]
    ///Return Type: [GetStyleSheetTextReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStyleSheetText;
    impl crate::util::Command for GetStyleSheetText {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getStyleSheetText"
        }
    }
    ///
    /// Parameter value for [GetLayersForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetLayersForNodeParams {
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///
    /// Return value for [GetLayersForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetLayersForNodeReturns {
        #[serde(rename = "rootLayer")]
        pub root_layer: CssLayerData,
    }
    ///Returns all layers parsed by the rendering engine for the tree scope of a node.
    ///Given a DOM element identified by nodeId, getLayersForNode returns the root
    ///layer for the nearest ancestor document or shadow root. The layer root contains
    ///the full layer tree for the tree scope and their ordering.
    ///---
    ///Parameter Type: [GetLayersForNodeParams]
    ///Return Type: [GetLayersForNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetLayersForNode;
    impl crate::util::Command for GetLayersForNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getLayersForNode"
        }
    }
    ///
    /// Parameter value for [TrackComputedStyleUpdates].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackComputedStyleUpdatesParams {
        #[serde(rename = "propertiesToTrack")]
        pub properties_to_track: Vec<CssComputedStyleProperty>,
    }
    ///Starts tracking the given computed styles for updates. The specified array of properties
    ///replaces the one previously specified. Pass empty array to disable tracking.
    ///Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
    ///The changes to computed style properties are only tracked for nodes pushed to the front-end
    ///by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
    ///to the front-end, no updates will be issued for the node.
    ///---
    ///Parameter Type: [TrackComputedStyleUpdatesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackComputedStyleUpdates;
    impl crate::util::Command for TrackComputedStyleUpdates {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "trackComputedStyleUpdates"
        }
    }
    ///
    /// Return value for [TakeComputedStyleUpdates].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeComputedStyleUpdatesReturns {
        ///The list of node Ids that have their tracked computed styles updated.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<crate::protocol_test::dom::NodeId>,
    }
    ///Polls the next batch of computed style updates.
    ///---
    ///Return Type: [TakeComputedStyleUpdatesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeComputedStyleUpdates;
    impl crate::util::Command for TakeComputedStyleUpdates {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "takeComputedStyleUpdates"
        }
    }
    ///
    /// Parameter value for [SetEffectivePropertyValueForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEffectivePropertyValueForNodeParams {
        ///The element id for which to set property.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
        #[serde(rename = "propertyName")]
        pub property_name: String,
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Find a rule with the given active property for the given node and set the new value for this
    ///property
    ///---
    ///Parameter Type: [SetEffectivePropertyValueForNodeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEffectivePropertyValueForNode;
    impl crate::util::Command for SetEffectivePropertyValueForNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setEffectivePropertyValueForNode"
        }
    }
    ///
    /// Parameter value for [SetKeyframeKey].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetKeyframeKeyParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        #[serde(rename = "range")]
        pub range: SourceRange,
        #[serde(rename = "keyText")]
        pub key_text: String,
    }
    ///
    /// Return value for [SetKeyframeKey].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetKeyframeKeyReturns {
        ///The resulting key text after modification.
        #[serde(rename = "keyText")]
        pub key_text: Value,
    }
    ///Modifies the keyframe rule key text.
    ///---
    ///Parameter Type: [SetKeyframeKeyParams]
    ///Return Type: [SetKeyframeKeyReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetKeyframeKey;
    impl crate::util::Command for SetKeyframeKey {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setKeyframeKey"
        }
    }
    ///
    /// Parameter value for [SetMediaText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetMediaTextParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        #[serde(rename = "range")]
        pub range: SourceRange,
        #[serde(rename = "text")]
        pub text: String,
    }
    ///
    /// Return value for [SetMediaText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetMediaTextReturns {
        ///The resulting CSS media rule after modification.
        #[serde(rename = "media")]
        pub media: CssMedia,
    }
    ///Modifies the rule selector.
    ///---
    ///Parameter Type: [SetMediaTextParams]
    ///Return Type: [SetMediaTextReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetMediaText;
    impl crate::util::Command for SetMediaText {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setMediaText"
        }
    }
    ///
    /// Parameter value for [SetContainerQueryText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetContainerQueryTextParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        #[serde(rename = "range")]
        pub range: SourceRange,
        #[serde(rename = "text")]
        pub text: String,
    }
    ///
    /// Return value for [SetContainerQueryText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetContainerQueryTextReturns {
        ///The resulting CSS container query rule after modification.
        #[serde(rename = "containerQuery")]
        pub container_query: CssContainerQuery,
    }
    ///Modifies the expression of a container query.
    ///---
    ///Parameter Type: [SetContainerQueryTextParams]
    ///Return Type: [SetContainerQueryTextReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetContainerQueryText;
    impl crate::util::Command for SetContainerQueryText {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setContainerQueryText"
        }
    }
    ///
    /// Parameter value for [SetSupportsText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSupportsTextParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        #[serde(rename = "range")]
        pub range: SourceRange,
        #[serde(rename = "text")]
        pub text: String,
    }
    ///
    /// Return value for [SetSupportsText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSupportsTextReturns {
        ///The resulting CSS Supports rule after modification.
        #[serde(rename = "supports")]
        pub supports: CssSupports,
    }
    ///Modifies the expression of a supports at-rule.
    ///---
    ///Parameter Type: [SetSupportsTextParams]
    ///Return Type: [SetSupportsTextReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSupportsText;
    impl crate::util::Command for SetSupportsText {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setSupportsText"
        }
    }
    ///
    /// Parameter value for [SetScopeText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScopeTextParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        #[serde(rename = "range")]
        pub range: SourceRange,
        #[serde(rename = "text")]
        pub text: String,
    }
    ///
    /// Return value for [SetScopeText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScopeTextReturns {
        ///The resulting CSS Scope rule after modification.
        #[serde(rename = "scope")]
        pub scope: CssScope,
    }
    ///Modifies the expression of a scope at-rule.
    ///---
    ///Parameter Type: [SetScopeTextParams]
    ///Return Type: [SetScopeTextReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScopeText;
    impl crate::util::Command for SetScopeText {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setScopeText"
        }
    }
    ///
    /// Parameter value for [SetRuleSelector].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRuleSelectorParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        #[serde(rename = "range")]
        pub range: SourceRange,
        #[serde(rename = "selector")]
        pub selector: String,
    }
    ///
    /// Return value for [SetRuleSelector].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRuleSelectorReturns {
        ///The resulting selector list after modification.
        #[serde(rename = "selectorList")]
        pub selector_list: SelectorList,
    }
    ///Modifies the rule selector.
    ///---
    ///Parameter Type: [SetRuleSelectorParams]
    ///Return Type: [SetRuleSelectorReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRuleSelector;
    impl crate::util::Command for SetRuleSelector {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setRuleSelector"
        }
    }
    ///
    /// Parameter value for [SetStyleSheetText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetStyleSheetTextParams {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
        #[serde(rename = "text")]
        pub text: String,
    }
    ///
    /// Return value for [SetStyleSheetText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetStyleSheetTextReturns {
        ///URL of source map associated with script (if any).
        #[serde(rename = "sourceMapURL")]
        pub source_map_url: Option<String>,
    }
    ///Sets the new stylesheet text.
    ///---
    ///Parameter Type: [SetStyleSheetTextParams]
    ///Return Type: [SetStyleSheetTextReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetStyleSheetText;
    impl crate::util::Command for SetStyleSheetText {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setStyleSheetText"
        }
    }
    ///
    /// Parameter value for [SetStyleTexts].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetStyleTextsParams {
        #[serde(rename = "edits")]
        pub edits: Vec<StyleDeclarationEdit>,
    }
    ///
    /// Return value for [SetStyleTexts].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetStyleTextsReturns {
        ///The resulting styles after modification.
        #[serde(rename = "styles")]
        pub styles: Vec<CssStyle>,
    }
    ///Applies specified style edits one after another in the given order.
    ///---
    ///Parameter Type: [SetStyleTextsParams]
    ///Return Type: [SetStyleTextsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetStyleTexts;
    impl crate::util::Command for SetStyleTexts {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setStyleTexts"
        }
    }
    ///Enables the selector recording.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartRuleUsageTracking;
    impl crate::util::Command for StartRuleUsageTracking {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startRuleUsageTracking"
        }
    }
    ///
    /// Return value for [StopRuleUsageTracking].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopRuleUsageTrackingReturns {
        #[serde(rename = "ruleUsage")]
        pub rule_usage: Vec<RuleUsage>,
    }
    ///Stop tracking rule usage and return the list of rules that were used since last call to
    ///`takeCoverageDelta` (or since start of coverage instrumentation).
    ///---
    ///Return Type: [StopRuleUsageTrackingReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopRuleUsageTracking;
    impl crate::util::Command for StopRuleUsageTracking {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopRuleUsageTracking"
        }
    }
    ///
    /// Return value for [TakeCoverageDelta].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeCoverageDeltaReturns {
        #[serde(rename = "coverage")]
        pub coverage: Vec<RuleUsage>,
        ///Monotonically increasing time, in seconds.
        #[serde(rename = "timestamp")]
        pub timestamp: f64,
    }
    ///Obtain list of rules that became used since last call to this method (or since start of coverage
    ///instrumentation).
    ///---
    ///Return Type: [TakeCoverageDeltaReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeCoverageDelta;
    impl crate::util::Command for TakeCoverageDelta {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "takeCoverageDelta"
        }
    }
    ///
    /// Parameter value for [SetLocalFontsEnabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetLocalFontsEnabledParams {
        ///Whether rendering of local fonts is enabled.
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Enables/disables rendering of local CSS fonts (enabled by default).
    ///---
    ///Parameter Type: [SetLocalFontsEnabledParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetLocalFontsEnabled;
    impl crate::util::Command for SetLocalFontsEnabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setLocalFontsEnabled"
        }
    }
    ///Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
    ///web font.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FontsUpdatedEvent {
        ///The web font that has loaded.
        #[serde(rename = "font")]
        pub font: Option<FontFace>,
    }
    ///Fires whenever a MediaQuery result changes (for example, after a browser window has been
    ///resized.) The current implementation considers only viewport-dependent media features.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MediaQueryResultChangedEvent {}
    ///Fired whenever an active document stylesheet is added.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StyleSheetAddedEvent {
        ///Added stylesheet metainfo.
        #[serde(rename = "header")]
        pub header: CssStyleSheetHeader,
    }
    ///Fired whenever a stylesheet is changed as a result of the client operation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StyleSheetChangedEvent {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
    }
    ///Fired whenever an active document stylesheet is removed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StyleSheetRemovedEvent {
        ///Identifier of the removed stylesheet.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: StyleSheetId,
    }
}
pub mod cache_storage {
    ///Unique identifier of the Cache object.
    pub type CacheId = String;
    ///type of HTTP response cached
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CachedResponseType {
        #[serde(rename = "basic")]
        Basic,
        #[serde(rename = "cors")]
        Cors,
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "opaqueResponse")]
        OpaqueResponse,
        #[serde(rename = "opaqueRedirect")]
        OpaqueRedirect,
    }
    ///Data entry.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DataEntry {
        ///Request URL.
        #[serde(rename = "requestURL")]
        pub request_url: String,
        ///Request method.
        #[serde(rename = "requestMethod")]
        pub request_method: String,
        ///Request headers
        #[serde(rename = "requestHeaders")]
        pub request_headers: Vec<Header>,
        ///Number of seconds since epoch.
        #[serde(rename = "responseTime")]
        pub response_time: f64,
        ///HTTP response status code.
        #[serde(rename = "responseStatus")]
        pub response_status: i64,
        ///HTTP response status text.
        #[serde(rename = "responseStatusText")]
        pub response_status_text: String,
        ///HTTP response type
        #[serde(rename = "responseType")]
        pub response_type: CachedResponseType,
        ///Response headers
        #[serde(rename = "responseHeaders")]
        pub response_headers: Vec<Header>,
    }
    ///Cache identifier.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Cache {
        ///An opaque unique id of the cache.
        #[serde(rename = "cacheId")]
        pub cache_id: CacheId,
        ///Security origin of the cache.
        #[serde(rename = "securityOrigin")]
        pub security_origin: String,
        ///Storage key of the cache.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        ///Storage bucket of the cache.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
        ///The name of the cache.
        #[serde(rename = "cacheName")]
        pub cache_name: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Header {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Cached response
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CachedResponse {
        ///Entry content, base64-encoded. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "body")]
        pub body: String,
    }
    ///
    /// Parameter value for [DeleteCache].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteCacheParams {
        ///Id of cache for deletion.
        #[serde(rename = "cacheId")]
        pub cache_id: CacheId,
    }
    ///Deletes a cache.
    ///---
    ///Parameter Type: [DeleteCacheParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteCache;
    impl crate::util::Command for DeleteCache {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deleteCache"
        }
    }
    ///
    /// Parameter value for [DeleteEntry].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteEntryParams {
        ///Id of cache where the entry will be deleted.
        #[serde(rename = "cacheId")]
        pub cache_id: CacheId,
        ///URL spec of the request.
        #[serde(rename = "request")]
        pub request: String,
    }
    ///Deletes a cache entry.
    ///---
    ///Parameter Type: [DeleteEntryParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteEntry;
    impl crate::util::Command for DeleteEntry {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deleteEntry"
        }
    }
    ///
    /// Parameter value for [RequestCacheNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestCacheNamesParams {
        ///At least and at most one of securityOrigin, storageKey, storageBucket must be specified.
        ///Security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: Option<String>,
        ///Storage bucket. If not specified, it uses the default bucket.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
    }
    ///
    /// Return value for [RequestCacheNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestCacheNamesReturns {
        ///Caches for the security origin.
        #[serde(rename = "caches")]
        pub caches: Vec<Cache>,
    }
    ///Requests cache names.
    ///---
    ///Parameter Type: [RequestCacheNamesParams]
    ///Return Type: [RequestCacheNamesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestCacheNames;
    impl crate::util::Command for RequestCacheNames {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestCacheNames"
        }
    }
    ///
    /// Parameter value for [RequestCachedResponse].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestCachedResponseParams {
        ///Id of cache that contains the entry.
        #[serde(rename = "cacheId")]
        pub cache_id: CacheId,
        ///URL spec of the request.
        #[serde(rename = "requestURL")]
        pub request_url: String,
        ///headers of the request.
        #[serde(rename = "requestHeaders")]
        pub request_headers: Vec<Header>,
    }
    ///
    /// Return value for [RequestCachedResponse].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestCachedResponseReturns {
        ///Response read from the cache.
        #[serde(rename = "response")]
        pub response: CachedResponse,
    }
    ///Fetches cache entry.
    ///---
    ///Parameter Type: [RequestCachedResponseParams]
    ///Return Type: [RequestCachedResponseReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestCachedResponse;
    impl crate::util::Command for RequestCachedResponse {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestCachedResponse"
        }
    }
    ///
    /// Parameter value for [RequestEntries].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestEntriesParams {
        ///ID of cache to get entries from.
        #[serde(rename = "cacheId")]
        pub cache_id: CacheId,
        ///Number of records to skip.
        #[serde(rename = "skipCount")]
        pub skip_count: Option<i64>,
        ///Number of records to fetch.
        #[serde(rename = "pageSize")]
        pub page_size: Option<i64>,
        ///If present, only return the entries containing this substring in the path
        #[serde(rename = "pathFilter")]
        pub path_filter: Option<String>,
    }
    ///
    /// Return value for [RequestEntries].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestEntriesReturns {
        ///Array of object store data entries.
        #[serde(rename = "cacheDataEntries")]
        pub cache_data_entries: Vec<DataEntry>,
        ///Count of returned entries from this storage. If pathFilter is empty, it
        ///is the count of all entries from this storage.
        #[serde(rename = "returnCount")]
        pub return_count: f64,
    }
    ///Requests data from cache.
    ///---
    ///Parameter Type: [RequestEntriesParams]
    ///Return Type: [RequestEntriesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestEntries;
    impl crate::util::Command for RequestEntries {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestEntries"
        }
    }
}
///A domain for interacting with Cast, Presentation API, and Remote Playback API
///functionalities.
pub mod cast {
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Sink {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "id")]
        pub id: String,
        ///Text describing the current session. Present only if there is an active
        ///session on the sink.
        #[serde(rename = "session")]
        pub session: Option<String>,
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        #[serde(rename = "presentationUrl")]
        pub presentation_url: Option<String>,
    }
    ///Starts observing for sinks that can be used for tab mirroring, and if set,
    ///sinks compatible with |presentationUrl| as well. When sinks are found, a
    ///|sinksUpdated| event is fired.
    ///Also starts observing for issue messages. When an issue is added or removed,
    ///an |issueUpdated| event is fired.
    ///---
    ///Parameter Type: [EnableParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///Stops observing for sinks and issues.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [SetSinkToUse].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSinkToUseParams {
        #[serde(rename = "sinkName")]
        pub sink_name: String,
    }
    ///Sets a sink to be used when the web page requests the browser to choose a
    ///sink via Presentation API, Remote Playback API, or Cast SDK.
    ///---
    ///Parameter Type: [SetSinkToUseParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSinkToUse;
    impl crate::util::Command for SetSinkToUse {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setSinkToUse"
        }
    }
    ///
    /// Parameter value for [StartDesktopMirroring].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartDesktopMirroringParams {
        #[serde(rename = "sinkName")]
        pub sink_name: String,
    }
    ///Starts mirroring the desktop to the sink.
    ///---
    ///Parameter Type: [StartDesktopMirroringParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartDesktopMirroring;
    impl crate::util::Command for StartDesktopMirroring {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startDesktopMirroring"
        }
    }
    ///
    /// Parameter value for [StartTabMirroring].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartTabMirroringParams {
        #[serde(rename = "sinkName")]
        pub sink_name: String,
    }
    ///Starts mirroring the tab to the sink.
    ///---
    ///Parameter Type: [StartTabMirroringParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartTabMirroring;
    impl crate::util::Command for StartTabMirroring {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startTabMirroring"
        }
    }
    ///
    /// Parameter value for [StopCasting].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopCastingParams {
        #[serde(rename = "sinkName")]
        pub sink_name: String,
    }
    ///Stops the active Cast session on the sink.
    ///---
    ///Parameter Type: [StopCastingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopCasting;
    impl crate::util::Command for StopCasting {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopCasting"
        }
    }
    ///This is fired whenever the list of available sinks changes. A sink is a
    ///device or a software surface that you can cast to.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SinksUpdatedEvent {
        #[serde(rename = "sinks")]
        pub sinks: Vec<Sink>,
    }
    ///This is fired whenever the outstanding issue/error message changes.
    ///|issueMessage| is empty if there is no issue.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct IssueUpdatedEvent {
        #[serde(rename = "issueMessage")]
        pub issue_message: String,
    }
}
///This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
///that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
///the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
///nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
///and never sends the same node twice. It is client's responsibility to collect information about
///the nodes that were sent to the client. Note that `iframe` owner elements will return
///corresponding document elements as their child nodes.
pub mod dom {
    ///Unique DOM node identifier.
    pub type NodeId = i64;
    ///Unique DOM node identifier used to reference a node that may not have been pushed to the
    ///front-end.
    pub type BackendNodeId = i64;
    ///Backend node with a friendly name.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BackendNode {
        ///`Node`'s nodeType.
        #[serde(rename = "nodeType")]
        pub node_type: i64,
        ///`Node`'s nodeName.
        #[serde(rename = "nodeName")]
        pub node_name: String,
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: BackendNodeId,
    }
    ///Pseudo element type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PseudoType {
        #[serde(rename = "first-line")]
        FirstLine,
        #[serde(rename = "first-letter")]
        FirstLetter,
        #[serde(rename = "before")]
        Before,
        #[serde(rename = "after")]
        After,
        #[serde(rename = "marker")]
        Marker,
        #[serde(rename = "backdrop")]
        Backdrop,
        #[serde(rename = "selection")]
        Selection,
        #[serde(rename = "target-text")]
        TargetText,
        #[serde(rename = "spelling-error")]
        SpellingError,
        #[serde(rename = "grammar-error")]
        GrammarError,
        #[serde(rename = "highlight")]
        Highlight,
        #[serde(rename = "first-line-inherited")]
        FirstLineInherited,
        #[serde(rename = "scrollbar")]
        Scrollbar,
        #[serde(rename = "scrollbar-thumb")]
        ScrollbarThumb,
        #[serde(rename = "scrollbar-button")]
        ScrollbarButton,
        #[serde(rename = "scrollbar-track")]
        ScrollbarTrack,
        #[serde(rename = "scrollbar-track-piece")]
        ScrollbarTrackPiece,
        #[serde(rename = "scrollbar-corner")]
        ScrollbarCorner,
        #[serde(rename = "resizer")]
        Resizer,
        #[serde(rename = "input-list-button")]
        InputListButton,
        #[serde(rename = "view-transition")]
        ViewTransition,
        #[serde(rename = "view-transition-group")]
        ViewTransitionGroup,
        #[serde(rename = "view-transition-image-pair")]
        ViewTransitionImagePair,
        #[serde(rename = "view-transition-old")]
        ViewTransitionOld,
        #[serde(rename = "view-transition-new")]
        ViewTransitionNew,
    }
    ///Shadow root type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ShadowRootType {
        #[serde(rename = "user-agent")]
        UserAgent,
        #[serde(rename = "open")]
        Open,
        #[serde(rename = "closed")]
        Closed,
    }
    ///Document compatibility mode.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CompatibilityMode {
        #[serde(rename = "QuirksMode")]
        QuirksMode,
        #[serde(rename = "LimitedQuirksMode")]
        LimitedQuirksMode,
        #[serde(rename = "NoQuirksMode")]
        NoQuirksMode,
    }
    ///ContainerSelector physical axes
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PhysicalAxes {
        #[serde(rename = "Horizontal")]
        Horizontal,
        #[serde(rename = "Vertical")]
        Vertical,
        #[serde(rename = "Both")]
        Both,
    }
    ///ContainerSelector logical axes
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum LogicalAxes {
        #[serde(rename = "Inline")]
        Inline,
        #[serde(rename = "Block")]
        Block,
        #[serde(rename = "Both")]
        Both,
    }
    ///DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
    ///DOMNode is a base node mirror type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Node {
        ///Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
        ///will only push node with given `id` once. It is aware of all requested nodes and will only
        ///fire DOM events for nodes known to the client.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///The id of the parent node if any.
        #[serde(rename = "parentId")]
        pub parent_id: Option<NodeId>,
        ///The BackendNodeId for this node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: BackendNodeId,
        ///`Node`'s nodeType.
        #[serde(rename = "nodeType")]
        pub node_type: i64,
        ///`Node`'s nodeName.
        #[serde(rename = "nodeName")]
        pub node_name: String,
        ///`Node`'s localName.
        #[serde(rename = "localName")]
        pub local_name: String,
        ///`Node`'s nodeValue.
        #[serde(rename = "nodeValue")]
        pub node_value: String,
        ///Child count for `Container` nodes.
        #[serde(rename = "childNodeCount")]
        pub child_node_count: Option<i64>,
        ///Child nodes of this node when requested with children.
        #[serde(rename = "children")]
        pub children: Option<Vec<Node>>,
        ///Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
        #[serde(rename = "attributes")]
        pub attributes: Option<Vec<String>>,
        ///Document URL that `Document` or `FrameOwner` node points to.
        #[serde(rename = "documentURL")]
        pub document_url: Option<String>,
        ///Base URL that `Document` or `FrameOwner` node uses for URL completion.
        #[serde(rename = "baseURL")]
        pub base_url: Option<String>,
        ///`DocumentType`'s publicId.
        #[serde(rename = "publicId")]
        pub public_id: Option<String>,
        ///`DocumentType`'s systemId.
        #[serde(rename = "systemId")]
        pub system_id: Option<String>,
        ///`DocumentType`'s internalSubset.
        #[serde(rename = "internalSubset")]
        pub internal_subset: Option<String>,
        ///`Document`'s XML version in case of XML documents.
        #[serde(rename = "xmlVersion")]
        pub xml_version: Option<String>,
        ///`Attr`'s name.
        #[serde(rename = "name")]
        pub name: Option<String>,
        ///`Attr`'s value.
        #[serde(rename = "value")]
        pub value: Option<String>,
        ///Pseudo element type for this node.
        #[serde(rename = "pseudoType")]
        pub pseudo_type: Option<PseudoType>,
        ///Pseudo element identifier for this node. Only present if there is a
        ///valid pseudoType.
        #[serde(rename = "pseudoIdentifier")]
        pub pseudo_identifier: Option<String>,
        ///Shadow root type.
        #[serde(rename = "shadowRootType")]
        pub shadow_root_type: Option<ShadowRootType>,
        ///Frame ID for frame owner elements.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
        ///Content document for frame owner elements.
        #[serde(rename = "contentDocument")]
        pub content_document: Option<Box<Node>>,
        ///Shadow root list for given element host.
        #[serde(rename = "shadowRoots")]
        pub shadow_roots: Option<Vec<Node>>,
        ///Content document fragment for template elements.
        #[serde(rename = "templateContent")]
        pub template_content: Option<Box<Node>>,
        ///Pseudo elements associated with this node.
        #[serde(rename = "pseudoElements")]
        pub pseudo_elements: Option<Vec<Node>>,
        ///Deprecated, as the HTML Imports API has been removed (crbug.com/937746).
        ///This property used to return the imported document for the HTMLImport links.
        ///The property is always undefined now.
        #[deprecated]
        #[serde(rename = "importedDocument")]
        pub imported_document: Option<Box<Node>>,
        ///Distributed nodes for given insertion point.
        #[serde(rename = "distributedNodes")]
        pub distributed_nodes: Option<Vec<BackendNode>>,
        ///Whether the node is SVG.
        #[serde(rename = "isSVG")]
        pub is_svg: Option<bool>,
        #[serde(rename = "compatibilityMode")]
        pub compatibility_mode: Option<CompatibilityMode>,
        #[serde(rename = "assignedSlot")]
        pub assigned_slot: Option<BackendNode>,
    }
    ///A structure holding an RGBA color.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Rgba {
        ///The red component, in the [0-255] range.
        #[serde(rename = "r")]
        pub r: i64,
        ///The green component, in the [0-255] range.
        #[serde(rename = "g")]
        pub g: i64,
        ///The blue component, in the [0-255] range.
        #[serde(rename = "b")]
        pub b: i64,
        ///The alpha component, in the [0-1] range (default: 1).
        #[serde(rename = "a")]
        pub a: Option<f64>,
    }
    ///An array of quad vertices, x immediately followed by y for each point, points clock-wise.
    pub type Quad = Vec<f64>;
    ///Box model.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BoxModel {
        ///Content box
        #[serde(rename = "content")]
        pub content: Quad,
        ///Padding box
        #[serde(rename = "padding")]
        pub padding: Quad,
        ///Border box
        #[serde(rename = "border")]
        pub border: Quad,
        ///Margin box
        #[serde(rename = "margin")]
        pub margin: Quad,
        ///Node width
        #[serde(rename = "width")]
        pub width: i64,
        ///Node height
        #[serde(rename = "height")]
        pub height: i64,
        ///Shape outside coordinates
        #[serde(rename = "shapeOutside")]
        pub shape_outside: Option<ShapeOutsideInfo>,
    }
    ///CSS Shape Outside details.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ShapeOutsideInfo {
        ///Shape bounds
        #[serde(rename = "bounds")]
        pub bounds: Quad,
        ///Shape coordinate details
        #[serde(rename = "shape")]
        pub shape: Vec<serde_json::Value>,
        ///Margin shape bounds
        #[serde(rename = "marginShape")]
        pub margin_shape: Vec<serde_json::Value>,
    }
    ///Rectangle.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Rect {
        ///X coordinate
        #[serde(rename = "x")]
        pub x: f64,
        ///Y coordinate
        #[serde(rename = "y")]
        pub y: f64,
        ///Rectangle width
        #[serde(rename = "width")]
        pub width: f64,
        ///Rectangle height
        #[serde(rename = "height")]
        pub height: f64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CssComputedStyleProperty {
        ///Computed style property name.
        #[serde(rename = "name")]
        pub name: String,
        ///Computed style property value.
        #[serde(rename = "value")]
        pub value: String,
    }
    ///
    /// Parameter value for [CollectClassNamesFromSubtree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CollectClassNamesFromSubtreeParams {
        ///Id of the node to collect class names.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///
    /// Return value for [CollectClassNamesFromSubtree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CollectClassNamesFromSubtreeReturns {
        ///Class name list.
        #[serde(rename = "classNames")]
        pub class_names: Vec<String>,
    }
    ///Collects class names for the node with given id and all of it's child nodes.
    ///---
    ///Parameter Type: [CollectClassNamesFromSubtreeParams]
    ///Return Type: [CollectClassNamesFromSubtreeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CollectClassNamesFromSubtree;
    impl crate::util::Command for CollectClassNamesFromSubtree {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "collectClassNamesFromSubtree"
        }
    }
    ///
    /// Parameter value for [CopyTo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CopyToParams {
        ///Id of the node to copy.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Id of the element to drop the copy into.
        #[serde(rename = "targetNodeId")]
        pub target_node_id: NodeId,
        ///Drop the copy before this node (if absent, the copy becomes the last child of
        ///`targetNodeId`).
        #[serde(rename = "insertBeforeNodeId")]
        pub insert_before_node_id: Option<NodeId>,
    }
    ///
    /// Return value for [CopyTo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CopyToReturns {
        ///Id of the node clone.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Creates a deep copy of the specified node and places it into the target container before the
    ///given anchor.
    ///---
    ///Parameter Type: [CopyToParams]
    ///Return Type: [CopyToReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CopyTo;
    impl crate::util::Command for CopyTo {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "copyTo"
        }
    }
    ///
    /// Parameter value for [DescribeNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DescribeNodeParams {
        ///Identifier of the node.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
        ///Identifier of the backend node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<BackendNodeId>,
        ///JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
        ///The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
        ///entire subtree or provide an integer larger than 0.
        #[serde(rename = "depth")]
        pub depth: Option<i64>,
        ///Whether or not iframes and shadow roots should be traversed when returning the subtree
        ///(default is false).
        #[serde(rename = "pierce")]
        pub pierce: Option<bool>,
    }
    ///
    /// Return value for [DescribeNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DescribeNodeReturns {
        ///Node description.
        #[serde(rename = "node")]
        pub node: Node,
    }
    ///Describes node given its id, does not require domain to be enabled. Does not start tracking any
    ///objects, can be used for automation.
    ///---
    ///Parameter Type: [DescribeNodeParams]
    ///Return Type: [DescribeNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DescribeNode;
    impl crate::util::Command for DescribeNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "describeNode"
        }
    }
    ///
    /// Parameter value for [ScrollIntoViewIfNeeded].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScrollIntoViewIfNeededParams {
        ///Identifier of the node.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
        ///Identifier of the backend node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<BackendNodeId>,
        ///JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
        ///The rect to be scrolled into view, relative to the node's border box, in CSS pixels.
        ///When omitted, center of the node will be used, similar to Element.scrollIntoView.
        #[serde(rename = "rect")]
        pub rect: Option<Rect>,
    }
    ///Scrolls the specified rect of the given node into view if not already visible.
    ///Note: exactly one between nodeId, backendNodeId and objectId should be passed
    ///to identify the node.
    ///---
    ///Parameter Type: [ScrollIntoViewIfNeededParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScrollIntoViewIfNeeded;
    impl crate::util::Command for ScrollIntoViewIfNeeded {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "scrollIntoViewIfNeeded"
        }
    }
    ///Disables DOM agent for the given page.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [DiscardSearchResults].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DiscardSearchResultsParams {
        ///Unique search session identifier.
        #[serde(rename = "searchId")]
        pub search_id: String,
    }
    ///Discards search results from the session with the given id. `getSearchResults` should no longer
    ///be called for that search.
    ///---
    ///Parameter Type: [DiscardSearchResultsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DiscardSearchResults;
    impl crate::util::Command for DiscardSearchResults {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "discardSearchResults"
        }
    }
    ///
    /// Enum for [Enable]'s `include_whitespace`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum EnableIncludeWhitespace {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "all")]
        All,
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        ///Whether to include whitespaces in the children array of returned Nodes.
        #[serde(rename = "includeWhitespace")]
        pub include_whitespace: Option<Option<EnableIncludeWhitespace>>,
    }
    ///Enables DOM agent for the given page.
    ///---
    ///Parameter Type: [EnableParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [Focus].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FocusParams {
        ///Identifier of the node.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
        ///Identifier of the backend node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<BackendNodeId>,
        ///JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
    }
    ///Focuses the given element.
    ///---
    ///Parameter Type: [FocusParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Focus;
    impl crate::util::Command for Focus {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "focus"
        }
    }
    ///
    /// Parameter value for [GetAttributes].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAttributesParams {
        ///Id of the node to retrieve attibutes for.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///
    /// Return value for [GetAttributes].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAttributesReturns {
        ///An interleaved array of node attribute names and values.
        #[serde(rename = "attributes")]
        pub attributes: Vec<String>,
    }
    ///Returns attributes for the specified node.
    ///---
    ///Parameter Type: [GetAttributesParams]
    ///Return Type: [GetAttributesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAttributes;
    impl crate::util::Command for GetAttributes {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getAttributes"
        }
    }
    ///
    /// Parameter value for [GetBoxModel].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBoxModelParams {
        ///Identifier of the node.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
        ///Identifier of the backend node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<BackendNodeId>,
        ///JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
    }
    ///
    /// Return value for [GetBoxModel].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBoxModelReturns {
        ///Box model for the node.
        #[serde(rename = "model")]
        pub model: BoxModel,
    }
    ///Returns boxes for the given node.
    ///---
    ///Parameter Type: [GetBoxModelParams]
    ///Return Type: [GetBoxModelReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBoxModel;
    impl crate::util::Command for GetBoxModel {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getBoxModel"
        }
    }
    ///
    /// Parameter value for [GetContentQuads].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetContentQuadsParams {
        ///Identifier of the node.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
        ///Identifier of the backend node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<BackendNodeId>,
        ///JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
    }
    ///
    /// Return value for [GetContentQuads].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetContentQuadsReturns {
        ///Quads that describe node layout relative to viewport.
        #[serde(rename = "quads")]
        pub quads: Vec<Quad>,
    }
    ///Returns quads that describe node position on the page. This method
    ///might return multiple quads for inline nodes.
    ///---
    ///Parameter Type: [GetContentQuadsParams]
    ///Return Type: [GetContentQuadsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetContentQuads;
    impl crate::util::Command for GetContentQuads {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getContentQuads"
        }
    }
    ///
    /// Parameter value for [GetDocument].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDocumentParams {
        ///The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
        ///entire subtree or provide an integer larger than 0.
        #[serde(rename = "depth")]
        pub depth: Option<i64>,
        ///Whether or not iframes and shadow roots should be traversed when returning the subtree
        ///(default is false).
        #[serde(rename = "pierce")]
        pub pierce: Option<bool>,
    }
    ///
    /// Return value for [GetDocument].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDocumentReturns {
        ///Resulting node.
        #[serde(rename = "root")]
        pub root: Node,
    }
    ///Returns the root DOM node (and optionally the subtree) to the caller.
    ///Implicitly enables the DOM domain events for the current target.
    ///---
    ///Parameter Type: [GetDocumentParams]
    ///Return Type: [GetDocumentReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDocument;
    impl crate::util::Command for GetDocument {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getDocument"
        }
    }
    ///
    /// Parameter value for [GetFlattenedDocument].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFlattenedDocumentParams {
        ///The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
        ///entire subtree or provide an integer larger than 0.
        #[serde(rename = "depth")]
        pub depth: Option<i64>,
        ///Whether or not iframes and shadow roots should be traversed when returning the subtree
        ///(default is false).
        #[serde(rename = "pierce")]
        pub pierce: Option<bool>,
    }
    ///
    /// Return value for [GetFlattenedDocument].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFlattenedDocumentReturns {
        ///Resulting node.
        #[serde(rename = "nodes")]
        pub nodes: Vec<Node>,
    }
    ///Returns the root DOM node (and optionally the subtree) to the caller.
    ///Deprecated, as it is not designed to work well with the rest of the DOM agent.
    ///Use DOMSnapshot.captureSnapshot instead.
    ///---
    ///Parameter Type: [GetFlattenedDocumentParams]
    ///Return Type: [GetFlattenedDocumentReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFlattenedDocument;
    impl crate::util::Command for GetFlattenedDocument {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getFlattenedDocument"
        }
    }
    ///
    /// Parameter value for [GetNodesForSubtreeByStyle].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodesForSubtreeByStyleParams {
        ///Node ID pointing to the root of a subtree.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///The style to filter nodes by (includes nodes if any of properties matches).
        #[serde(rename = "computedStyles")]
        pub computed_styles: Vec<CssComputedStyleProperty>,
        ///Whether or not iframes and shadow roots in the same target should be traversed when returning the
        ///results (default is false).
        #[serde(rename = "pierce")]
        pub pierce: Option<bool>,
    }
    ///
    /// Return value for [GetNodesForSubtreeByStyle].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodesForSubtreeByStyleReturns {
        ///Resulting nodes.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }
    ///Finds nodes with a given computed style in a subtree.
    ///---
    ///Parameter Type: [GetNodesForSubtreeByStyleParams]
    ///Return Type: [GetNodesForSubtreeByStyleReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodesForSubtreeByStyle;
    impl crate::util::Command for GetNodesForSubtreeByStyle {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getNodesForSubtreeByStyle"
        }
    }
    ///
    /// Parameter value for [GetNodeForLocation].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodeForLocationParams {
        ///X coordinate.
        #[serde(rename = "x")]
        pub x: i64,
        ///Y coordinate.
        #[serde(rename = "y")]
        pub y: i64,
        ///False to skip to the nearest non-UA shadow root ancestor (default: false).
        #[serde(rename = "includeUserAgentShadowDOM")]
        pub include_user_agent_shadow_dom: Option<bool>,
        ///Whether to ignore pointer-events: none on elements and hit test them.
        #[serde(rename = "ignorePointerEventsNone")]
        pub ignore_pointer_events_none: Option<bool>,
    }
    ///
    /// Return value for [GetNodeForLocation].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodeForLocationReturns {
        ///Resulting node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: BackendNodeId,
        ///Frame this node belongs to.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        ///Id of the node at given coordinates, only when enabled and requested document.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
    }
    ///Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    ///either returned or not.
    ///---
    ///Parameter Type: [GetNodeForLocationParams]
    ///Return Type: [GetNodeForLocationReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodeForLocation;
    impl crate::util::Command for GetNodeForLocation {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getNodeForLocation"
        }
    }
    ///
    /// Parameter value for [GetOuterHtml].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetOuterHtmlParams {
        ///Identifier of the node.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
        ///Identifier of the backend node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<BackendNodeId>,
        ///JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
    }
    ///
    /// Return value for [GetOuterHtml].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetOuterHtmlReturns {
        ///Outer HTML markup.
        #[serde(rename = "outerHTML")]
        pub outer_html: String,
    }
    ///Returns node's HTML markup.
    ///---
    ///Parameter Type: [GetOuterHtmlParams]
    ///Return Type: [GetOuterHtmlReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetOuterHtml;
    impl crate::util::Command for GetOuterHtml {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getOuterHTML"
        }
    }
    ///
    /// Parameter value for [GetRelayoutBoundary].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRelayoutBoundaryParams {
        ///Id of the node.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///
    /// Return value for [GetRelayoutBoundary].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRelayoutBoundaryReturns {
        ///Relayout boundary node id for the given node.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Returns the id of the nearest ancestor that is a relayout boundary.
    ///---
    ///Parameter Type: [GetRelayoutBoundaryParams]
    ///Return Type: [GetRelayoutBoundaryReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRelayoutBoundary;
    impl crate::util::Command for GetRelayoutBoundary {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getRelayoutBoundary"
        }
    }
    ///
    /// Parameter value for [GetSearchResults].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSearchResultsParams {
        ///Unique search session identifier.
        #[serde(rename = "searchId")]
        pub search_id: String,
        ///Start index of the search result to be returned.
        #[serde(rename = "fromIndex")]
        pub from_index: i64,
        ///End index of the search result to be returned.
        #[serde(rename = "toIndex")]
        pub to_index: i64,
    }
    ///
    /// Return value for [GetSearchResults].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSearchResultsReturns {
        ///Ids of the search result nodes.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }
    ///Returns search results from given `fromIndex` to given `toIndex` from the search with the given
    ///identifier.
    ///---
    ///Parameter Type: [GetSearchResultsParams]
    ///Return Type: [GetSearchResultsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSearchResults;
    impl crate::util::Command for GetSearchResults {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getSearchResults"
        }
    }
    ///Hides any highlight.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HideHighlight;
    impl crate::util::Command for HideHighlight {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "hideHighlight"
        }
    }
    ///Highlights DOM node.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightNode;
    impl crate::util::Command for HighlightNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "highlightNode"
        }
    }
    ///Highlights given rectangle.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightRect;
    impl crate::util::Command for HighlightRect {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "highlightRect"
        }
    }
    ///Marks last undoable state.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MarkUndoableState;
    impl crate::util::Command for MarkUndoableState {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "markUndoableState"
        }
    }
    ///
    /// Parameter value for [MoveTo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MoveToParams {
        ///Id of the node to move.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Id of the element to drop the moved node into.
        #[serde(rename = "targetNodeId")]
        pub target_node_id: NodeId,
        ///Drop node before this one (if absent, the moved node becomes the last child of
        ///`targetNodeId`).
        #[serde(rename = "insertBeforeNodeId")]
        pub insert_before_node_id: Option<NodeId>,
    }
    ///
    /// Return value for [MoveTo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MoveToReturns {
        ///New id of the moved node.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Moves node into the new container, places it before the given anchor.
    ///---
    ///Parameter Type: [MoveToParams]
    ///Return Type: [MoveToReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MoveTo;
    impl crate::util::Command for MoveTo {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "moveTo"
        }
    }
    ///
    /// Parameter value for [PerformSearch].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PerformSearchParams {
        ///Plain text or query selector or XPath search query.
        #[serde(rename = "query")]
        pub query: String,
        ///True to search in user agent shadow DOM.
        #[serde(rename = "includeUserAgentShadowDOM")]
        pub include_user_agent_shadow_dom: Option<bool>,
    }
    ///
    /// Return value for [PerformSearch].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PerformSearchReturns {
        ///Unique search session identifier.
        #[serde(rename = "searchId")]
        pub search_id: String,
        ///Number of search results.
        #[serde(rename = "resultCount")]
        pub result_count: i64,
    }
    ///Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
    ///`cancelSearch` to end this search session.
    ///---
    ///Parameter Type: [PerformSearchParams]
    ///Return Type: [PerformSearchReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PerformSearch;
    impl crate::util::Command for PerformSearch {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "performSearch"
        }
    }
    ///
    /// Parameter value for [PushNodeByPathToFrontend].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PushNodeByPathToFrontendParams {
        ///Path to node in the proprietary format.
        #[serde(rename = "path")]
        pub path: String,
    }
    ///
    /// Return value for [PushNodeByPathToFrontend].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PushNodeByPathToFrontendReturns {
        ///Id of the node for given path.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Requests that the node is sent to the caller given its path. // FIXME, use XPath
    ///---
    ///Parameter Type: [PushNodeByPathToFrontendParams]
    ///Return Type: [PushNodeByPathToFrontendReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PushNodeByPathToFrontend;
    impl crate::util::Command for PushNodeByPathToFrontend {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "pushNodeByPathToFrontend"
        }
    }
    ///
    /// Parameter value for [PushNodesByBackendIdsToFrontend].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PushNodesByBackendIdsToFrontendParams {
        ///The array of backend node ids.
        #[serde(rename = "backendNodeIds")]
        pub backend_node_ids: Vec<BackendNodeId>,
    }
    ///
    /// Return value for [PushNodesByBackendIdsToFrontend].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PushNodesByBackendIdsToFrontendReturns {
        ///The array of ids of pushed nodes that correspond to the backend ids specified in
        ///backendNodeIds.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }
    ///Requests that a batch of nodes is sent to the caller given their backend node ids.
    ///---
    ///Parameter Type: [PushNodesByBackendIdsToFrontendParams]
    ///Return Type: [PushNodesByBackendIdsToFrontendReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PushNodesByBackendIdsToFrontend;
    impl crate::util::Command for PushNodesByBackendIdsToFrontend {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "pushNodesByBackendIdsToFrontend"
        }
    }
    ///
    /// Parameter value for [QuerySelector].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QuerySelectorParams {
        ///Id of the node to query upon.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Selector string.
        #[serde(rename = "selector")]
        pub selector: String,
    }
    ///
    /// Return value for [QuerySelector].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QuerySelectorReturns {
        ///Query selector result.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Executes `querySelector` on a given node.
    ///---
    ///Parameter Type: [QuerySelectorParams]
    ///Return Type: [QuerySelectorReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QuerySelector;
    impl crate::util::Command for QuerySelector {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "querySelector"
        }
    }
    ///
    /// Parameter value for [QuerySelectorAll].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QuerySelectorAllParams {
        ///Id of the node to query upon.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Selector string.
        #[serde(rename = "selector")]
        pub selector: String,
    }
    ///
    /// Return value for [QuerySelectorAll].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QuerySelectorAllReturns {
        ///Query selector result.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }
    ///Executes `querySelectorAll` on a given node.
    ///---
    ///Parameter Type: [QuerySelectorAllParams]
    ///Return Type: [QuerySelectorAllReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QuerySelectorAll;
    impl crate::util::Command for QuerySelectorAll {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "querySelectorAll"
        }
    }
    ///
    /// Return value for [GetTopLayerElements].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTopLayerElementsReturns {
        ///NodeIds of top layer elements
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }
    ///Returns NodeIds of current top layer elements.
    ///Top layer is rendered closest to the user within a viewport, therefore its elements always
    ///appear on top of all other content.
    ///---
    ///Return Type: [GetTopLayerElementsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTopLayerElements;
    impl crate::util::Command for GetTopLayerElements {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getTopLayerElements"
        }
    }
    ///Re-does the last undone action.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Redo;
    impl crate::util::Command for Redo {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "redo"
        }
    }
    ///
    /// Parameter value for [RemoveAttribute].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveAttributeParams {
        ///Id of the element to remove attribute from.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Name of the attribute to remove.
        #[serde(rename = "name")]
        pub name: String,
    }
    ///Removes attribute with given name from an element with given id.
    ///---
    ///Parameter Type: [RemoveAttributeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveAttribute;
    impl crate::util::Command for RemoveAttribute {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeAttribute"
        }
    }
    ///
    /// Parameter value for [RemoveNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveNodeParams {
        ///Id of the node to remove.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Removes node with given id.
    ///---
    ///Parameter Type: [RemoveNodeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveNode;
    impl crate::util::Command for RemoveNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeNode"
        }
    }
    ///
    /// Parameter value for [RequestChildNodes].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestChildNodesParams {
        ///Id of the node to get children for.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
        ///entire subtree or provide an integer larger than 0.
        #[serde(rename = "depth")]
        pub depth: Option<i64>,
        ///Whether or not iframes and shadow roots should be traversed when returning the sub-tree
        ///(default is false).
        #[serde(rename = "pierce")]
        pub pierce: Option<bool>,
    }
    ///Requests that children of the node with given id are returned to the caller in form of
    ///`setChildNodes` events where not only immediate children are retrieved, but all children down to
    ///the specified depth.
    ///---
    ///Parameter Type: [RequestChildNodesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestChildNodes;
    impl crate::util::Command for RequestChildNodes {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestChildNodes"
        }
    }
    ///
    /// Parameter value for [RequestNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestNodeParams {
        ///JavaScript object id to convert into node.
        #[serde(rename = "objectId")]
        pub object_id: crate::protocol_test::runtime::RemoteObjectId,
    }
    ///
    /// Return value for [RequestNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestNodeReturns {
        ///Node id for given object.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Requests that the node is sent to the caller given the JavaScript node object reference. All
    ///nodes that form the path from the node to the root are also sent to the client as a series of
    ///`setChildNodes` notifications.
    ///---
    ///Parameter Type: [RequestNodeParams]
    ///Return Type: [RequestNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestNode;
    impl crate::util::Command for RequestNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestNode"
        }
    }
    ///
    /// Parameter value for [ResolveNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveNodeParams {
        ///Id of the node to resolve.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
        ///Backend identifier of the node to resolve.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///Symbolic group name that can be used to release multiple objects.
        #[serde(rename = "objectGroup")]
        pub object_group: Option<String>,
        ///Execution context in which to resolve the node.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<
            crate::protocol_test::runtime::ExecutionContextId,
        >,
    }
    ///
    /// Return value for [ResolveNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveNodeReturns {
        ///JavaScript object wrapper for given node.
        #[serde(rename = "object")]
        pub object: crate::protocol_test::runtime::RemoteObject,
    }
    ///Resolves the JavaScript node object for a given NodeId or BackendNodeId.
    ///---
    ///Parameter Type: [ResolveNodeParams]
    ///Return Type: [ResolveNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveNode;
    impl crate::util::Command for ResolveNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resolveNode"
        }
    }
    ///
    /// Parameter value for [SetAttributeValue].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttributeValueParams {
        ///Id of the element to set attribute for.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Attribute name.
        #[serde(rename = "name")]
        pub name: String,
        ///Attribute value.
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Sets attribute for an element with given id.
    ///---
    ///Parameter Type: [SetAttributeValueParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttributeValue;
    impl crate::util::Command for SetAttributeValue {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAttributeValue"
        }
    }
    ///
    /// Parameter value for [SetAttributesAsText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttributesAsTextParams {
        ///Id of the element to set attributes for.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Text with a number of attributes. Will parse this text using HTML parser.
        #[serde(rename = "text")]
        pub text: String,
        ///Attribute name to replace with new attributes derived from text in case text parsed
        ///successfully.
        #[serde(rename = "name")]
        pub name: Option<String>,
    }
    ///Sets attributes on element with given id. This method is useful when user edits some existing
    ///attribute value and types in several attribute name/value pairs.
    ///---
    ///Parameter Type: [SetAttributesAsTextParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttributesAsText;
    impl crate::util::Command for SetAttributesAsText {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAttributesAsText"
        }
    }
    ///
    /// Parameter value for [SetFileInputFiles].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetFileInputFilesParams {
        ///Array of file paths to set.
        #[serde(rename = "files")]
        pub files: Vec<String>,
        ///Identifier of the node.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
        ///Identifier of the backend node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<BackendNodeId>,
        ///JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
    }
    ///Sets files for the given file input element.
    ///---
    ///Parameter Type: [SetFileInputFilesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetFileInputFiles;
    impl crate::util::Command for SetFileInputFiles {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setFileInputFiles"
        }
    }
    ///
    /// Parameter value for [SetNodeStackTracesEnabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNodeStackTracesEnabledParams {
        ///Enable or disable.
        #[serde(rename = "enable")]
        pub enable: bool,
    }
    ///Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
    ///---
    ///Parameter Type: [SetNodeStackTracesEnabledParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNodeStackTracesEnabled;
    impl crate::util::Command for SetNodeStackTracesEnabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setNodeStackTracesEnabled"
        }
    }
    ///
    /// Parameter value for [GetNodeStackTraces].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodeStackTracesParams {
        ///Id of the node to get stack traces for.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///
    /// Return value for [GetNodeStackTraces].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodeStackTracesReturns {
        ///Creation stack trace, if available.
        #[serde(rename = "creation")]
        pub creation: Option<crate::protocol_test::runtime::StackTrace>,
    }
    ///Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
    ///---
    ///Parameter Type: [GetNodeStackTracesParams]
    ///Return Type: [GetNodeStackTracesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNodeStackTraces;
    impl crate::util::Command for GetNodeStackTraces {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getNodeStackTraces"
        }
    }
    ///
    /// Parameter value for [GetFileInfo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFileInfoParams {
        ///JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        pub object_id: crate::protocol_test::runtime::RemoteObjectId,
    }
    ///
    /// Return value for [GetFileInfo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFileInfoReturns {
        #[serde(rename = "path")]
        pub path: String,
    }
    ///Returns file information for the given
    ///File wrapper.
    ///---
    ///Parameter Type: [GetFileInfoParams]
    ///Return Type: [GetFileInfoReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFileInfo;
    impl crate::util::Command for GetFileInfo {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getFileInfo"
        }
    }
    ///
    /// Parameter value for [SetInspectedNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInspectedNodeParams {
        ///DOM node id to be accessible by means of $x command line API.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Enables console to refer to the node with given id via $x (see Command Line API for more details
    ///$x functions).
    ///---
    ///Parameter Type: [SetInspectedNodeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInspectedNode;
    impl crate::util::Command for SetInspectedNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setInspectedNode"
        }
    }
    ///
    /// Parameter value for [SetNodeName].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNodeNameParams {
        ///Id of the node to set name for.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///New node's name.
        #[serde(rename = "name")]
        pub name: String,
    }
    ///
    /// Return value for [SetNodeName].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNodeNameReturns {
        ///New node's id.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Sets node name for a node with given id.
    ///---
    ///Parameter Type: [SetNodeNameParams]
    ///Return Type: [SetNodeNameReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNodeName;
    impl crate::util::Command for SetNodeName {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setNodeName"
        }
    }
    ///
    /// Parameter value for [SetNodeValue].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNodeValueParams {
        ///Id of the node to set value for.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///New node's value.
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Sets node value for a node with given id.
    ///---
    ///Parameter Type: [SetNodeValueParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNodeValue;
    impl crate::util::Command for SetNodeValue {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setNodeValue"
        }
    }
    ///
    /// Parameter value for [SetOuterHtml].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetOuterHtmlParams {
        ///Id of the node to set markup for.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Outer HTML markup to set.
        #[serde(rename = "outerHTML")]
        pub outer_html: String,
    }
    ///Sets node HTML markup, returns new node id.
    ///---
    ///Parameter Type: [SetOuterHtmlParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetOuterHtml;
    impl crate::util::Command for SetOuterHtml {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setOuterHTML"
        }
    }
    ///Undoes the last performed action.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Undo;
    impl crate::util::Command for Undo {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "undo"
        }
    }
    ///
    /// Parameter value for [GetFrameOwner].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFrameOwnerParams {
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
    }
    ///
    /// Return value for [GetFrameOwner].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFrameOwnerReturns {
        ///Resulting node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: BackendNodeId,
        ///Id of the node at given coordinates, only when enabled and requested document.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
    }
    ///Returns iframe node that owns iframe with the given domain.
    ///---
    ///Parameter Type: [GetFrameOwnerParams]
    ///Return Type: [GetFrameOwnerReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFrameOwner;
    impl crate::util::Command for GetFrameOwner {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getFrameOwner"
        }
    }
    ///
    /// Parameter value for [GetContainerForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetContainerForNodeParams {
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        #[serde(rename = "containerName")]
        pub container_name: Option<String>,
        #[serde(rename = "physicalAxes")]
        pub physical_axes: Option<PhysicalAxes>,
        #[serde(rename = "logicalAxes")]
        pub logical_axes: Option<LogicalAxes>,
    }
    ///
    /// Return value for [GetContainerForNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetContainerForNodeReturns {
        ///The container node for the given node, or null if not found.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
    }
    ///Returns the query container of the given node based on container query
    ///conditions: containerName, physical, and logical axes. If no axes are
    ///provided, the style container is returned, which is the direct parent or the
    ///closest element with a matching container-name.
    ///---
    ///Parameter Type: [GetContainerForNodeParams]
    ///Return Type: [GetContainerForNodeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetContainerForNode;
    impl crate::util::Command for GetContainerForNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getContainerForNode"
        }
    }
    ///
    /// Parameter value for [GetQueryingDescendantsForContainer].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetQueryingDescendantsForContainerParams {
        ///Id of the container node to find querying descendants from.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///
    /// Return value for [GetQueryingDescendantsForContainer].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetQueryingDescendantsForContainerReturns {
        ///Descendant nodes with container queries against the given container.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }
    ///Returns the descendants of a container query container that have
    ///container queries against this container.
    ///---
    ///Parameter Type: [GetQueryingDescendantsForContainerParams]
    ///Return Type: [GetQueryingDescendantsForContainerReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetQueryingDescendantsForContainer;
    impl crate::util::Command for GetQueryingDescendantsForContainer {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getQueryingDescendantsForContainer"
        }
    }
    ///Fired when `Element`'s attribute is modified.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttributeModifiedEvent {
        ///Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///Attribute name.
        #[serde(rename = "name")]
        pub name: String,
        ///Attribute value.
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Fired when `Element`'s attribute is removed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttributeRemovedEvent {
        ///Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///A ttribute name.
        #[serde(rename = "name")]
        pub name: String,
    }
    ///Mirrors `DOMCharacterDataModified` event.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CharacterDataModifiedEvent {
        ///Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///New text value.
        #[serde(rename = "characterData")]
        pub character_data: String,
    }
    ///Fired when `Container`'s child node count has changed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ChildNodeCountUpdatedEvent {
        ///Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        ///New node count.
        #[serde(rename = "childNodeCount")]
        pub child_node_count: i64,
    }
    ///Mirrors `DOMNodeInserted` event.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ChildNodeInsertedEvent {
        ///Id of the node that has changed.
        #[serde(rename = "parentNodeId")]
        pub parent_node_id: NodeId,
        ///Id of the previous sibling.
        #[serde(rename = "previousNodeId")]
        pub previous_node_id: NodeId,
        ///Inserted node data.
        #[serde(rename = "node")]
        pub node: Node,
    }
    ///Mirrors `DOMNodeRemoved` event.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ChildNodeRemovedEvent {
        ///Parent id.
        #[serde(rename = "parentNodeId")]
        pub parent_node_id: NodeId,
        ///Id of the node that has been removed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }
    ///Called when distribution is changed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DistributedNodesUpdatedEvent {
        ///Insertion point where distributed nodes were updated.
        #[serde(rename = "insertionPointId")]
        pub insertion_point_id: NodeId,
        ///Distributed nodes for given insertion point.
        #[serde(rename = "distributedNodes")]
        pub distributed_nodes: Vec<BackendNode>,
    }
    ///Fired when `Document` has been totally updated. Node ids are no longer valid.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DocumentUpdatedEvent {}
    ///Fired when `Element`'s inline style is modified via a CSS property modification.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InlineStyleInvalidatedEvent {
        ///Ids of the nodes for which the inline styles have been invalidated.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }
    ///Called when a pseudo element is added to an element.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PseudoElementAddedEvent {
        ///Pseudo element's parent element id.
        #[serde(rename = "parentId")]
        pub parent_id: NodeId,
        ///The added pseudo element.
        #[serde(rename = "pseudoElement")]
        pub pseudo_element: Node,
    }
    ///Called when top layer elements are changed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TopLayerElementsUpdatedEvent {}
    ///Called when a pseudo element is removed from an element.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PseudoElementRemovedEvent {
        ///Pseudo element's parent element id.
        #[serde(rename = "parentId")]
        pub parent_id: NodeId,
        ///The removed pseudo element id.
        #[serde(rename = "pseudoElementId")]
        pub pseudo_element_id: NodeId,
    }
    ///Fired when backend wants to provide client with the missing DOM structure. This happens upon
    ///most of the calls requesting node ids.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetChildNodesEvent {
        ///Parent node id to populate with children.
        #[serde(rename = "parentId")]
        pub parent_id: NodeId,
        ///Child nodes array.
        #[serde(rename = "nodes")]
        pub nodes: Vec<Node>,
    }
    ///Called when shadow root is popped from the element.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ShadowRootPoppedEvent {
        ///Host element id.
        #[serde(rename = "hostId")]
        pub host_id: NodeId,
        ///Shadow root id.
        #[serde(rename = "rootId")]
        pub root_id: NodeId,
    }
    ///Called when shadow root is pushed into the element.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ShadowRootPushedEvent {
        ///Host element id.
        #[serde(rename = "hostId")]
        pub host_id: NodeId,
        ///Shadow root.
        #[serde(rename = "root")]
        pub root: Node,
    }
}
///DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
///execution will stop on these operations as if there was a regular breakpoint set.
pub mod dom_debugger {
    ///DOM breakpoint type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DomBreakpointType {
        #[serde(rename = "subtree-modified")]
        SubtreeModified,
        #[serde(rename = "attribute-modified")]
        AttributeModified,
        #[serde(rename = "node-removed")]
        NodeRemoved,
    }
    ///CSP Violation type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CspViolationType {
        #[serde(rename = "trustedtype-sink-violation")]
        TrustedtypeSinkViolation,
        #[serde(rename = "trustedtype-policy-violation")]
        TrustedtypePolicyViolation,
    }
    ///Object event listener.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EventListener {
        ///`EventListener`'s type.
        #[serde(rename = "type")]
        pub type_: String,
        ///`EventListener`'s useCapture.
        #[serde(rename = "useCapture")]
        pub use_capture: bool,
        ///`EventListener`'s passive flag.
        #[serde(rename = "passive")]
        pub passive: bool,
        ///`EventListener`'s once flag.
        #[serde(rename = "once")]
        pub once: bool,
        ///Script id of the handler code.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///Line number in the script (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        ///Column number in the script (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
        ///Event handler function value.
        #[serde(rename = "handler")]
        pub handler: Option<crate::protocol_test::runtime::RemoteObject>,
        ///Event original handler function value.
        #[serde(rename = "originalHandler")]
        pub original_handler: Option<crate::protocol_test::runtime::RemoteObject>,
        ///Node the listener is added to (if any).
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
    }
    ///
    /// Parameter value for [GetEventListeners].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetEventListenersParams {
        ///Identifier of the object to return listeners for.
        #[serde(rename = "objectId")]
        pub object_id: crate::protocol_test::runtime::RemoteObjectId,
        ///The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the
        ///entire subtree or provide an integer larger than 0.
        #[serde(rename = "depth")]
        pub depth: Option<i64>,
        ///Whether or not iframes and shadow roots should be traversed when returning the subtree
        ///(default is false). Reports listeners for all contexts if pierce is enabled.
        #[serde(rename = "pierce")]
        pub pierce: Option<bool>,
    }
    ///
    /// Return value for [GetEventListeners].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetEventListenersReturns {
        ///Array of relevant listeners.
        #[serde(rename = "listeners")]
        pub listeners: Vec<EventListener>,
    }
    ///Returns event listeners of the given object.
    ///---
    ///Parameter Type: [GetEventListenersParams]
    ///Return Type: [GetEventListenersReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetEventListeners;
    impl crate::util::Command for GetEventListeners {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getEventListeners"
        }
    }
    ///
    /// Parameter value for [RemoveDomBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveDomBreakpointParams {
        ///Identifier of the node to remove breakpoint from.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
        ///Type of the breakpoint to remove.
        #[serde(rename = "type")]
        pub type_: DomBreakpointType,
    }
    ///Removes DOM breakpoint that was set using `setDOMBreakpoint`.
    ///---
    ///Parameter Type: [RemoveDomBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveDomBreakpoint;
    impl crate::util::Command for RemoveDomBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeDOMBreakpoint"
        }
    }
    ///
    /// Parameter value for [RemoveEventListenerBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveEventListenerBreakpointParams {
        ///Event name.
        #[serde(rename = "eventName")]
        pub event_name: String,
        ///EventTarget interface name.
        #[serde(rename = "targetName")]
        pub target_name: Option<String>,
    }
    ///Removes breakpoint on particular DOM event.
    ///---
    ///Parameter Type: [RemoveEventListenerBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveEventListenerBreakpoint;
    impl crate::util::Command for RemoveEventListenerBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeEventListenerBreakpoint"
        }
    }
    ///
    /// Parameter value for [RemoveInstrumentationBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveInstrumentationBreakpointParams {
        ///Instrumentation name to stop on.
        #[serde(rename = "eventName")]
        pub event_name: String,
    }
    ///Removes breakpoint on particular native event.
    ///---
    ///Parameter Type: [RemoveInstrumentationBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveInstrumentationBreakpoint;
    impl crate::util::Command for RemoveInstrumentationBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeInstrumentationBreakpoint"
        }
    }
    ///
    /// Parameter value for [RemoveXhrBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveXhrBreakpointParams {
        ///Resource URL substring.
        #[serde(rename = "url")]
        pub url: String,
    }
    ///Removes breakpoint from XMLHttpRequest.
    ///---
    ///Parameter Type: [RemoveXhrBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveXhrBreakpoint;
    impl crate::util::Command for RemoveXhrBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeXHRBreakpoint"
        }
    }
    ///
    /// Parameter value for [SetBreakOnCspViolation].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakOnCspViolationParams {
        ///CSP Violations to stop upon.
        #[serde(rename = "violationTypes")]
        pub violation_types: Vec<CspViolationType>,
    }
    ///Sets breakpoint on particular CSP violations.
    ///---
    ///Parameter Type: [SetBreakOnCspViolationParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakOnCspViolation;
    impl crate::util::Command for SetBreakOnCspViolation {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBreakOnCSPViolation"
        }
    }
    ///
    /// Parameter value for [SetDomBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDomBreakpointParams {
        ///Identifier of the node to set breakpoint on.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
        ///Type of the operation to stop upon.
        #[serde(rename = "type")]
        pub type_: DomBreakpointType,
    }
    ///Sets breakpoint on particular operation with DOM.
    ///---
    ///Parameter Type: [SetDomBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDomBreakpoint;
    impl crate::util::Command for SetDomBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDOMBreakpoint"
        }
    }
    ///
    /// Parameter value for [SetEventListenerBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEventListenerBreakpointParams {
        ///DOM Event name to stop on (any DOM event will do).
        #[serde(rename = "eventName")]
        pub event_name: String,
        ///EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on any
        ///EventTarget.
        #[serde(rename = "targetName")]
        pub target_name: Option<String>,
    }
    ///Sets breakpoint on particular DOM event.
    ///---
    ///Parameter Type: [SetEventListenerBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEventListenerBreakpoint;
    impl crate::util::Command for SetEventListenerBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setEventListenerBreakpoint"
        }
    }
    ///
    /// Parameter value for [SetInstrumentationBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInstrumentationBreakpointParams {
        ///Instrumentation name to stop on.
        #[serde(rename = "eventName")]
        pub event_name: String,
    }
    ///Sets breakpoint on particular native event.
    ///---
    ///Parameter Type: [SetInstrumentationBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInstrumentationBreakpoint;
    impl crate::util::Command for SetInstrumentationBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setInstrumentationBreakpoint"
        }
    }
    ///
    /// Parameter value for [SetXhrBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetXhrBreakpointParams {
        ///Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
        #[serde(rename = "url")]
        pub url: String,
    }
    ///Sets breakpoint on XMLHttpRequest.
    ///---
    ///Parameter Type: [SetXhrBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetXhrBreakpoint;
    impl crate::util::Command for SetXhrBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setXHRBreakpoint"
        }
    }
}
///EventBreakpoints permits setting breakpoints on particular operations and
///events in targets that run JavaScript but do not have a DOM.
///JavaScript execution will stop on these operations as if there was a regular
///breakpoint set.
pub mod event_breakpoints {
    ///
    /// Parameter value for [SetInstrumentationBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInstrumentationBreakpointParams {
        ///Instrumentation name to stop on.
        #[serde(rename = "eventName")]
        pub event_name: String,
    }
    ///Sets breakpoint on particular native event.
    ///---
    ///Parameter Type: [SetInstrumentationBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInstrumentationBreakpoint;
    impl crate::util::Command for SetInstrumentationBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setInstrumentationBreakpoint"
        }
    }
    ///
    /// Parameter value for [RemoveInstrumentationBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveInstrumentationBreakpointParams {
        ///Instrumentation name to stop on.
        #[serde(rename = "eventName")]
        pub event_name: String,
    }
    ///Removes breakpoint on particular native event.
    ///---
    ///Parameter Type: [RemoveInstrumentationBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveInstrumentationBreakpoint;
    impl crate::util::Command for RemoveInstrumentationBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeInstrumentationBreakpoint"
        }
    }
}
///This domain facilitates obtaining document snapshots with DOM, layout, and style information.
pub mod dom_snapshot {
    ///A Node in the DOM tree.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DomNode {
        ///`Node`'s nodeType.
        #[serde(rename = "nodeType")]
        pub node_type: i64,
        ///`Node`'s nodeName.
        #[serde(rename = "nodeName")]
        pub node_name: String,
        ///`Node`'s nodeValue.
        #[serde(rename = "nodeValue")]
        pub node_value: String,
        ///Only set for textarea elements, contains the text value.
        #[serde(rename = "textValue")]
        pub text_value: Option<String>,
        ///Only set for input elements, contains the input's associated text value.
        #[serde(rename = "inputValue")]
        pub input_value: Option<String>,
        ///Only set for radio and checkbox input elements, indicates if the element has been checked
        #[serde(rename = "inputChecked")]
        pub input_checked: Option<bool>,
        ///Only set for option elements, indicates if the element has been selected
        #[serde(rename = "optionSelected")]
        pub option_selected: Option<bool>,
        ///`Node`'s id, corresponds to DOM.Node.backendNodeId.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: crate::protocol_test::dom::BackendNodeId,
        ///The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
        ///any.
        #[serde(rename = "childNodeIndexes")]
        pub child_node_indexes: Option<Vec<i64>>,
        ///Attributes of an `Element` node.
        #[serde(rename = "attributes")]
        pub attributes: Option<Vec<NameValue>>,
        ///Indexes of pseudo elements associated with this node in the `domNodes` array returned by
        ///`getSnapshot`, if any.
        #[serde(rename = "pseudoElementIndexes")]
        pub pseudo_element_indexes: Option<Vec<i64>>,
        ///The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
        ///`getSnapshot`, if any.
        #[serde(rename = "layoutNodeIndex")]
        pub layout_node_index: Option<i64>,
        ///Document URL that `Document` or `FrameOwner` node points to.
        #[serde(rename = "documentURL")]
        pub document_url: Option<String>,
        ///Base URL that `Document` or `FrameOwner` node uses for URL completion.
        #[serde(rename = "baseURL")]
        pub base_url: Option<String>,
        ///Only set for documents, contains the document's content language.
        #[serde(rename = "contentLanguage")]
        pub content_language: Option<String>,
        ///Only set for documents, contains the document's character set encoding.
        #[serde(rename = "documentEncoding")]
        pub document_encoding: Option<String>,
        ///`DocumentType` node's publicId.
        #[serde(rename = "publicId")]
        pub public_id: Option<String>,
        ///`DocumentType` node's systemId.
        #[serde(rename = "systemId")]
        pub system_id: Option<String>,
        ///Frame ID for frame owner elements and also for the document node.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
        ///The index of a frame owner element's content document in the `domNodes` array returned by
        ///`getSnapshot`, if any.
        #[serde(rename = "contentDocumentIndex")]
        pub content_document_index: Option<i64>,
        ///Type of a pseudo element node.
        #[serde(rename = "pseudoType")]
        pub pseudo_type: Option<crate::protocol_test::dom::PseudoType>,
        ///Shadow root type.
        #[serde(rename = "shadowRootType")]
        pub shadow_root_type: Option<crate::protocol_test::dom::ShadowRootType>,
        ///Whether this DOM node responds to mouse clicks. This includes nodes that have had click
        ///event listeners attached via JavaScript as well as anchor tags that naturally navigate when
        ///clicked.
        #[serde(rename = "isClickable")]
        pub is_clickable: Option<bool>,
        ///Details of the node's event listeners, if any.
        #[serde(rename = "eventListeners")]
        pub event_listeners: Option<
            Vec<crate::protocol_test::dom_debugger::EventListener>,
        >,
        ///The selected url for nodes with a srcset attribute.
        #[serde(rename = "currentSourceURL")]
        pub current_source_url: Option<String>,
        ///The url of the script (if any) that generates this node.
        #[serde(rename = "originURL")]
        pub origin_url: Option<String>,
        ///Scroll offsets, set when this node is a Document.
        #[serde(rename = "scrollOffsetX")]
        pub scroll_offset_x: Option<f64>,
        #[serde(rename = "scrollOffsetY")]
        pub scroll_offset_y: Option<f64>,
    }
    ///Details of post layout rendered text positions. The exact layout should not be regarded as
    ///stable and may change between versions.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InlineTextBox {
        ///The bounding box in document coordinates. Note that scroll offset of the document is ignored.
        #[serde(rename = "boundingBox")]
        pub bounding_box: crate::protocol_test::dom::Rect,
        ///The starting index in characters, for this post layout textbox substring. Characters that
        ///would be represented as a surrogate pair in UTF-16 have length 2.
        #[serde(rename = "startCharacterIndex")]
        pub start_character_index: i64,
        ///The number of characters in this post layout textbox substring. Characters that would be
        ///represented as a surrogate pair in UTF-16 have length 2.
        #[serde(rename = "numCharacters")]
        pub num_characters: i64,
    }
    ///Details of an element in the DOM tree with a LayoutObject.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LayoutTreeNode {
        ///The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
        #[serde(rename = "domNodeIndex")]
        pub dom_node_index: i64,
        ///The bounding box in document coordinates. Note that scroll offset of the document is ignored.
        #[serde(rename = "boundingBox")]
        pub bounding_box: crate::protocol_test::dom::Rect,
        ///Contents of the LayoutText, if any.
        #[serde(rename = "layoutText")]
        pub layout_text: Option<String>,
        ///The post-layout inline text nodes, if any.
        #[serde(rename = "inlineTextNodes")]
        pub inline_text_nodes: Option<Vec<InlineTextBox>>,
        ///Index into the `computedStyles` array returned by `getSnapshot`.
        #[serde(rename = "styleIndex")]
        pub style_index: Option<i64>,
        ///Global paint order index, which is determined by the stacking order of the nodes. Nodes
        ///that are painted together will have the same index. Only provided if includePaintOrder in
        ///getSnapshot was true.
        #[serde(rename = "paintOrder")]
        pub paint_order: Option<i64>,
        ///Set to true to indicate the element begins a new stacking context.
        #[serde(rename = "isStackingContext")]
        pub is_stacking_context: Option<bool>,
    }
    ///A subset of the full ComputedStyle as defined by the request whitelist.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ComputedStyle {
        ///Name/value pairs of computed style properties.
        #[serde(rename = "properties")]
        pub properties: Vec<NameValue>,
    }
    ///A name/value pair.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NameValue {
        ///Attribute/property name.
        #[serde(rename = "name")]
        pub name: String,
        ///Attribute/property value.
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Index of the string in the strings table.
    pub type StringIndex = i64;
    ///Index of the string in the strings table.
    pub type ArrayOfStrings = Vec<StringIndex>;
    ///Data that is only present on rare nodes.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RareStringData {
        #[serde(rename = "index")]
        pub index: Vec<i64>,
        #[serde(rename = "value")]
        pub value: Vec<StringIndex>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RareBooleanData {
        #[serde(rename = "index")]
        pub index: Vec<i64>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RareIntegerData {
        #[serde(rename = "index")]
        pub index: Vec<i64>,
        #[serde(rename = "value")]
        pub value: Vec<i64>,
    }
    pub type Rectangle = Vec<f64>;
    ///Document snapshot.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DocumentSnapshot {
        ///Document URL that `Document` or `FrameOwner` node points to.
        #[serde(rename = "documentURL")]
        pub document_url: StringIndex,
        ///Document title.
        #[serde(rename = "title")]
        pub title: StringIndex,
        ///Base URL that `Document` or `FrameOwner` node uses for URL completion.
        #[serde(rename = "baseURL")]
        pub base_url: StringIndex,
        ///Contains the document's content language.
        #[serde(rename = "contentLanguage")]
        pub content_language: StringIndex,
        ///Contains the document's character set encoding.
        #[serde(rename = "encodingName")]
        pub encoding_name: StringIndex,
        ///`DocumentType` node's publicId.
        #[serde(rename = "publicId")]
        pub public_id: StringIndex,
        ///`DocumentType` node's systemId.
        #[serde(rename = "systemId")]
        pub system_id: StringIndex,
        ///Frame ID for frame owner elements and also for the document node.
        #[serde(rename = "frameId")]
        pub frame_id: StringIndex,
        ///A table with dom nodes.
        #[serde(rename = "nodes")]
        pub nodes: NodeTreeSnapshot,
        ///The nodes in the layout tree.
        #[serde(rename = "layout")]
        pub layout: LayoutTreeSnapshot,
        ///The post-layout inline text nodes.
        #[serde(rename = "textBoxes")]
        pub text_boxes: TextBoxSnapshot,
        ///Horizontal scroll offset.
        #[serde(rename = "scrollOffsetX")]
        pub scroll_offset_x: Option<f64>,
        ///Vertical scroll offset.
        #[serde(rename = "scrollOffsetY")]
        pub scroll_offset_y: Option<f64>,
        ///Document content width.
        #[serde(rename = "contentWidth")]
        pub content_width: Option<f64>,
        ///Document content height.
        #[serde(rename = "contentHeight")]
        pub content_height: Option<f64>,
    }
    ///Table containing nodes.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NodeTreeSnapshot {
        ///Parent node index.
        #[serde(rename = "parentIndex")]
        pub parent_index: Option<Vec<i64>>,
        ///`Node`'s nodeType.
        #[serde(rename = "nodeType")]
        pub node_type: Option<Vec<i64>>,
        ///Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum.
        #[serde(rename = "shadowRootType")]
        pub shadow_root_type: Option<RareStringData>,
        ///`Node`'s nodeName.
        #[serde(rename = "nodeName")]
        pub node_name: Option<Vec<StringIndex>>,
        ///`Node`'s nodeValue.
        #[serde(rename = "nodeValue")]
        pub node_value: Option<Vec<StringIndex>>,
        ///`Node`'s id, corresponds to DOM.Node.backendNodeId.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<Vec<crate::protocol_test::dom::BackendNodeId>>,
        ///Attributes of an `Element` node. Flatten name, value pairs.
        #[serde(rename = "attributes")]
        pub attributes: Option<Vec<ArrayOfStrings>>,
        ///Only set for textarea elements, contains the text value.
        #[serde(rename = "textValue")]
        pub text_value: Option<RareStringData>,
        ///Only set for input elements, contains the input's associated text value.
        #[serde(rename = "inputValue")]
        pub input_value: Option<RareStringData>,
        ///Only set for radio and checkbox input elements, indicates if the element has been checked
        #[serde(rename = "inputChecked")]
        pub input_checked: Option<RareBooleanData>,
        ///Only set for option elements, indicates if the element has been selected
        #[serde(rename = "optionSelected")]
        pub option_selected: Option<RareBooleanData>,
        ///The index of the document in the list of the snapshot documents.
        #[serde(rename = "contentDocumentIndex")]
        pub content_document_index: Option<RareIntegerData>,
        ///Type of a pseudo element node.
        #[serde(rename = "pseudoType")]
        pub pseudo_type: Option<RareStringData>,
        ///Pseudo element identifier for this node. Only present if there is a
        ///valid pseudoType.
        #[serde(rename = "pseudoIdentifier")]
        pub pseudo_identifier: Option<RareStringData>,
        ///Whether this DOM node responds to mouse clicks. This includes nodes that have had click
        ///event listeners attached via JavaScript as well as anchor tags that naturally navigate when
        ///clicked.
        #[serde(rename = "isClickable")]
        pub is_clickable: Option<RareBooleanData>,
        ///The selected url for nodes with a srcset attribute.
        #[serde(rename = "currentSourceURL")]
        pub current_source_url: Option<RareStringData>,
        ///The url of the script (if any) that generates this node.
        #[serde(rename = "originURL")]
        pub origin_url: Option<RareStringData>,
    }
    ///Table of details of an element in the DOM tree with a LayoutObject.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LayoutTreeSnapshot {
        ///Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
        #[serde(rename = "nodeIndex")]
        pub node_index: Vec<i64>,
        ///Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
        #[serde(rename = "styles")]
        pub styles: Vec<ArrayOfStrings>,
        ///The absolute position bounding box.
        #[serde(rename = "bounds")]
        pub bounds: Vec<Rectangle>,
        ///Contents of the LayoutText, if any.
        #[serde(rename = "text")]
        pub text: Vec<StringIndex>,
        ///Stacking context information.
        #[serde(rename = "stackingContexts")]
        pub stacking_contexts: RareBooleanData,
        ///Global paint order index, which is determined by the stacking order of the nodes. Nodes
        ///that are painted together will have the same index. Only provided if includePaintOrder in
        ///captureSnapshot was true.
        #[serde(rename = "paintOrders")]
        pub paint_orders: Option<Vec<i64>>,
        ///The offset rect of nodes. Only available when includeDOMRects is set to true
        #[serde(rename = "offsetRects")]
        pub offset_rects: Option<Vec<Rectangle>>,
        ///The scroll rect of nodes. Only available when includeDOMRects is set to true
        #[serde(rename = "scrollRects")]
        pub scroll_rects: Option<Vec<Rectangle>>,
        ///The client rect of nodes. Only available when includeDOMRects is set to true
        #[serde(rename = "clientRects")]
        pub client_rects: Option<Vec<Rectangle>>,
        ///The list of background colors that are blended with colors of overlapping elements.
        #[serde(rename = "blendedBackgroundColors")]
        pub blended_background_colors: Option<Vec<StringIndex>>,
        ///The list of computed text opacities.
        #[serde(rename = "textColorOpacities")]
        pub text_color_opacities: Option<Vec<f64>>,
    }
    ///Table of details of the post layout rendered text positions. The exact layout should not be regarded as
    ///stable and may change between versions.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TextBoxSnapshot {
        ///Index of the layout tree node that owns this box collection.
        #[serde(rename = "layoutIndex")]
        pub layout_index: Vec<i64>,
        ///The absolute position bounding box.
        #[serde(rename = "bounds")]
        pub bounds: Vec<Rectangle>,
        ///The starting index in characters, for this post layout textbox substring. Characters that
        ///would be represented as a surrogate pair in UTF-16 have length 2.
        #[serde(rename = "start")]
        pub start: Vec<i64>,
        ///The number of characters in this post layout textbox substring. Characters that would be
        ///represented as a surrogate pair in UTF-16 have length 2.
        #[serde(rename = "length")]
        pub length: Vec<i64>,
    }
    ///Disables DOM snapshot agent for the given page.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables DOM snapshot agent for the given page.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [GetSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSnapshotParams {
        ///Whitelist of computed styles to return.
        #[serde(rename = "computedStyleWhitelist")]
        pub computed_style_whitelist: Vec<String>,
        ///Whether or not to retrieve details of DOM listeners (default false).
        #[serde(rename = "includeEventListeners")]
        pub include_event_listeners: Option<bool>,
        ///Whether to determine and include the paint order index of LayoutTreeNodes (default false).
        #[serde(rename = "includePaintOrder")]
        pub include_paint_order: Option<bool>,
        ///Whether to include UA shadow tree in the snapshot (default false).
        #[serde(rename = "includeUserAgentShadowTree")]
        pub include_user_agent_shadow_tree: Option<bool>,
    }
    ///
    /// Return value for [GetSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSnapshotReturns {
        ///The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
        #[serde(rename = "domNodes")]
        pub dom_nodes: Vec<DomNode>,
        ///The nodes in the layout tree.
        #[serde(rename = "layoutTreeNodes")]
        pub layout_tree_nodes: Vec<LayoutTreeNode>,
        ///Whitelisted ComputedStyle properties for each node in the layout tree.
        #[serde(rename = "computedStyles")]
        pub computed_styles: Vec<ComputedStyle>,
    }
    ///Returns a document snapshot, including the full DOM tree of the root node (including iframes,
    ///template contents, and imported documents) in a flattened array, as well as layout and
    ///white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
    ///flattened.
    ///---
    ///Parameter Type: [GetSnapshotParams]
    ///Return Type: [GetSnapshotReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSnapshot;
    impl crate::util::Command for GetSnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getSnapshot"
        }
    }
    ///
    /// Parameter value for [CaptureSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureSnapshotParams {
        ///Whitelist of computed styles to return.
        #[serde(rename = "computedStyles")]
        pub computed_styles: Vec<String>,
        ///Whether to include layout object paint orders into the snapshot.
        #[serde(rename = "includePaintOrder")]
        pub include_paint_order: Option<bool>,
        ///Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
        #[serde(rename = "includeDOMRects")]
        pub include_dom_rects: Option<bool>,
        ///Whether to include blended background colors in the snapshot (default: false).
        ///Blended background color is achieved by blending background colors of all elements
        ///that overlap with the current element.
        #[serde(rename = "includeBlendedBackgroundColors")]
        pub include_blended_background_colors: Option<bool>,
        ///Whether to include text color opacity in the snapshot (default: false).
        ///An element might have the opacity property set that affects the text color of the element.
        ///The final text color opacity is computed based on the opacity of all overlapping elements.
        #[serde(rename = "includeTextColorOpacities")]
        pub include_text_color_opacities: Option<bool>,
    }
    ///
    /// Return value for [CaptureSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureSnapshotReturns {
        ///The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
        #[serde(rename = "documents")]
        pub documents: Vec<DocumentSnapshot>,
        ///Shared string table that all string properties refer to with indexes.
        #[serde(rename = "strings")]
        pub strings: Vec<String>,
    }
    ///Returns a document snapshot, including the full DOM tree of the root node (including iframes,
    ///template contents, and imported documents) in a flattened array, as well as layout and
    ///white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
    ///flattened.
    ///---
    ///Parameter Type: [CaptureSnapshotParams]
    ///Return Type: [CaptureSnapshotReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureSnapshot;
    impl crate::util::Command for CaptureSnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "captureSnapshot"
        }
    }
}
///Query and modify DOM storage.
pub mod dom_storage {
    pub type SerializedStorageKey = String;
    ///DOM Storage identifier.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StorageId {
        ///Security origin for the storage.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Represents a key by which DOM Storage keys its CachedStorageAreas
        #[serde(rename = "storageKey")]
        pub storage_key: Option<SerializedStorageKey>,
        ///Whether the storage is local storage (not session storage).
        #[serde(rename = "isLocalStorage")]
        pub is_local_storage: bool,
    }
    ///DOM Storage item.
    pub type Item = Vec<String>;
    ///
    /// Parameter value for [Clear].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearParams {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Clear;
    impl crate::util::Command for Clear {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clear"
        }
    }
    ///Disables storage tracking, prevents storage events from being sent to the client.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables storage tracking, storage events will now be delivered to the client.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [GetDomStorageItems].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDomStorageItemsParams {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
    }
    ///
    /// Return value for [GetDomStorageItems].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDomStorageItemsReturns {
        #[serde(rename = "entries")]
        pub entries: Vec<Item>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDomStorageItems;
    impl crate::util::Command for GetDomStorageItems {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getDOMStorageItems"
        }
    }
    ///
    /// Parameter value for [RemoveDomStorageItem].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveDomStorageItemParams {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
        #[serde(rename = "key")]
        pub key: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveDomStorageItem;
    impl crate::util::Command for RemoveDomStorageItem {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeDOMStorageItem"
        }
    }
    ///
    /// Parameter value for [SetDomStorageItem].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDomStorageItemParams {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "value")]
        pub value: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDomStorageItem;
    impl crate::util::Command for SetDomStorageItem {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDOMStorageItem"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DomStorageItemAddedEvent {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "newValue")]
        pub new_value: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DomStorageItemRemovedEvent {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
        #[serde(rename = "key")]
        pub key: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DomStorageItemUpdatedEvent {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "oldValue")]
        pub old_value: String,
        #[serde(rename = "newValue")]
        pub new_value: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DomStorageItemsClearedEvent {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
    }
}
pub mod database {
    ///Unique identifier of Database object.
    pub type DatabaseId = String;
    ///Database object.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Database {
        ///Database ID.
        #[serde(rename = "id")]
        pub id: DatabaseId,
        ///Database domain.
        #[serde(rename = "domain")]
        pub domain: String,
        ///Database name.
        #[serde(rename = "name")]
        pub name: String,
        ///Database version.
        #[serde(rename = "version")]
        pub version: String,
    }
    ///Database error.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Error {
        ///Error message.
        #[serde(rename = "message")]
        pub message: String,
        ///Error code.
        #[serde(rename = "code")]
        pub code: i64,
    }
    ///Disables database tracking, prevents database events from being sent to the client.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables database tracking, database events will now be delivered to the client.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [ExecuteSql].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecuteSqlParams {
        #[serde(rename = "databaseId")]
        pub database_id: DatabaseId,
        #[serde(rename = "query")]
        pub query: String,
    }
    ///
    /// Return value for [ExecuteSql].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecuteSqlReturns {
        #[serde(rename = "columnNames")]
        pub column_names: Option<Vec<String>>,
        #[serde(rename = "values")]
        pub values: Option<Vec<serde_json::Value>>,
        #[serde(rename = "sqlError")]
        pub sql_error: Option<Error>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecuteSql;
    impl crate::util::Command for ExecuteSql {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "executeSQL"
        }
    }
    ///
    /// Parameter value for [GetDatabaseTableNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDatabaseTableNamesParams {
        #[serde(rename = "databaseId")]
        pub database_id: DatabaseId,
    }
    ///
    /// Return value for [GetDatabaseTableNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDatabaseTableNamesReturns {
        #[serde(rename = "tableNames")]
        pub table_names: Vec<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDatabaseTableNames;
    impl crate::util::Command for GetDatabaseTableNames {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getDatabaseTableNames"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddDatabaseEvent {
        #[serde(rename = "database")]
        pub database: Database,
    }
}
pub mod device_orientation {
    ///Clears the overridden Device Orientation.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearDeviceOrientationOverride;
    impl crate::util::Command for ClearDeviceOrientationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearDeviceOrientationOverride"
        }
    }
    ///
    /// Parameter value for [SetDeviceOrientationOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDeviceOrientationOverrideParams {
        ///Mock alpha
        #[serde(rename = "alpha")]
        pub alpha: f64,
        ///Mock beta
        #[serde(rename = "beta")]
        pub beta: f64,
        ///Mock gamma
        #[serde(rename = "gamma")]
        pub gamma: f64,
    }
    ///Overrides the Device Orientation.
    ///---
    ///Parameter Type: [SetDeviceOrientationOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDeviceOrientationOverride;
    impl crate::util::Command for SetDeviceOrientationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDeviceOrientationOverride"
        }
    }
}
///This domain emulates different environments for the page.
pub mod emulation {
    ///
    /// Enum for [ScreenOrientation]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ScreenOrientationType {
        #[serde(rename = "portraitPrimary")]
        PortraitPrimary,
        #[serde(rename = "portraitSecondary")]
        PortraitSecondary,
        #[serde(rename = "landscapePrimary")]
        LandscapePrimary,
        #[serde(rename = "landscapeSecondary")]
        LandscapeSecondary,
    }
    ///Screen orientation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScreenOrientation {
        ///Orientation type.
        #[serde(rename = "type")]
        pub type_: ScreenOrientationType,
        ///Orientation angle.
        #[serde(rename = "angle")]
        pub angle: i64,
    }
    ///
    /// Enum for [DisplayFeature]'s `orientation`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DisplayFeatureOrientation {
        #[serde(rename = "vertical")]
        Vertical,
        #[serde(rename = "horizontal")]
        Horizontal,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DisplayFeature {
        ///Orientation of a display feature in relation to screen
        #[serde(rename = "orientation")]
        pub orientation: DisplayFeatureOrientation,
        ///The offset from the screen origin in either the x (for vertical
        ///orientation) or y (for horizontal orientation) direction.
        #[serde(rename = "offset")]
        pub offset: i64,
        ///A display feature may mask content such that it is not physically
        ///displayed - this length along with the offset describes this area.
        ///A display feature that only splits content will have a 0 mask_length.
        #[serde(rename = "maskLength")]
        pub mask_length: i64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MediaFeature {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "value")]
        pub value: String,
    }
    ///advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
    ///allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
    ///pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
    ///resource fetches.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum VirtualTimePolicy {
        #[serde(rename = "advance")]
        Advance,
        #[serde(rename = "pause")]
        Pause,
        #[serde(rename = "pauseIfNetworkFetchesPending")]
        PauseIfNetworkFetchesPending,
    }
    ///Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UserAgentBrandVersion {
        #[serde(rename = "brand")]
        pub brand: String,
        #[serde(rename = "version")]
        pub version: String,
    }
    ///Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
    ///Missing optional values will be filled in by the target with what it would normally use.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UserAgentMetadata {
        ///Brands appearing in Sec-CH-UA.
        #[serde(rename = "brands")]
        pub brands: Option<Vec<UserAgentBrandVersion>>,
        ///Brands appearing in Sec-CH-UA-Full-Version-List.
        #[serde(rename = "fullVersionList")]
        pub full_version_list: Option<Vec<UserAgentBrandVersion>>,
        #[deprecated]
        #[serde(rename = "fullVersion")]
        pub full_version: Option<String>,
        #[serde(rename = "platform")]
        pub platform: String,
        #[serde(rename = "platformVersion")]
        pub platform_version: String,
        #[serde(rename = "architecture")]
        pub architecture: String,
        #[serde(rename = "model")]
        pub model: String,
        #[serde(rename = "mobile")]
        pub mobile: bool,
        #[serde(rename = "bitness")]
        pub bitness: Option<String>,
        #[serde(rename = "wow64")]
        pub wow_64: Option<bool>,
    }
    ///Enum of image types that can be disabled.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DisabledImageType {
        #[serde(rename = "avif")]
        Avif,
        #[serde(rename = "webp")]
        Webp,
    }
    ///
    /// Return value for [CanEmulate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CanEmulateReturns {
        ///True if emulation is supported.
        #[serde(rename = "result")]
        pub result: bool,
    }
    ///Tells whether emulation is supported.
    ///---
    ///Return Type: [CanEmulateReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CanEmulate;
    impl crate::util::Command for CanEmulate {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "canEmulate"
        }
    }
    ///Clears the overridden device metrics.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearDeviceMetricsOverride;
    impl crate::util::Command for ClearDeviceMetricsOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearDeviceMetricsOverride"
        }
    }
    ///Clears the overridden Geolocation Position and Error.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearGeolocationOverride;
    impl crate::util::Command for ClearGeolocationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearGeolocationOverride"
        }
    }
    ///Requests that page scale factor is reset to initial values.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResetPageScaleFactor;
    impl crate::util::Command for ResetPageScaleFactor {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resetPageScaleFactor"
        }
    }
    ///
    /// Parameter value for [SetFocusEmulationEnabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetFocusEmulationEnabledParams {
        ///Whether to enable to disable focus emulation.
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Enables or disables simulating a focused and active page.
    ///---
    ///Parameter Type: [SetFocusEmulationEnabledParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetFocusEmulationEnabled;
    impl crate::util::Command for SetFocusEmulationEnabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setFocusEmulationEnabled"
        }
    }
    ///
    /// Parameter value for [SetAutoDarkModeOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAutoDarkModeOverrideParams {
        ///Whether to enable or disable automatic dark mode.
        ///If not specified, any existing override will be cleared.
        #[serde(rename = "enabled")]
        pub enabled: Option<bool>,
    }
    ///Automatically render all web contents using a dark theme.
    ///---
    ///Parameter Type: [SetAutoDarkModeOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAutoDarkModeOverride;
    impl crate::util::Command for SetAutoDarkModeOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAutoDarkModeOverride"
        }
    }
    ///
    /// Parameter value for [SetCpuThrottlingRate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCpuThrottlingRateParams {
        ///Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).
        #[serde(rename = "rate")]
        pub rate: f64,
    }
    ///Enables CPU throttling to emulate slow CPUs.
    ///---
    ///Parameter Type: [SetCpuThrottlingRateParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCpuThrottlingRate;
    impl crate::util::Command for SetCpuThrottlingRate {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setCPUThrottlingRate"
        }
    }
    ///
    /// Parameter value for [SetDefaultBackgroundColorOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDefaultBackgroundColorOverrideParams {
        ///RGBA of the default background color. If not specified, any existing override will be
        ///cleared.
        #[serde(rename = "color")]
        pub color: Option<crate::protocol_test::dom::Rgba>,
    }
    ///Sets or clears an override of the default background color of the frame. This override is used
    ///if the content does not specify one.
    ///---
    ///Parameter Type: [SetDefaultBackgroundColorOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDefaultBackgroundColorOverride;
    impl crate::util::Command for SetDefaultBackgroundColorOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDefaultBackgroundColorOverride"
        }
    }
    ///
    /// Parameter value for [SetDeviceMetricsOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDeviceMetricsOverrideParams {
        ///Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
        #[serde(rename = "width")]
        pub width: i64,
        ///Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
        #[serde(rename = "height")]
        pub height: i64,
        ///Overriding device scale factor value. 0 disables the override.
        #[serde(rename = "deviceScaleFactor")]
        pub device_scale_factor: f64,
        ///Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
        ///autosizing and more.
        #[serde(rename = "mobile")]
        pub mobile: bool,
        ///Scale to apply to resulting view image.
        #[serde(rename = "scale")]
        pub scale: Option<f64>,
        ///Overriding screen width value in pixels (minimum 0, maximum 10000000).
        #[serde(rename = "screenWidth")]
        pub screen_width: Option<i64>,
        ///Overriding screen height value in pixels (minimum 0, maximum 10000000).
        #[serde(rename = "screenHeight")]
        pub screen_height: Option<i64>,
        ///Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
        #[serde(rename = "positionX")]
        pub position_x: Option<i64>,
        ///Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
        #[serde(rename = "positionY")]
        pub position_y: Option<i64>,
        ///Do not set visible view size, rely upon explicit setVisibleSize call.
        #[serde(rename = "dontSetVisibleSize")]
        pub dont_set_visible_size: Option<bool>,
        ///Screen orientation override.
        #[serde(rename = "screenOrientation")]
        pub screen_orientation: Option<ScreenOrientation>,
        ///If set, the visible area of the page will be overridden to this viewport. This viewport
        ///change is not observed by the page, e.g. viewport-relative elements do not change positions.
        #[serde(rename = "viewport")]
        pub viewport: Option<crate::protocol_test::page::Viewport>,
        ///If set, the display feature of a multi-segment screen. If not set, multi-segment support
        ///is turned-off.
        #[serde(rename = "displayFeature")]
        pub display_feature: Option<DisplayFeature>,
    }
    ///Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    ///window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    ///query results).
    ///---
    ///Parameter Type: [SetDeviceMetricsOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDeviceMetricsOverride;
    impl crate::util::Command for SetDeviceMetricsOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDeviceMetricsOverride"
        }
    }
    ///
    /// Parameter value for [SetScrollbarsHidden].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScrollbarsHiddenParams {
        ///Whether scrollbars should be always hidden.
        #[serde(rename = "hidden")]
        pub hidden: bool,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScrollbarsHidden;
    impl crate::util::Command for SetScrollbarsHidden {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setScrollbarsHidden"
        }
    }
    ///
    /// Parameter value for [SetDocumentCookieDisabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDocumentCookieDisabledParams {
        ///Whether document.coookie API should be disabled.
        #[serde(rename = "disabled")]
        pub disabled: bool,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDocumentCookieDisabled;
    impl crate::util::Command for SetDocumentCookieDisabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDocumentCookieDisabled"
        }
    }
    ///
    /// Enum for [SetEmitTouchEventsForMouse]'s `configuration`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetEmitTouchEventsForMouseConfiguration {
        #[serde(rename = "mobile")]
        Mobile,
        #[serde(rename = "desktop")]
        Desktop,
    }
    ///
    /// Parameter value for [SetEmitTouchEventsForMouse].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEmitTouchEventsForMouseParams {
        ///Whether touch emulation based on mouse input should be enabled.
        #[serde(rename = "enabled")]
        pub enabled: bool,
        ///Touch/gesture events configuration. Default: current platform.
        #[serde(rename = "configuration")]
        pub configuration: Option<Option<SetEmitTouchEventsForMouseConfiguration>>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEmitTouchEventsForMouse;
    impl crate::util::Command for SetEmitTouchEventsForMouse {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setEmitTouchEventsForMouse"
        }
    }
    ///
    /// Parameter value for [SetEmulatedMedia].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEmulatedMediaParams {
        ///Media type to emulate. Empty string disables the override.
        #[serde(rename = "media")]
        pub media: Option<String>,
        ///Media features to emulate.
        #[serde(rename = "features")]
        pub features: Option<Vec<MediaFeature>>,
    }
    ///Emulates the given media type or media feature for CSS media queries.
    ///---
    ///Parameter Type: [SetEmulatedMediaParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEmulatedMedia;
    impl crate::util::Command for SetEmulatedMedia {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setEmulatedMedia"
        }
    }
    ///
    /// Enum for [SetEmulatedVisionDeficiency]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetEmulatedVisionDeficiencyType {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "blurredVision")]
        BlurredVision,
        #[serde(rename = "reducedContrast")]
        ReducedContrast,
        #[serde(rename = "achromatopsia")]
        Achromatopsia,
        #[serde(rename = "deuteranopia")]
        Deuteranopia,
        #[serde(rename = "protanopia")]
        Protanopia,
        #[serde(rename = "tritanopia")]
        Tritanopia,
    }
    ///
    /// Parameter value for [SetEmulatedVisionDeficiency].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEmulatedVisionDeficiencyParams {
        ///Vision deficiency to emulate. Order: best-effort emulations come first, followed by any
        ///physiologically accurate emulations for medically recognized color vision deficiencies.
        #[serde(rename = "type")]
        pub type_: SetEmulatedVisionDeficiencyType,
    }
    ///Emulates the given vision deficiency.
    ///---
    ///Parameter Type: [SetEmulatedVisionDeficiencyParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetEmulatedVisionDeficiency;
    impl crate::util::Command for SetEmulatedVisionDeficiency {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setEmulatedVisionDeficiency"
        }
    }
    ///
    /// Parameter value for [SetGeolocationOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetGeolocationOverrideParams {
        ///Mock latitude
        #[serde(rename = "latitude")]
        pub latitude: Option<f64>,
        ///Mock longitude
        #[serde(rename = "longitude")]
        pub longitude: Option<f64>,
        ///Mock accuracy
        #[serde(rename = "accuracy")]
        pub accuracy: Option<f64>,
    }
    ///Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    ///unavailable.
    ///---
    ///Parameter Type: [SetGeolocationOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetGeolocationOverride;
    impl crate::util::Command for SetGeolocationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setGeolocationOverride"
        }
    }
    ///
    /// Parameter value for [SetIdleOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetIdleOverrideParams {
        ///Mock isUserActive
        #[serde(rename = "isUserActive")]
        pub is_user_active: bool,
        ///Mock isScreenUnlocked
        #[serde(rename = "isScreenUnlocked")]
        pub is_screen_unlocked: bool,
    }
    ///Overrides the Idle state.
    ///---
    ///Parameter Type: [SetIdleOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetIdleOverride;
    impl crate::util::Command for SetIdleOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setIdleOverride"
        }
    }
    ///Clears Idle state overrides.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearIdleOverride;
    impl crate::util::Command for ClearIdleOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearIdleOverride"
        }
    }
    ///
    /// Parameter value for [SetNavigatorOverrides].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNavigatorOverridesParams {
        ///The platform navigator.platform should return.
        #[serde(rename = "platform")]
        pub platform: String,
    }
    ///Overrides value returned by the javascript navigator object.
    ///---
    ///Parameter Type: [SetNavigatorOverridesParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetNavigatorOverrides;
    impl crate::util::Command for SetNavigatorOverrides {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setNavigatorOverrides"
        }
    }
    ///
    /// Parameter value for [SetPageScaleFactor].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPageScaleFactorParams {
        ///Page scale factor.
        #[serde(rename = "pageScaleFactor")]
        pub page_scale_factor: f64,
    }
    ///Sets a specified page scale factor.
    ///---
    ///Parameter Type: [SetPageScaleFactorParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPageScaleFactor;
    impl crate::util::Command for SetPageScaleFactor {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setPageScaleFactor"
        }
    }
    ///
    /// Parameter value for [SetScriptExecutionDisabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScriptExecutionDisabledParams {
        ///Whether script execution should be disabled in the page.
        #[serde(rename = "value")]
        pub value: bool,
    }
    ///Switches script execution in the page.
    ///---
    ///Parameter Type: [SetScriptExecutionDisabledParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScriptExecutionDisabled;
    impl crate::util::Command for SetScriptExecutionDisabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setScriptExecutionDisabled"
        }
    }
    ///
    /// Parameter value for [SetTouchEmulationEnabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTouchEmulationEnabledParams {
        ///Whether the touch event emulation should be enabled.
        #[serde(rename = "enabled")]
        pub enabled: bool,
        ///Maximum touch points supported. Defaults to one.
        #[serde(rename = "maxTouchPoints")]
        pub max_touch_points: Option<i64>,
    }
    ///Enables touch on platforms which do not support them.
    ///---
    ///Parameter Type: [SetTouchEmulationEnabledParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTouchEmulationEnabled;
    impl crate::util::Command for SetTouchEmulationEnabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setTouchEmulationEnabled"
        }
    }
    ///
    /// Parameter value for [SetVirtualTimePolicy].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetVirtualTimePolicyParams {
        #[serde(rename = "policy")]
        pub policy: VirtualTimePolicy,
        ///If set, after this many virtual milliseconds have elapsed virtual time will be paused and a
        ///virtualTimeBudgetExpired event is sent.
        #[serde(rename = "budget")]
        pub budget: Option<f64>,
        ///If set this specifies the maximum number of tasks that can be run before virtual is forced
        ///forwards to prevent deadlock.
        #[serde(rename = "maxVirtualTimeTaskStarvationCount")]
        pub max_virtual_time_task_starvation_count: Option<i64>,
        ///If set, base::Time::Now will be overridden to initially return this value.
        #[serde(rename = "initialVirtualTime")]
        pub initial_virtual_time: Option<crate::protocol_test::network::TimeSinceEpoch>,
    }
    ///
    /// Return value for [SetVirtualTimePolicy].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetVirtualTimePolicyReturns {
        ///Absolute timestamp at which virtual time was first enabled (up time in milliseconds).
        #[serde(rename = "virtualTimeTicksBase")]
        pub virtual_time_ticks_base: f64,
    }
    ///Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
    ///the current virtual time policy.  Note this supersedes any previous time budget.
    ///---
    ///Parameter Type: [SetVirtualTimePolicyParams]
    ///Return Type: [SetVirtualTimePolicyReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetVirtualTimePolicy;
    impl crate::util::Command for SetVirtualTimePolicy {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setVirtualTimePolicy"
        }
    }
    ///
    /// Parameter value for [SetLocaleOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetLocaleOverrideParams {
        ///ICU style C locale (e.g. "en_US"). If not specified or empty, disables the override and
        ///restores default host system locale.
        #[serde(rename = "locale")]
        pub locale: Option<String>,
    }
    ///Overrides default host system locale with the specified one.
    ///---
    ///Parameter Type: [SetLocaleOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetLocaleOverride;
    impl crate::util::Command for SetLocaleOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setLocaleOverride"
        }
    }
    ///
    /// Parameter value for [SetTimezoneOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTimezoneOverrideParams {
        ///The timezone identifier. If empty, disables the override and
        ///restores default host system timezone.
        #[serde(rename = "timezoneId")]
        pub timezone_id: String,
    }
    ///Overrides default host system timezone with the specified one.
    ///---
    ///Parameter Type: [SetTimezoneOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTimezoneOverride;
    impl crate::util::Command for SetTimezoneOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setTimezoneOverride"
        }
    }
    ///
    /// Parameter value for [SetVisibleSize].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetVisibleSizeParams {
        ///Frame width (DIP).
        #[serde(rename = "width")]
        pub width: i64,
        ///Frame height (DIP).
        #[serde(rename = "height")]
        pub height: i64,
    }
    ///Resizes the frame/viewport of the page. Note that this does not affect the frame's container
    ///(e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
    ///on Android.
    ///---
    ///Parameter Type: [SetVisibleSizeParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetVisibleSize;
    impl crate::util::Command for SetVisibleSize {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setVisibleSize"
        }
    }
    ///
    /// Parameter value for [SetDisabledImageTypes].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDisabledImageTypesParams {
        ///Image types to disable.
        #[serde(rename = "imageTypes")]
        pub image_types: Vec<DisabledImageType>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDisabledImageTypes;
    impl crate::util::Command for SetDisabledImageTypes {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDisabledImageTypes"
        }
    }
    ///
    /// Parameter value for [SetHardwareConcurrencyOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetHardwareConcurrencyOverrideParams {
        ///Hardware concurrency to report
        #[serde(rename = "hardwareConcurrency")]
        pub hardware_concurrency: i64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetHardwareConcurrencyOverride;
    impl crate::util::Command for SetHardwareConcurrencyOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setHardwareConcurrencyOverride"
        }
    }
    ///
    /// Parameter value for [SetUserAgentOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetUserAgentOverrideParams {
        ///User agent to use.
        #[serde(rename = "userAgent")]
        pub user_agent: String,
        ///Browser langugage to emulate.
        #[serde(rename = "acceptLanguage")]
        pub accept_language: Option<String>,
        ///The platform navigator.platform should return.
        #[serde(rename = "platform")]
        pub platform: Option<String>,
        ///To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
        #[serde(rename = "userAgentMetadata")]
        pub user_agent_metadata: Option<UserAgentMetadata>,
    }
    ///Allows overriding user agent with the given string.
    ///---
    ///Parameter Type: [SetUserAgentOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetUserAgentOverride;
    impl crate::util::Command for SetUserAgentOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setUserAgentOverride"
        }
    }
    ///
    /// Parameter value for [SetAutomationOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAutomationOverrideParams {
        ///Whether the override should be enabled.
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Allows overriding the automation flag.
    ///---
    ///Parameter Type: [SetAutomationOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAutomationOverride;
    impl crate::util::Command for SetAutomationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAutomationOverride"
        }
    }
    ///Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct VirtualTimeBudgetExpiredEvent {}
}
///This domain provides experimental commands only supported in headless mode.
pub mod headless_experimental {
    ///
    /// Enum for [ScreenshotParams]'s `format`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ScreenshotParamsFormat {
        #[serde(rename = "jpeg")]
        Jpeg,
        #[serde(rename = "png")]
        Png,
        #[serde(rename = "webp")]
        Webp,
    }
    ///Encoding options for a screenshot.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScreenshotParams {
        ///Image compression format (defaults to png).
        #[serde(rename = "format")]
        pub format: Option<Option<ScreenshotParamsFormat>>,
        ///Compression quality from range [0..100] (jpeg and webp only).
        #[serde(rename = "quality")]
        pub quality: Option<i64>,
        ///Optimize image encoding for speed, not for resulting size (defaults to false)
        #[serde(rename = "optimizeForSpeed")]
        pub optimize_for_speed: Option<bool>,
    }
    ///
    /// Parameter value for [BeginFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BeginFrameParams {
        ///Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,
        ///the current time will be used.
        #[serde(rename = "frameTimeTicks")]
        pub frame_time_ticks: Option<f64>,
        ///The interval between BeginFrames that is reported to the compositor, in milliseconds.
        ///Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.
        #[serde(rename = "interval")]
        pub interval: Option<f64>,
        ///Whether updates should not be committed and drawn onto the display. False by default. If
        ///true, only side effects of the BeginFrame will be run, such as layout and animations, but
        ///any visual updates may not be visible on the display or in screenshots.
        #[serde(rename = "noDisplayUpdates")]
        pub no_display_updates: Option<bool>,
        ///If set, a screenshot of the frame will be captured and returned in the response. Otherwise,
        ///no screenshot will be captured. Note that capturing a screenshot can fail, for example,
        ///during renderer initialization. In such a case, no screenshot data will be returned.
        #[serde(rename = "screenshot")]
        pub screenshot: Option<ScreenshotParams>,
    }
    ///
    /// Return value for [BeginFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BeginFrameReturns {
        ///Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the
        ///display. Reported for diagnostic uses, may be removed in the future.
        #[serde(rename = "hasDamage")]
        pub has_damage: bool,
        ///Base64-encoded image data of the screenshot, if one was requested and successfully taken. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "screenshotData")]
        pub screenshot_data: Option<String>,
    }
    ///Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
    ///screenshot from the resulting frame. Requires that the target was created with enabled
    ///BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
    ///https://goo.gle/chrome-headless-rendering for more background.
    ///---
    ///Parameter Type: [BeginFrameParams]
    ///Return Type: [BeginFrameReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BeginFrame;
    impl crate::util::Command for BeginFrame {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "beginFrame"
        }
    }
    ///Disables headless events for the target.
    ///---
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables headless events for the target.
    ///---
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
}
///Input/Output operations for streams produced by DevTools.
pub mod io {
    ///This is either obtained from another method or specified as `blob:<uuid>` where
    ///`<uuid>` is an UUID of a Blob.
    pub type StreamHandle = String;
    ///
    /// Parameter value for [Close].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CloseParams {
        ///Handle of the stream to close.
        #[serde(rename = "handle")]
        pub handle: StreamHandle,
    }
    ///Close the stream, discard any temporary backing storage.
    ///---
    ///Parameter Type: [CloseParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Close;
    impl crate::util::Command for Close {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "close"
        }
    }
    ///
    /// Parameter value for [Read].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReadParams {
        ///Handle of the stream to read.
        #[serde(rename = "handle")]
        pub handle: StreamHandle,
        ///Seek to the specified offset before reading (if not specificed, proceed with offset
        ///following the last read). Some types of streams may only support sequential reads.
        #[serde(rename = "offset")]
        pub offset: Option<i64>,
        ///Maximum number of bytes to read (left upon the agent discretion if not specified).
        #[serde(rename = "size")]
        pub size: Option<i64>,
    }
    ///
    /// Return value for [Read].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReadReturns {
        ///Set if the data is base64-encoded
        #[serde(rename = "base64Encoded")]
        pub base_64_encoded: Option<bool>,
        ///Data that were read.
        #[serde(rename = "data")]
        pub data: String,
        ///Set if the end-of-file condition occurred while reading.
        #[serde(rename = "eof")]
        pub eof: bool,
    }
    ///Read a chunk of the stream
    ///---
    ///Parameter Type: [ReadParams]
    ///Return Type: [ReadReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Read;
    impl crate::util::Command for Read {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "read"
        }
    }
    ///
    /// Parameter value for [ResolveBlob].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveBlobParams {
        ///Object id of a Blob object wrapper.
        #[serde(rename = "objectId")]
        pub object_id: crate::protocol_test::runtime::RemoteObjectId,
    }
    ///
    /// Return value for [ResolveBlob].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveBlobReturns {
        ///UUID of the specified Blob.
        #[serde(rename = "uuid")]
        pub uuid: String,
    }
    ///Return UUID of Blob object specified by a remote object id.
    ///---
    ///Parameter Type: [ResolveBlobParams]
    ///Return Type: [ResolveBlobReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResolveBlob;
    impl crate::util::Command for ResolveBlob {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resolveBlob"
        }
    }
}
pub mod indexed_db {
    ///Database with an array of object stores.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DatabaseWithObjectStores {
        ///Database name.
        #[serde(rename = "name")]
        pub name: String,
        ///Database version (type is not 'integer', as the standard
        ///requires the version number to be 'unsigned long long')
        #[serde(rename = "version")]
        pub version: f64,
        ///Object stores in this database.
        #[serde(rename = "objectStores")]
        pub object_stores: Vec<ObjectStore>,
    }
    ///Object store.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ObjectStore {
        ///Object store name.
        #[serde(rename = "name")]
        pub name: String,
        ///Object store key path.
        #[serde(rename = "keyPath")]
        pub key_path: KeyPath,
        ///If true, object store has auto increment flag set.
        #[serde(rename = "autoIncrement")]
        pub auto_increment: bool,
        ///Indexes in this object store.
        #[serde(rename = "indexes")]
        pub indexes: Vec<ObjectStoreIndex>,
    }
    ///Object store index.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ObjectStoreIndex {
        ///Index name.
        #[serde(rename = "name")]
        pub name: String,
        ///Index key path.
        #[serde(rename = "keyPath")]
        pub key_path: KeyPath,
        ///If true, index is unique.
        #[serde(rename = "unique")]
        pub unique: bool,
        ///If true, index allows multiple entries for a key.
        #[serde(rename = "multiEntry")]
        pub multi_entry: bool,
    }
    ///
    /// Enum for [Key]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum KeyType {
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "array")]
        Array,
    }
    ///Key.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Key {
        ///Key type.
        #[serde(rename = "type")]
        pub type_: KeyType,
        ///Number value.
        #[serde(rename = "number")]
        pub number: Option<f64>,
        ///String value.
        #[serde(rename = "string")]
        pub string: Option<String>,
        ///Date value.
        #[serde(rename = "date")]
        pub date: Option<f64>,
        ///Array value.
        #[serde(rename = "array")]
        pub array: Option<Vec<Key>>,
    }
    ///Key range.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct KeyRange {
        ///Lower bound.
        #[serde(rename = "lower")]
        pub lower: Option<Key>,
        ///Upper bound.
        #[serde(rename = "upper")]
        pub upper: Option<Key>,
        ///If true lower bound is open.
        #[serde(rename = "lowerOpen")]
        pub lower_open: bool,
        ///If true upper bound is open.
        #[serde(rename = "upperOpen")]
        pub upper_open: bool,
    }
    ///Data entry.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DataEntry {
        ///Key object.
        #[serde(rename = "key")]
        pub key: crate::protocol_test::runtime::RemoteObject,
        ///Primary key object.
        #[serde(rename = "primaryKey")]
        pub primary_key: crate::protocol_test::runtime::RemoteObject,
        ///Value object.
        #[serde(rename = "value")]
        pub value: crate::protocol_test::runtime::RemoteObject,
    }
    ///
    /// Enum for [KeyPath]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum KeyPathType {
        #[serde(rename = "null")]
        Null,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "array")]
        Array,
    }
    ///Key path.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct KeyPath {
        ///Key path type.
        #[serde(rename = "type")]
        pub type_: KeyPathType,
        ///String value.
        #[serde(rename = "string")]
        pub string: Option<String>,
        ///Array value.
        #[serde(rename = "array")]
        pub array: Option<Vec<String>>,
    }
    ///
    /// Parameter value for [ClearObjectStore].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearObjectStoreParams {
        ///At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
        ///Security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: Option<String>,
        ///Storage bucket. If not specified, it uses the default bucket.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
        ///Database name.
        #[serde(rename = "databaseName")]
        pub database_name: String,
        ///Object store name.
        #[serde(rename = "objectStoreName")]
        pub object_store_name: String,
    }
    ///Clears all entries from an object store.
    ///---
    ///Parameter Type: [ClearObjectStoreParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearObjectStore;
    impl crate::util::Command for ClearObjectStore {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearObjectStore"
        }
    }
    ///
    /// Parameter value for [DeleteDatabase].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteDatabaseParams {
        ///At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
        ///Security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: Option<String>,
        ///Storage bucket. If not specified, it uses the default bucket.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
        ///Database name.
        #[serde(rename = "databaseName")]
        pub database_name: String,
    }
    ///Deletes a database.
    ///---
    ///Parameter Type: [DeleteDatabaseParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteDatabase;
    impl crate::util::Command for DeleteDatabase {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deleteDatabase"
        }
    }
    ///
    /// Parameter value for [DeleteObjectStoreEntries].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteObjectStoreEntriesParams {
        ///At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
        ///Security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: Option<String>,
        ///Storage bucket. If not specified, it uses the default bucket.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
        #[serde(rename = "databaseName")]
        pub database_name: String,
        #[serde(rename = "objectStoreName")]
        pub object_store_name: String,
        ///Range of entry keys to delete
        #[serde(rename = "keyRange")]
        pub key_range: KeyRange,
    }
    ///Delete a range of entries from an object store
    ///---
    ///Parameter Type: [DeleteObjectStoreEntriesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteObjectStoreEntries;
    impl crate::util::Command for DeleteObjectStoreEntries {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deleteObjectStoreEntries"
        }
    }
    ///Disables events from backend.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables events from backend.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [RequestData].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestDataParams {
        ///At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
        ///Security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: Option<String>,
        ///Storage bucket. If not specified, it uses the default bucket.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
        ///Database name.
        #[serde(rename = "databaseName")]
        pub database_name: String,
        ///Object store name.
        #[serde(rename = "objectStoreName")]
        pub object_store_name: String,
        ///Index name, empty string for object store data requests.
        #[serde(rename = "indexName")]
        pub index_name: String,
        ///Number of records to skip.
        #[serde(rename = "skipCount")]
        pub skip_count: i64,
        ///Number of records to fetch.
        #[serde(rename = "pageSize")]
        pub page_size: i64,
        ///Key range.
        #[serde(rename = "keyRange")]
        pub key_range: Option<KeyRange>,
    }
    ///
    /// Return value for [RequestData].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestDataReturns {
        ///Array of object store data entries.
        #[serde(rename = "objectStoreDataEntries")]
        pub object_store_data_entries: Vec<DataEntry>,
        ///If true, there are more entries to fetch in the given range.
        #[serde(rename = "hasMore")]
        pub has_more: bool,
    }
    ///Requests data from object store or index.
    ///---
    ///Parameter Type: [RequestDataParams]
    ///Return Type: [RequestDataReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestData;
    impl crate::util::Command for RequestData {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestData"
        }
    }
    ///
    /// Parameter value for [GetMetadata].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMetadataParams {
        ///At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
        ///Security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: Option<String>,
        ///Storage bucket. If not specified, it uses the default bucket.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
        ///Database name.
        #[serde(rename = "databaseName")]
        pub database_name: String,
        ///Object store name.
        #[serde(rename = "objectStoreName")]
        pub object_store_name: String,
    }
    ///
    /// Return value for [GetMetadata].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMetadataReturns {
        ///the entries count
        #[serde(rename = "entriesCount")]
        pub entries_count: f64,
        ///the current value of key generator, to become the next inserted
        ///key into the object store. Valid if objectStore.autoIncrement
        ///is true.
        #[serde(rename = "keyGeneratorValue")]
        pub key_generator_value: f64,
    }
    ///Gets metadata of an object store.
    ///---
    ///Parameter Type: [GetMetadataParams]
    ///Return Type: [GetMetadataReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMetadata;
    impl crate::util::Command for GetMetadata {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getMetadata"
        }
    }
    ///
    /// Parameter value for [RequestDatabase].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestDatabaseParams {
        ///At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
        ///Security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: Option<String>,
        ///Storage bucket. If not specified, it uses the default bucket.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
        ///Database name.
        #[serde(rename = "databaseName")]
        pub database_name: String,
    }
    ///
    /// Return value for [RequestDatabase].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestDatabaseReturns {
        ///Database with an array of object stores.
        #[serde(rename = "databaseWithObjectStores")]
        pub database_with_object_stores: DatabaseWithObjectStores,
    }
    ///Requests database with given name in given frame.
    ///---
    ///Parameter Type: [RequestDatabaseParams]
    ///Return Type: [RequestDatabaseReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestDatabase;
    impl crate::util::Command for RequestDatabase {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestDatabase"
        }
    }
    ///
    /// Parameter value for [RequestDatabaseNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestDatabaseNamesParams {
        ///At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
        ///Security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: Option<String>,
        ///Storage bucket. If not specified, it uses the default bucket.
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<crate::protocol_test::storage::StorageBucket>,
    }
    ///
    /// Return value for [RequestDatabaseNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestDatabaseNamesReturns {
        ///Database names for origin.
        #[serde(rename = "databaseNames")]
        pub database_names: Vec<String>,
    }
    ///Requests database names for given security origin.
    ///---
    ///Parameter Type: [RequestDatabaseNamesParams]
    ///Return Type: [RequestDatabaseNamesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestDatabaseNames;
    impl crate::util::Command for RequestDatabaseNames {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestDatabaseNames"
        }
    }
}
pub mod input {
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TouchPoint {
        ///X coordinate of the event relative to the main frame's viewport in CSS pixels.
        #[serde(rename = "x")]
        pub x: f64,
        ///Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
        ///the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        #[serde(rename = "y")]
        pub y: f64,
        ///X radius of the touch area (default: 1.0).
        #[serde(rename = "radiusX")]
        pub radius_x: Option<f64>,
        ///Y radius of the touch area (default: 1.0).
        #[serde(rename = "radiusY")]
        pub radius_y: Option<f64>,
        ///Rotation angle (default: 0.0).
        #[serde(rename = "rotationAngle")]
        pub rotation_angle: Option<f64>,
        ///Force (default: 1.0).
        #[serde(rename = "force")]
        pub force: Option<f64>,
        ///The normalized tangential pressure, which has a range of [-1,1] (default: 0).
        #[serde(rename = "tangentialPressure")]
        pub tangential_pressure: Option<f64>,
        ///The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
        #[serde(rename = "tiltX")]
        pub tilt_x: Option<i64>,
        ///The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
        #[serde(rename = "tiltY")]
        pub tilt_y: Option<i64>,
        ///The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
        #[serde(rename = "twist")]
        pub twist: Option<i64>,
        ///Identifier used to track touch sources between events, must be unique within an event.
        #[serde(rename = "id")]
        pub id: Option<f64>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum GestureSourceType {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "touch")]
        Touch,
        #[serde(rename = "mouse")]
        Mouse,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum MouseButton {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "left")]
        Left,
        #[serde(rename = "middle")]
        Middle,
        #[serde(rename = "right")]
        Right,
        #[serde(rename = "back")]
        Back,
        #[serde(rename = "forward")]
        Forward,
    }
    ///UTC time in seconds, counted from January 1, 1970.
    pub type TimeSinceEpoch = f64;
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DragDataItem {
        ///Mime type of the dragged data.
        #[serde(rename = "mimeType")]
        pub mime_type: String,
        ///Depending of the value of `mimeType`, it contains the dragged link,
        ///text, HTML markup or any other data.
        #[serde(rename = "data")]
        pub data: String,
        ///Title associated with a link. Only valid when `mimeType` == "text/uri-list".
        #[serde(rename = "title")]
        pub title: Option<String>,
        ///Stores the base URL for the contained markup. Only valid when `mimeType`
        ///== "text/html".
        #[serde(rename = "baseURL")]
        pub base_url: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DragData {
        #[serde(rename = "items")]
        pub items: Vec<DragDataItem>,
        ///List of filenames that should be included when dropping
        #[serde(rename = "files")]
        pub files: Option<Vec<String>>,
        ///Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16
        #[serde(rename = "dragOperationsMask")]
        pub drag_operations_mask: i64,
    }
    ///
    /// Enum for [DispatchDragEvent]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DispatchDragEventType {
        #[serde(rename = "dragEnter")]
        DragEnter,
        #[serde(rename = "dragOver")]
        DragOver,
        #[serde(rename = "drop")]
        Drop,
        #[serde(rename = "dragCancel")]
        DragCancel,
    }
    ///
    /// Parameter value for [DispatchDragEvent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchDragEventParams {
        ///Type of the drag event.
        #[serde(rename = "type")]
        pub type_: DispatchDragEventType,
        ///X coordinate of the event relative to the main frame's viewport in CSS pixels.
        #[serde(rename = "x")]
        pub x: f64,
        ///Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
        ///the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        #[serde(rename = "y")]
        pub y: f64,
        #[serde(rename = "data")]
        pub data: DragData,
        ///Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
        ///(default: 0).
        #[serde(rename = "modifiers")]
        pub modifiers: Option<i64>,
    }
    ///Dispatches a drag event into the page.
    ///---
    ///Parameter Type: [DispatchDragEventParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchDragEvent;
    impl crate::util::Command for DispatchDragEvent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "dispatchDragEvent"
        }
    }
    ///
    /// Enum for [DispatchKeyEvent]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DispatchKeyEventType {
        #[serde(rename = "keyDown")]
        KeyDown,
        #[serde(rename = "keyUp")]
        KeyUp,
        #[serde(rename = "rawKeyDown")]
        RawKeyDown,
        #[serde(rename = "char")]
        Char,
    }
    ///
    /// Parameter value for [DispatchKeyEvent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchKeyEventParams {
        ///Type of the key event.
        #[serde(rename = "type")]
        pub type_: DispatchKeyEventType,
        ///Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
        ///(default: 0).
        #[serde(rename = "modifiers")]
        pub modifiers: Option<i64>,
        ///Time at which the event occurred.
        #[serde(rename = "timestamp")]
        pub timestamp: Option<TimeSinceEpoch>,
        ///Text as generated by processing a virtual key code with a keyboard layout. Not needed for
        ///for `keyUp` and `rawKeyDown` events (default: "")
        #[serde(rename = "text")]
        pub text: Option<String>,
        ///Text that would have been generated by the keyboard if no modifiers were pressed (except for
        ///shift). Useful for shortcut (accelerator) key handling (default: "").
        #[serde(rename = "unmodifiedText")]
        pub unmodified_text: Option<String>,
        ///Unique key identifier (e.g., 'U+0041') (default: "").
        #[serde(rename = "keyIdentifier")]
        pub key_identifier: Option<String>,
        ///Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
        #[serde(rename = "code")]
        pub code: Option<String>,
        ///Unique DOM defined string value describing the meaning of the key in the context of active
        ///modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
        #[serde(rename = "key")]
        pub key: Option<String>,
        ///Windows virtual key code (default: 0).
        #[serde(rename = "windowsVirtualKeyCode")]
        pub windows_virtual_key_code: Option<i64>,
        ///Native virtual key code (default: 0).
        #[serde(rename = "nativeVirtualKeyCode")]
        pub native_virtual_key_code: Option<i64>,
        ///Whether the event was generated from auto repeat (default: false).
        #[serde(rename = "autoRepeat")]
        pub auto_repeat: Option<bool>,
        ///Whether the event was generated from the keypad (default: false).
        #[serde(rename = "isKeypad")]
        pub is_keypad: Option<bool>,
        ///Whether the event was a system key event (default: false).
        #[serde(rename = "isSystemKey")]
        pub is_system_key: Option<bool>,
        ///Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
        ///0).
        #[serde(rename = "location")]
        pub location: Option<i64>,
        ///Editing commands to send with the key event (e.g., 'selectAll') (default: []).
        ///These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.
        ///See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
        #[serde(rename = "commands")]
        pub commands: Option<Vec<String>>,
    }
    ///Dispatches a key event to the page.
    ///---
    ///Parameter Type: [DispatchKeyEventParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchKeyEvent;
    impl crate::util::Command for DispatchKeyEvent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "dispatchKeyEvent"
        }
    }
    ///
    /// Parameter value for [InsertText].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InsertTextParams {
        ///The text to insert.
        #[serde(rename = "text")]
        pub text: String,
    }
    ///This method emulates inserting text that doesn't come from a key press,
    ///for example an emoji keyboard or an IME.
    ///---
    ///Parameter Type: [InsertTextParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InsertText;
    impl crate::util::Command for InsertText {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "insertText"
        }
    }
    ///
    /// Parameter value for [ImeSetComposition].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ImeSetCompositionParams {
        ///The text to insert
        #[serde(rename = "text")]
        pub text: String,
        ///selection start
        #[serde(rename = "selectionStart")]
        pub selection_start: i64,
        ///selection end
        #[serde(rename = "selectionEnd")]
        pub selection_end: i64,
        ///replacement start
        #[serde(rename = "replacementStart")]
        pub replacement_start: Option<i64>,
        ///replacement end
        #[serde(rename = "replacementEnd")]
        pub replacement_end: Option<i64>,
    }
    ///This method sets the current candidate text for ime.
    ///Use imeCommitComposition to commit the final text.
    ///Use imeSetComposition with empty string as text to cancel composition.
    ///---
    ///Parameter Type: [ImeSetCompositionParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ImeSetComposition;
    impl crate::util::Command for ImeSetComposition {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "imeSetComposition"
        }
    }
    ///
    /// Enum for [DispatchMouseEvent]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DispatchMouseEventType {
        #[serde(rename = "mousePressed")]
        MousePressed,
        #[serde(rename = "mouseReleased")]
        MouseReleased,
        #[serde(rename = "mouseMoved")]
        MouseMoved,
        #[serde(rename = "mouseWheel")]
        MouseWheel,
    }
    ///
    /// Enum for [DispatchMouseEvent]'s `pointer_type`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DispatchMouseEventPointerType {
        #[serde(rename = "mouse")]
        Mouse,
        #[serde(rename = "pen")]
        Pen,
    }
    ///
    /// Parameter value for [DispatchMouseEvent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchMouseEventParams {
        ///Type of the mouse event.
        #[serde(rename = "type")]
        pub type_: DispatchMouseEventType,
        ///X coordinate of the event relative to the main frame's viewport in CSS pixels.
        #[serde(rename = "x")]
        pub x: f64,
        ///Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
        ///the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        #[serde(rename = "y")]
        pub y: f64,
        ///Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
        ///(default: 0).
        #[serde(rename = "modifiers")]
        pub modifiers: Option<i64>,
        ///Time at which the event occurred.
        #[serde(rename = "timestamp")]
        pub timestamp: Option<TimeSinceEpoch>,
        ///Mouse button (default: "none").
        #[serde(rename = "button")]
        pub button: Option<MouseButton>,
        ///A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
        ///Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
        #[serde(rename = "buttons")]
        pub buttons: Option<i64>,
        ///Number of times the mouse button was clicked (default: 0).
        #[serde(rename = "clickCount")]
        pub click_count: Option<i64>,
        ///The normalized pressure, which has a range of [0,1] (default: 0).
        #[serde(rename = "force")]
        pub force: Option<f64>,
        ///The normalized tangential pressure, which has a range of [-1,1] (default: 0).
        #[serde(rename = "tangentialPressure")]
        pub tangential_pressure: Option<f64>,
        ///The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
        #[serde(rename = "tiltX")]
        pub tilt_x: Option<i64>,
        ///The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
        #[serde(rename = "tiltY")]
        pub tilt_y: Option<i64>,
        ///The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
        #[serde(rename = "twist")]
        pub twist: Option<i64>,
        ///X delta in CSS pixels for mouse wheel event (default: 0).
        #[serde(rename = "deltaX")]
        pub delta_x: Option<f64>,
        ///Y delta in CSS pixels for mouse wheel event (default: 0).
        #[serde(rename = "deltaY")]
        pub delta_y: Option<f64>,
        ///Pointer type (default: "mouse").
        #[serde(rename = "pointerType")]
        pub pointer_type: Option<Option<DispatchMouseEventPointerType>>,
    }
    ///Dispatches a mouse event to the page.
    ///---
    ///Parameter Type: [DispatchMouseEventParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchMouseEvent;
    impl crate::util::Command for DispatchMouseEvent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "dispatchMouseEvent"
        }
    }
    ///
    /// Enum for [DispatchTouchEvent]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DispatchTouchEventType {
        #[serde(rename = "touchStart")]
        TouchStart,
        #[serde(rename = "touchEnd")]
        TouchEnd,
        #[serde(rename = "touchMove")]
        TouchMove,
        #[serde(rename = "touchCancel")]
        TouchCancel,
    }
    ///
    /// Parameter value for [DispatchTouchEvent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchTouchEventParams {
        ///Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
        ///TouchStart and TouchMove must contains at least one.
        #[serde(rename = "type")]
        pub type_: DispatchTouchEventType,
        ///Active touch points on the touch device. One event per any changed point (compared to
        ///previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
        ///one by one.
        #[serde(rename = "touchPoints")]
        pub touch_points: Vec<TouchPoint>,
        ///Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
        ///(default: 0).
        #[serde(rename = "modifiers")]
        pub modifiers: Option<i64>,
        ///Time at which the event occurred.
        #[serde(rename = "timestamp")]
        pub timestamp: Option<TimeSinceEpoch>,
    }
    ///Dispatches a touch event to the page.
    ///---
    ///Parameter Type: [DispatchTouchEventParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchTouchEvent;
    impl crate::util::Command for DispatchTouchEvent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "dispatchTouchEvent"
        }
    }
    ///Cancels any active dragging in the page.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CancelDragging;
    impl crate::util::Command for CancelDragging {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "cancelDragging"
        }
    }
    ///
    /// Enum for [EmulateTouchFromMouseEvent]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum EmulateTouchFromMouseEventType {
        #[serde(rename = "mousePressed")]
        MousePressed,
        #[serde(rename = "mouseReleased")]
        MouseReleased,
        #[serde(rename = "mouseMoved")]
        MouseMoved,
        #[serde(rename = "mouseWheel")]
        MouseWheel,
    }
    ///
    /// Parameter value for [EmulateTouchFromMouseEvent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EmulateTouchFromMouseEventParams {
        ///Type of the mouse event.
        #[serde(rename = "type")]
        pub type_: EmulateTouchFromMouseEventType,
        ///X coordinate of the mouse pointer in DIP.
        #[serde(rename = "x")]
        pub x: i64,
        ///Y coordinate of the mouse pointer in DIP.
        #[serde(rename = "y")]
        pub y: i64,
        ///Mouse button. Only "none", "left", "right" are supported.
        #[serde(rename = "button")]
        pub button: MouseButton,
        ///Time at which the event occurred (default: current time).
        #[serde(rename = "timestamp")]
        pub timestamp: Option<TimeSinceEpoch>,
        ///X delta in DIP for mouse wheel event (default: 0).
        #[serde(rename = "deltaX")]
        pub delta_x: Option<f64>,
        ///Y delta in DIP for mouse wheel event (default: 0).
        #[serde(rename = "deltaY")]
        pub delta_y: Option<f64>,
        ///Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
        ///(default: 0).
        #[serde(rename = "modifiers")]
        pub modifiers: Option<i64>,
        ///Number of times the mouse button was clicked (default: 0).
        #[serde(rename = "clickCount")]
        pub click_count: Option<i64>,
    }
    ///Emulates touch event from the mouse event parameters.
    ///---
    ///Parameter Type: [EmulateTouchFromMouseEventParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EmulateTouchFromMouseEvent;
    impl crate::util::Command for EmulateTouchFromMouseEvent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "emulateTouchFromMouseEvent"
        }
    }
    ///
    /// Parameter value for [SetIgnoreInputEvents].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetIgnoreInputEventsParams {
        ///Ignores input events processing when set to true.
        #[serde(rename = "ignore")]
        pub ignore: bool,
    }
    ///Ignores input events (useful while auditing page).
    ///---
    ///Parameter Type: [SetIgnoreInputEventsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetIgnoreInputEvents;
    impl crate::util::Command for SetIgnoreInputEvents {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setIgnoreInputEvents"
        }
    }
    ///
    /// Parameter value for [SetInterceptDrags].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInterceptDragsParams {
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
    ///Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
    ///---
    ///Parameter Type: [SetInterceptDragsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInterceptDrags;
    impl crate::util::Command for SetInterceptDrags {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setInterceptDrags"
        }
    }
    ///
    /// Parameter value for [SynthesizePinchGesture].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SynthesizePinchGestureParams {
        ///X coordinate of the start of the gesture in CSS pixels.
        #[serde(rename = "x")]
        pub x: f64,
        ///Y coordinate of the start of the gesture in CSS pixels.
        #[serde(rename = "y")]
        pub y: f64,
        ///Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
        #[serde(rename = "scaleFactor")]
        pub scale_factor: f64,
        ///Relative pointer speed in pixels per second (default: 800).
        #[serde(rename = "relativeSpeed")]
        pub relative_speed: Option<i64>,
        ///Which type of input events to be generated (default: 'default', which queries the platform
        ///for the preferred input type).
        #[serde(rename = "gestureSourceType")]
        pub gesture_source_type: Option<GestureSourceType>,
    }
    ///Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
    ///---
    ///Parameter Type: [SynthesizePinchGestureParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SynthesizePinchGesture;
    impl crate::util::Command for SynthesizePinchGesture {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "synthesizePinchGesture"
        }
    }
    ///
    /// Parameter value for [SynthesizeScrollGesture].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SynthesizeScrollGestureParams {
        ///X coordinate of the start of the gesture in CSS pixels.
        #[serde(rename = "x")]
        pub x: f64,
        ///Y coordinate of the start of the gesture in CSS pixels.
        #[serde(rename = "y")]
        pub y: f64,
        ///The distance to scroll along the X axis (positive to scroll left).
        #[serde(rename = "xDistance")]
        pub x_distance: Option<f64>,
        ///The distance to scroll along the Y axis (positive to scroll up).
        #[serde(rename = "yDistance")]
        pub y_distance: Option<f64>,
        ///The number of additional pixels to scroll back along the X axis, in addition to the given
        ///distance.
        #[serde(rename = "xOverscroll")]
        pub x_overscroll: Option<f64>,
        ///The number of additional pixels to scroll back along the Y axis, in addition to the given
        ///distance.
        #[serde(rename = "yOverscroll")]
        pub y_overscroll: Option<f64>,
        ///Prevent fling (default: true).
        #[serde(rename = "preventFling")]
        pub prevent_fling: Option<bool>,
        ///Swipe speed in pixels per second (default: 800).
        #[serde(rename = "speed")]
        pub speed: Option<i64>,
        ///Which type of input events to be generated (default: 'default', which queries the platform
        ///for the preferred input type).
        #[serde(rename = "gestureSourceType")]
        pub gesture_source_type: Option<GestureSourceType>,
        ///The number of times to repeat the gesture (default: 0).
        #[serde(rename = "repeatCount")]
        pub repeat_count: Option<i64>,
        ///The number of milliseconds delay between each repeat. (default: 250).
        #[serde(rename = "repeatDelayMs")]
        pub repeat_delay_ms: Option<i64>,
        ///The name of the interaction markers to generate, if not empty (default: "").
        #[serde(rename = "interactionMarkerName")]
        pub interaction_marker_name: Option<String>,
    }
    ///Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
    ///---
    ///Parameter Type: [SynthesizeScrollGestureParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SynthesizeScrollGesture;
    impl crate::util::Command for SynthesizeScrollGesture {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "synthesizeScrollGesture"
        }
    }
    ///
    /// Parameter value for [SynthesizeTapGesture].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SynthesizeTapGestureParams {
        ///X coordinate of the start of the gesture in CSS pixels.
        #[serde(rename = "x")]
        pub x: f64,
        ///Y coordinate of the start of the gesture in CSS pixels.
        #[serde(rename = "y")]
        pub y: f64,
        ///Duration between touchdown and touchup events in ms (default: 50).
        #[serde(rename = "duration")]
        pub duration: Option<i64>,
        ///Number of times to perform the tap (e.g. 2 for double tap, default: 1).
        #[serde(rename = "tapCount")]
        pub tap_count: Option<i64>,
        ///Which type of input events to be generated (default: 'default', which queries the platform
        ///for the preferred input type).
        #[serde(rename = "gestureSourceType")]
        pub gesture_source_type: Option<GestureSourceType>,
    }
    ///Synthesizes a tap gesture over a time period by issuing appropriate touch events.
    ///---
    ///Parameter Type: [SynthesizeTapGestureParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SynthesizeTapGesture;
    impl crate::util::Command for SynthesizeTapGesture {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "synthesizeTapGesture"
        }
    }
    ///Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
    ///restore normal drag and drop behavior.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DragInterceptedEvent {
        #[serde(rename = "data")]
        pub data: DragData,
    }
}
pub mod inspector {
    ///Disables inspector domain notifications.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables inspector domain notifications.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///Fired when remote debugging connection is about to be terminated. Contains detach reason.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DetachedEvent {
        ///The reason why connection has been terminated.
        #[serde(rename = "reason")]
        pub reason: String,
    }
    ///Fired when debugging target has crashed
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TargetCrashedEvent {}
    ///Fired when debugging target has reloaded after crash
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TargetReloadedAfterCrashEvent {}
}
pub mod layer_tree {
    ///Unique Layer identifier.
    pub type LayerId = String;
    ///Unique snapshot identifier.
    pub type SnapshotId = String;
    ///
    /// Enum for [ScrollRect]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ScrollRectType {
        #[serde(rename = "RepaintsOnScroll")]
        RepaintsOnScroll,
        #[serde(rename = "TouchEventHandler")]
        TouchEventHandler,
        #[serde(rename = "WheelEventHandler")]
        WheelEventHandler,
    }
    ///Rectangle where scrolling happens on the main thread.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScrollRect {
        ///Rectangle itself.
        #[serde(rename = "rect")]
        pub rect: crate::protocol_test::dom::Rect,
        ///Reason for rectangle to force scrolling on the main thread
        #[serde(rename = "type")]
        pub type_: ScrollRectType,
    }
    ///Sticky position constraints.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StickyPositionConstraint {
        ///Layout rectangle of the sticky element before being shifted
        #[serde(rename = "stickyBoxRect")]
        pub sticky_box_rect: crate::protocol_test::dom::Rect,
        ///Layout rectangle of the containing block of the sticky element
        #[serde(rename = "containingBlockRect")]
        pub containing_block_rect: crate::protocol_test::dom::Rect,
        ///The nearest sticky layer that shifts the sticky box
        #[serde(rename = "nearestLayerShiftingStickyBox")]
        pub nearest_layer_shifting_sticky_box: Option<LayerId>,
        ///The nearest sticky layer that shifts the containing block
        #[serde(rename = "nearestLayerShiftingContainingBlock")]
        pub nearest_layer_shifting_containing_block: Option<LayerId>,
    }
    ///Serialized fragment of layer picture along with its offset within the layer.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PictureTile {
        ///Offset from owning layer left boundary
        #[serde(rename = "x")]
        pub x: f64,
        ///Offset from owning layer top boundary
        #[serde(rename = "y")]
        pub y: f64,
        ///Base64-encoded snapshot data. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "picture")]
        pub picture: String,
    }
    ///Information about a compositing layer.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Layer {
        ///The unique id for this layer.
        #[serde(rename = "layerId")]
        pub layer_id: LayerId,
        ///The id of parent (not present for root).
        #[serde(rename = "parentLayerId")]
        pub parent_layer_id: Option<LayerId>,
        ///The backend id for the node associated with this layer.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///Offset from parent layer, X coordinate.
        #[serde(rename = "offsetX")]
        pub offset_x: f64,
        ///Offset from parent layer, Y coordinate.
        #[serde(rename = "offsetY")]
        pub offset_y: f64,
        ///Layer width.
        #[serde(rename = "width")]
        pub width: f64,
        ///Layer height.
        #[serde(rename = "height")]
        pub height: f64,
        ///Transformation matrix for layer, default is identity matrix
        #[serde(rename = "transform")]
        pub transform: Option<Vec<f64>>,
        ///Transform anchor point X, absent if no transform specified
        #[serde(rename = "anchorX")]
        pub anchor_x: Option<f64>,
        ///Transform anchor point Y, absent if no transform specified
        #[serde(rename = "anchorY")]
        pub anchor_y: Option<f64>,
        ///Transform anchor point Z, absent if no transform specified
        #[serde(rename = "anchorZ")]
        pub anchor_z: Option<f64>,
        ///Indicates how many time this layer has painted.
        #[serde(rename = "paintCount")]
        pub paint_count: i64,
        ///Indicates whether this layer hosts any content, rather than being used for
        ///transform/scrolling purposes only.
        #[serde(rename = "drawsContent")]
        pub draws_content: bool,
        ///Set if layer is not visible.
        #[serde(rename = "invisible")]
        pub invisible: Option<bool>,
        ///Rectangles scrolling on main thread only.
        #[serde(rename = "scrollRects")]
        pub scroll_rects: Option<Vec<ScrollRect>>,
        ///Sticky position constraint information
        #[serde(rename = "stickyPositionConstraint")]
        pub sticky_position_constraint: Option<StickyPositionConstraint>,
    }
    ///Array of timings, one per paint step.
    pub type PaintProfile = Vec<f64>;
    ///
    /// Parameter value for [CompositingReasons].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CompositingReasonsParams {
        ///The id of the layer for which we want to get the reasons it was composited.
        #[serde(rename = "layerId")]
        pub layer_id: LayerId,
    }
    ///
    /// Return value for [CompositingReasons].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CompositingReasonsReturns {
        ///A list of strings specifying reasons for the given layer to become composited.
        #[serde(rename = "compositingReasons")]
        pub compositing_reasons: Vec<String>,
        ///A list of strings specifying reason IDs for the given layer to become composited.
        #[serde(rename = "compositingReasonIds")]
        pub compositing_reason_ids: Vec<String>,
    }
    ///Provides the reasons why the given layer was composited.
    ///---
    ///Parameter Type: [CompositingReasonsParams]
    ///Return Type: [CompositingReasonsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CompositingReasons;
    impl crate::util::Command for CompositingReasons {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "compositingReasons"
        }
    }
    ///Disables compositing tree inspection.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables compositing tree inspection.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [LoadSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadSnapshotParams {
        ///An array of tiles composing the snapshot.
        #[serde(rename = "tiles")]
        pub tiles: Vec<PictureTile>,
    }
    ///
    /// Return value for [LoadSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadSnapshotReturns {
        ///The id of the snapshot.
        #[serde(rename = "snapshotId")]
        pub snapshot_id: SnapshotId,
    }
    ///Returns the snapshot identifier.
    ///---
    ///Parameter Type: [LoadSnapshotParams]
    ///Return Type: [LoadSnapshotReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadSnapshot;
    impl crate::util::Command for LoadSnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "loadSnapshot"
        }
    }
    ///
    /// Parameter value for [MakeSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MakeSnapshotParams {
        ///The id of the layer.
        #[serde(rename = "layerId")]
        pub layer_id: LayerId,
    }
    ///
    /// Return value for [MakeSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MakeSnapshotReturns {
        ///The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        pub snapshot_id: SnapshotId,
    }
    ///Returns the layer snapshot identifier.
    ///---
    ///Parameter Type: [MakeSnapshotParams]
    ///Return Type: [MakeSnapshotReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MakeSnapshot;
    impl crate::util::Command for MakeSnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "makeSnapshot"
        }
    }
    ///
    /// Parameter value for [ProfileSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ProfileSnapshotParams {
        ///The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        pub snapshot_id: SnapshotId,
        ///The maximum number of times to replay the snapshot (1, if not specified).
        #[serde(rename = "minRepeatCount")]
        pub min_repeat_count: Option<i64>,
        ///The minimum duration (in seconds) to replay the snapshot.
        #[serde(rename = "minDuration")]
        pub min_duration: Option<f64>,
        ///The clip rectangle to apply when replaying the snapshot.
        #[serde(rename = "clipRect")]
        pub clip_rect: Option<crate::protocol_test::dom::Rect>,
    }
    ///
    /// Return value for [ProfileSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ProfileSnapshotReturns {
        ///The array of paint profiles, one per run.
        #[serde(rename = "timings")]
        pub timings: Vec<PaintProfile>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ProfileSnapshot;
    impl crate::util::Command for ProfileSnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "profileSnapshot"
        }
    }
    ///
    /// Parameter value for [ReleaseSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReleaseSnapshotParams {
        ///The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        pub snapshot_id: SnapshotId,
    }
    ///Releases layer snapshot captured by the back-end.
    ///---
    ///Parameter Type: [ReleaseSnapshotParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReleaseSnapshot;
    impl crate::util::Command for ReleaseSnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "releaseSnapshot"
        }
    }
    ///
    /// Parameter value for [ReplaySnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReplaySnapshotParams {
        ///The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        pub snapshot_id: SnapshotId,
        ///The first step to replay from (replay from the very start if not specified).
        #[serde(rename = "fromStep")]
        pub from_step: Option<i64>,
        ///The last step to replay to (replay till the end if not specified).
        #[serde(rename = "toStep")]
        pub to_step: Option<i64>,
        ///The scale to apply while replaying (defaults to 1).
        #[serde(rename = "scale")]
        pub scale: Option<f64>,
    }
    ///
    /// Return value for [ReplaySnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReplaySnapshotReturns {
        ///A data: URL for resulting image.
        #[serde(rename = "dataURL")]
        pub data_url: String,
    }
    ///Replays the layer snapshot and returns the resulting bitmap.
    ///---
    ///Parameter Type: [ReplaySnapshotParams]
    ///Return Type: [ReplaySnapshotReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReplaySnapshot;
    impl crate::util::Command for ReplaySnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "replaySnapshot"
        }
    }
    ///
    /// Parameter value for [SnapshotCommandLog].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SnapshotCommandLogParams {
        ///The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        pub snapshot_id: SnapshotId,
    }
    ///
    /// Return value for [SnapshotCommandLog].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SnapshotCommandLogReturns {
        ///The array of canvas function calls.
        #[serde(rename = "commandLog")]
        pub command_log: Vec<serde_json::Map<String, serde_json::Value>>,
    }
    ///Replays the layer snapshot and returns canvas log.
    ///---
    ///Parameter Type: [SnapshotCommandLogParams]
    ///Return Type: [SnapshotCommandLogReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SnapshotCommandLog;
    impl crate::util::Command for SnapshotCommandLog {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "snapshotCommandLog"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LayerPaintedEvent {
        ///The id of the painted layer.
        #[serde(rename = "layerId")]
        pub layer_id: LayerId,
        ///Clip rectangle.
        #[serde(rename = "clip")]
        pub clip: crate::protocol_test::dom::Rect,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LayerTreeDidChangeEvent {
        ///Layer tree, absent if not in the comspositing mode.
        #[serde(rename = "layers")]
        pub layers: Option<Vec<Layer>>,
    }
}
///Provides access to log entries.
pub mod log {
    ///
    /// Enum for [LogEntry]'s `source`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum LogEntrySource {
        #[serde(rename = "xml")]
        Xml,
        #[serde(rename = "javascript")]
        Javascript,
        #[serde(rename = "network")]
        Network,
        #[serde(rename = "storage")]
        Storage,
        #[serde(rename = "appcache")]
        Appcache,
        #[serde(rename = "rendering")]
        Rendering,
        #[serde(rename = "security")]
        Security,
        #[serde(rename = "deprecation")]
        Deprecation,
        #[serde(rename = "worker")]
        Worker,
        #[serde(rename = "violation")]
        Violation,
        #[serde(rename = "intervention")]
        Intervention,
        #[serde(rename = "recommendation")]
        Recommendation,
        #[serde(rename = "other")]
        Other,
    }
    ///
    /// Enum for [LogEntry]'s `level`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum LogEntryLevel {
        #[serde(rename = "verbose")]
        Verbose,
        #[serde(rename = "info")]
        Info,
        #[serde(rename = "warning")]
        Warning,
        #[serde(rename = "error")]
        Error,
    }
    ///
    /// Enum for [LogEntry]'s `category`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum LogEntryCategory {
        #[serde(rename = "cors")]
        Cors,
    }
    ///Log entry.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LogEntry {
        ///Log entry source.
        #[serde(rename = "source")]
        pub source: LogEntrySource,
        ///Log entry severity.
        #[serde(rename = "level")]
        pub level: LogEntryLevel,
        ///Logged text.
        #[serde(rename = "text")]
        pub text: String,
        #[serde(rename = "category")]
        pub category: Option<Option<LogEntryCategory>>,
        ///Timestamp when this entry was added.
        #[serde(rename = "timestamp")]
        pub timestamp: crate::protocol_test::runtime::Timestamp,
        ///URL of the resource if known.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///Line number in the resource.
        #[serde(rename = "lineNumber")]
        pub line_number: Option<i64>,
        ///JavaScript stack trace.
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<crate::protocol_test::runtime::StackTrace>,
        ///Identifier of the network request associated with this entry.
        #[serde(rename = "networkRequestId")]
        pub network_request_id: Option<crate::protocol_test::network::RequestId>,
        ///Identifier of the worker associated with this entry.
        #[serde(rename = "workerId")]
        pub worker_id: Option<String>,
        ///Call arguments.
        #[serde(rename = "args")]
        pub args: Option<Vec<crate::protocol_test::runtime::RemoteObject>>,
    }
    ///
    /// Enum for [ViolationSetting]'s `name`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ViolationSettingName {
        #[serde(rename = "longTask")]
        LongTask,
        #[serde(rename = "longLayout")]
        LongLayout,
        #[serde(rename = "blockedEvent")]
        BlockedEvent,
        #[serde(rename = "blockedParser")]
        BlockedParser,
        #[serde(rename = "discouragedAPIUse")]
        DiscouragedApiUse,
        #[serde(rename = "handler")]
        Handler,
        #[serde(rename = "recurringHandler")]
        RecurringHandler,
    }
    ///Violation configuration setting.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ViolationSetting {
        ///Violation type.
        #[serde(rename = "name")]
        pub name: ViolationSettingName,
        ///Time threshold to trigger upon.
        #[serde(rename = "threshold")]
        pub threshold: f64,
    }
    ///Clears the log.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Clear;
    impl crate::util::Command for Clear {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clear"
        }
    }
    ///Disables log domain, prevents further log entries from being reported to the client.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables log domain, sends the entries collected so far to the client by means of the
    ///`entryAdded` notification.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [StartViolationsReport].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartViolationsReportParams {
        ///Configuration for violations.
        #[serde(rename = "config")]
        pub config: Vec<ViolationSetting>,
    }
    ///start violation reporting.
    ///---
    ///Parameter Type: [StartViolationsReportParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartViolationsReport;
    impl crate::util::Command for StartViolationsReport {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startViolationsReport"
        }
    }
    ///Stop violation reporting.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopViolationsReport;
    impl crate::util::Command for StopViolationsReport {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopViolationsReport"
        }
    }
    ///Issued when new message was logged.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EntryAddedEvent {
        ///The entry.
        #[serde(rename = "entry")]
        pub entry: LogEntry,
    }
}
pub mod memory {
    ///Memory pressure level.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PressureLevel {
        #[serde(rename = "moderate")]
        Moderate,
        #[serde(rename = "critical")]
        Critical,
    }
    ///Heap profile sample.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SamplingProfileNode {
        ///Size of the sampled allocation.
        #[serde(rename = "size")]
        pub size: f64,
        ///Total bytes attributed to this sample.
        #[serde(rename = "total")]
        pub total: f64,
        ///Execution stack at the point of allocation.
        #[serde(rename = "stack")]
        pub stack: Vec<String>,
    }
    ///Array of heap profile samples.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SamplingProfile {
        #[serde(rename = "samples")]
        pub samples: Vec<SamplingProfileNode>,
        #[serde(rename = "modules")]
        pub modules: Vec<Module>,
    }
    ///Executable module information
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Module {
        ///Name of the module.
        #[serde(rename = "name")]
        pub name: String,
        ///UUID of the module.
        #[serde(rename = "uuid")]
        pub uuid: String,
        ///Base address where the module is loaded into memory. Encoded as a decimal
        ///or hexadecimal (0x prefixed) string.
        #[serde(rename = "baseAddress")]
        pub base_address: String,
        ///Size of the module in bytes.
        #[serde(rename = "size")]
        pub size: f64,
    }
    ///
    /// Return value for [GetDomCounters].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDomCountersReturns {
        #[serde(rename = "documents")]
        pub documents: i64,
        #[serde(rename = "nodes")]
        pub nodes: i64,
        #[serde(rename = "jsEventListeners")]
        pub js_event_listeners: i64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDomCounters;
    impl crate::util::Command for GetDomCounters {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getDOMCounters"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PrepareForLeakDetection;
    impl crate::util::Command for PrepareForLeakDetection {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "prepareForLeakDetection"
        }
    }
    ///Simulate OomIntervention by purging V8 memory.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ForciblyPurgeJavaScriptMemory;
    impl crate::util::Command for ForciblyPurgeJavaScriptMemory {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "forciblyPurgeJavaScriptMemory"
        }
    }
    ///
    /// Parameter value for [SetPressureNotificationsSuppressed].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPressureNotificationsSuppressedParams {
        ///If true, memory pressure notifications will be suppressed.
        #[serde(rename = "suppressed")]
        pub suppressed: bool,
    }
    ///Enable/disable suppressing memory pressure notifications in all processes.
    ///---
    ///Parameter Type: [SetPressureNotificationsSuppressedParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPressureNotificationsSuppressed;
    impl crate::util::Command for SetPressureNotificationsSuppressed {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setPressureNotificationsSuppressed"
        }
    }
    ///
    /// Parameter value for [SimulatePressureNotification].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SimulatePressureNotificationParams {
        ///Memory pressure level of the notification.
        #[serde(rename = "level")]
        pub level: PressureLevel,
    }
    ///Simulate a memory pressure notification in all processes.
    ///---
    ///Parameter Type: [SimulatePressureNotificationParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SimulatePressureNotification;
    impl crate::util::Command for SimulatePressureNotification {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "simulatePressureNotification"
        }
    }
    ///
    /// Parameter value for [StartSampling].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartSamplingParams {
        ///Average number of bytes between samples.
        #[serde(rename = "samplingInterval")]
        pub sampling_interval: Option<i64>,
        ///Do not randomize intervals between samples.
        #[serde(rename = "suppressRandomness")]
        pub suppress_randomness: Option<bool>,
    }
    ///Start collecting native memory profile.
    ///---
    ///Parameter Type: [StartSamplingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartSampling;
    impl crate::util::Command for StartSampling {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startSampling"
        }
    }
    ///Stop collecting native memory profile.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopSampling;
    impl crate::util::Command for StopSampling {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopSampling"
        }
    }
    ///
    /// Return value for [GetAllTimeSamplingProfile].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAllTimeSamplingProfileReturns {
        #[serde(rename = "profile")]
        pub profile: SamplingProfile,
    }
    ///Retrieve native memory allocations profile
    ///collected since renderer process startup.
    ///---
    ///Return Type: [GetAllTimeSamplingProfileReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAllTimeSamplingProfile;
    impl crate::util::Command for GetAllTimeSamplingProfile {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getAllTimeSamplingProfile"
        }
    }
    ///
    /// Return value for [GetBrowserSamplingProfile].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBrowserSamplingProfileReturns {
        #[serde(rename = "profile")]
        pub profile: SamplingProfile,
    }
    ///Retrieve native memory allocations profile
    ///collected since browser process startup.
    ///---
    ///Return Type: [GetBrowserSamplingProfileReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBrowserSamplingProfile;
    impl crate::util::Command for GetBrowserSamplingProfile {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getBrowserSamplingProfile"
        }
    }
    ///
    /// Return value for [GetSamplingProfile].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSamplingProfileReturns {
        #[serde(rename = "profile")]
        pub profile: SamplingProfile,
    }
    ///Retrieve native memory allocations profile collected since last
    ///`startSampling` call.
    ///---
    ///Return Type: [GetSamplingProfileReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSamplingProfile;
    impl crate::util::Command for GetSamplingProfile {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getSamplingProfile"
        }
    }
}
///Network domain allows tracking network activities of the page. It exposes information about http,
///file, data and other requests and responses, their headers, bodies, timing, etc.
pub mod network {
    ///Resource type as it was perceived by the rendering engine.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ResourceType {
        #[serde(rename = "Document")]
        Document,
        #[serde(rename = "Stylesheet")]
        Stylesheet,
        #[serde(rename = "Image")]
        Image,
        #[serde(rename = "Media")]
        Media,
        #[serde(rename = "Font")]
        Font,
        #[serde(rename = "Script")]
        Script,
        #[serde(rename = "TextTrack")]
        TextTrack,
        #[serde(rename = "XHR")]
        Xhr,
        #[serde(rename = "Fetch")]
        Fetch,
        #[serde(rename = "Prefetch")]
        Prefetch,
        #[serde(rename = "EventSource")]
        EventSource,
        #[serde(rename = "WebSocket")]
        WebSocket,
        #[serde(rename = "Manifest")]
        Manifest,
        #[serde(rename = "SignedExchange")]
        SignedExchange,
        #[serde(rename = "Ping")]
        Ping,
        #[serde(rename = "CSPViolationReport")]
        CspViolationReport,
        #[serde(rename = "Preflight")]
        Preflight,
        #[serde(rename = "Other")]
        Other,
    }
    ///Unique loader identifier.
    pub type LoaderId = String;
    ///Unique request identifier.
    pub type RequestId = String;
    ///Unique intercepted request identifier.
    pub type InterceptionId = String;
    ///Network level fetch failure reason.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ErrorReason {
        #[serde(rename = "Failed")]
        Failed,
        #[serde(rename = "Aborted")]
        Aborted,
        #[serde(rename = "TimedOut")]
        TimedOut,
        #[serde(rename = "AccessDenied")]
        AccessDenied,
        #[serde(rename = "ConnectionClosed")]
        ConnectionClosed,
        #[serde(rename = "ConnectionReset")]
        ConnectionReset,
        #[serde(rename = "ConnectionRefused")]
        ConnectionRefused,
        #[serde(rename = "ConnectionAborted")]
        ConnectionAborted,
        #[serde(rename = "ConnectionFailed")]
        ConnectionFailed,
        #[serde(rename = "NameNotResolved")]
        NameNotResolved,
        #[serde(rename = "InternetDisconnected")]
        InternetDisconnected,
        #[serde(rename = "AddressUnreachable")]
        AddressUnreachable,
        #[serde(rename = "BlockedByClient")]
        BlockedByClient,
        #[serde(rename = "BlockedByResponse")]
        BlockedByResponse,
    }
    ///UTC time in seconds, counted from January 1, 1970.
    pub type TimeSinceEpoch = f64;
    ///Monotonically increasing time in seconds since an arbitrary point in the past.
    pub type MonotonicTime = f64;
    ///Request / response headers as keys / values of JSON object.
    pub type Headers = serde_json::Map<String, serde_json::Value>;
    ///The underlying connection technology that the browser is supposedly using.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ConnectionType {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "cellular2g")]
        Cellular2G,
        #[serde(rename = "cellular3g")]
        Cellular3G,
        #[serde(rename = "cellular4g")]
        Cellular4G,
        #[serde(rename = "bluetooth")]
        Bluetooth,
        #[serde(rename = "ethernet")]
        Ethernet,
        #[serde(rename = "wifi")]
        Wifi,
        #[serde(rename = "wimax")]
        Wimax,
        #[serde(rename = "other")]
        Other,
    }
    ///Represents the cookie's 'SameSite' status:
    ///https://tools.ietf.org/html/draft-west-first-party-cookies
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CookieSameSite {
        #[serde(rename = "Strict")]
        Strict,
        #[serde(rename = "Lax")]
        Lax,
        #[serde(rename = "None")]
        None,
    }
    ///Represents the cookie's 'Priority' status:
    ///https://tools.ietf.org/html/draft-west-cookie-priority-00
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CookiePriority {
        #[serde(rename = "Low")]
        Low,
        #[serde(rename = "Medium")]
        Medium,
        #[serde(rename = "High")]
        High,
    }
    ///Represents the source scheme of the origin that originally set the cookie.
    ///A value of "Unset" allows protocol clients to emulate legacy cookie scope for the scheme.
    ///This is a temporary ability and it will be removed in the future.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CookieSourceScheme {
        #[serde(rename = "Unset")]
        Unset,
        #[serde(rename = "NonSecure")]
        NonSecure,
        #[serde(rename = "Secure")]
        Secure,
    }
    ///Timing information for the request.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResourceTiming {
        ///Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
        ///milliseconds relatively to this requestTime.
        #[serde(rename = "requestTime")]
        pub request_time: f64,
        ///Started resolving proxy.
        #[serde(rename = "proxyStart")]
        pub proxy_start: f64,
        ///Finished resolving proxy.
        #[serde(rename = "proxyEnd")]
        pub proxy_end: f64,
        ///Started DNS address resolve.
        #[serde(rename = "dnsStart")]
        pub dns_start: f64,
        ///Finished DNS address resolve.
        #[serde(rename = "dnsEnd")]
        pub dns_end: f64,
        ///Started connecting to the remote host.
        #[serde(rename = "connectStart")]
        pub connect_start: f64,
        ///Connected to the remote host.
        #[serde(rename = "connectEnd")]
        pub connect_end: f64,
        ///Started SSL handshake.
        #[serde(rename = "sslStart")]
        pub ssl_start: f64,
        ///Finished SSL handshake.
        #[serde(rename = "sslEnd")]
        pub ssl_end: f64,
        ///Started running ServiceWorker.
        #[serde(rename = "workerStart")]
        pub worker_start: f64,
        ///Finished Starting ServiceWorker.
        #[serde(rename = "workerReady")]
        pub worker_ready: f64,
        ///Started fetch event.
        #[serde(rename = "workerFetchStart")]
        pub worker_fetch_start: f64,
        ///Settled fetch event respondWith promise.
        #[serde(rename = "workerRespondWithSettled")]
        pub worker_respond_with_settled: f64,
        ///Started sending request.
        #[serde(rename = "sendStart")]
        pub send_start: f64,
        ///Finished sending request.
        #[serde(rename = "sendEnd")]
        pub send_end: f64,
        ///Time the server started pushing request.
        #[serde(rename = "pushStart")]
        pub push_start: f64,
        ///Time the server finished pushing request.
        #[serde(rename = "pushEnd")]
        pub push_end: f64,
        ///Started receiving response headers.
        #[serde(rename = "receiveHeadersStart")]
        pub receive_headers_start: f64,
        ///Finished receiving response headers.
        #[serde(rename = "receiveHeadersEnd")]
        pub receive_headers_end: f64,
    }
    ///Loading priority of a resource request.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ResourcePriority {
        #[serde(rename = "VeryLow")]
        VeryLow,
        #[serde(rename = "Low")]
        Low,
        #[serde(rename = "Medium")]
        Medium,
        #[serde(rename = "High")]
        High,
        #[serde(rename = "VeryHigh")]
        VeryHigh,
    }
    ///Post data entry for HTTP request
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PostDataEntry {
        #[serde(rename = "bytes")]
        pub bytes: Option<String>,
    }
    ///
    /// Enum for [Request]'s `referrer_policy`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum RequestReferrerPolicy {
        #[serde(rename = "unsafe-url")]
        UnsafeUrl,
        #[serde(rename = "no-referrer-when-downgrade")]
        NoReferrerWhenDowngrade,
        #[serde(rename = "no-referrer")]
        NoReferrer,
        #[serde(rename = "origin")]
        Origin,
        #[serde(rename = "origin-when-cross-origin")]
        OriginWhenCrossOrigin,
        #[serde(rename = "same-origin")]
        SameOrigin,
        #[serde(rename = "strict-origin")]
        StrictOrigin,
        #[serde(rename = "strict-origin-when-cross-origin")]
        StrictOriginWhenCrossOrigin,
    }
    ///HTTP request data.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Request {
        ///Request URL (without fragment).
        #[serde(rename = "url")]
        pub url: String,
        ///Fragment of the requested URL starting with hash, if present.
        #[serde(rename = "urlFragment")]
        pub url_fragment: Option<String>,
        ///HTTP request method.
        #[serde(rename = "method")]
        pub method: String,
        ///HTTP request headers.
        #[serde(rename = "headers")]
        pub headers: Headers,
        ///HTTP POST request data.
        #[serde(rename = "postData")]
        pub post_data: Option<String>,
        ///True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
        #[serde(rename = "hasPostData")]
        pub has_post_data: Option<bool>,
        ///Request body elements. This will be converted from base64 to binary
        #[serde(rename = "postDataEntries")]
        pub post_data_entries: Option<Vec<PostDataEntry>>,
        ///The mixed content type of the request.
        #[serde(rename = "mixedContentType")]
        pub mixed_content_type: Option<crate::protocol_test::security::MixedContentType>,
        ///Priority of the resource request at the time request is sent.
        #[serde(rename = "initialPriority")]
        pub initial_priority: ResourcePriority,
        ///The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
        #[serde(rename = "referrerPolicy")]
        pub referrer_policy: RequestReferrerPolicy,
        ///Whether is loaded via link preload.
        #[serde(rename = "isLinkPreload")]
        pub is_link_preload: Option<bool>,
        ///Set for requests when the TrustToken API is used. Contains the parameters
        ///passed by the developer (e.g. via "fetch") as understood by the backend.
        #[serde(rename = "trustTokenParams")]
        pub trust_token_params: Option<TrustTokenParams>,
        ///True if this resource request is considered to be the 'same site' as the
        ///request correspondinfg to the main frame.
        #[serde(rename = "isSameSite")]
        pub is_same_site: Option<bool>,
    }
    ///Details of a signed certificate timestamp (SCT).
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignedCertificateTimestamp {
        ///Validation status.
        #[serde(rename = "status")]
        pub status: String,
        ///Origin.
        #[serde(rename = "origin")]
        pub origin: String,
        ///Log name / description.
        #[serde(rename = "logDescription")]
        pub log_description: String,
        ///Log ID.
        #[serde(rename = "logId")]
        pub log_id: String,
        ///Issuance date. Unlike TimeSinceEpoch, this contains the number of
        ///milliseconds since January 1, 1970, UTC, not the number of seconds.
        #[serde(rename = "timestamp")]
        pub timestamp: f64,
        ///Hash algorithm.
        #[serde(rename = "hashAlgorithm")]
        pub hash_algorithm: String,
        ///Signature algorithm.
        #[serde(rename = "signatureAlgorithm")]
        pub signature_algorithm: String,
        ///Signature data.
        #[serde(rename = "signatureData")]
        pub signature_data: String,
    }
    ///Security details about a request.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SecurityDetails {
        ///Protocol name (e.g. "TLS 1.2" or "QUIC").
        #[serde(rename = "protocol")]
        pub protocol: String,
        ///Key Exchange used by the connection, or the empty string if not applicable.
        #[serde(rename = "keyExchange")]
        pub key_exchange: String,
        ///(EC)DH group used by the connection, if applicable.
        #[serde(rename = "keyExchangeGroup")]
        pub key_exchange_group: Option<String>,
        ///Cipher name.
        #[serde(rename = "cipher")]
        pub cipher: String,
        ///TLS MAC. Note that AEAD ciphers do not have separate MACs.
        #[serde(rename = "mac")]
        pub mac: Option<String>,
        ///Certificate ID value.
        #[serde(rename = "certificateId")]
        pub certificate_id: crate::protocol_test::security::CertificateId,
        ///Certificate subject name.
        #[serde(rename = "subjectName")]
        pub subject_name: String,
        ///Subject Alternative Name (SAN) DNS names and IP addresses.
        #[serde(rename = "sanList")]
        pub san_list: Vec<String>,
        ///Name of the issuing CA.
        #[serde(rename = "issuer")]
        pub issuer: String,
        ///Certificate valid from date.
        #[serde(rename = "validFrom")]
        pub valid_from: TimeSinceEpoch,
        ///Certificate valid to (expiration) date
        #[serde(rename = "validTo")]
        pub valid_to: TimeSinceEpoch,
        ///List of signed certificate timestamps (SCTs).
        #[serde(rename = "signedCertificateTimestampList")]
        pub signed_certificate_timestamp_list: Vec<SignedCertificateTimestamp>,
        ///Whether the request complied with Certificate Transparency policy
        #[serde(rename = "certificateTransparencyCompliance")]
        pub certificate_transparency_compliance: CertificateTransparencyCompliance,
        ///The signature algorithm used by the server in the TLS server signature,
        ///represented as a TLS SignatureScheme code point. Omitted if not
        ///applicable or not known.
        #[serde(rename = "serverSignatureAlgorithm")]
        pub server_signature_algorithm: Option<i64>,
        ///Whether the connection used Encrypted ClientHello
        #[serde(rename = "encryptedClientHello")]
        pub encrypted_client_hello: bool,
    }
    ///Whether the request complied with Certificate Transparency policy.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CertificateTransparencyCompliance {
        #[serde(rename = "unknown")]
        Unknown,
        #[serde(rename = "not-compliant")]
        NotCompliant,
        #[serde(rename = "compliant")]
        Compliant,
    }
    ///The reason why request was blocked.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum BlockedReason {
        #[serde(rename = "other")]
        Other,
        #[serde(rename = "csp")]
        Csp,
        #[serde(rename = "mixed-content")]
        MixedContent,
        #[serde(rename = "origin")]
        Origin,
        #[serde(rename = "inspector")]
        Inspector,
        #[serde(rename = "subresource-filter")]
        SubresourceFilter,
        #[serde(rename = "content-type")]
        ContentType,
        #[serde(rename = "coep-frame-resource-needs-coep-header")]
        CoepFrameResourceNeedsCoepHeader,
        #[serde(rename = "coop-sandboxed-iframe-cannot-navigate-to-coop-page")]
        CoopSandboxedIframeCannotNavigateToCoopPage,
        #[serde(rename = "corp-not-same-origin")]
        CorpNotSameOrigin,
        #[serde(rename = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        #[serde(rename = "corp-not-same-site")]
        CorpNotSameSite,
    }
    ///The reason why request was blocked.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CorsError {
        #[serde(rename = "DisallowedByMode")]
        DisallowedByMode,
        #[serde(rename = "InvalidResponse")]
        InvalidResponse,
        #[serde(rename = "WildcardOriginNotAllowed")]
        WildcardOriginNotAllowed,
        #[serde(rename = "MissingAllowOriginHeader")]
        MissingAllowOriginHeader,
        #[serde(rename = "MultipleAllowOriginValues")]
        MultipleAllowOriginValues,
        #[serde(rename = "InvalidAllowOriginValue")]
        InvalidAllowOriginValue,
        #[serde(rename = "AllowOriginMismatch")]
        AllowOriginMismatch,
        #[serde(rename = "InvalidAllowCredentials")]
        InvalidAllowCredentials,
        #[serde(rename = "CorsDisabledScheme")]
        CorsDisabledScheme,
        #[serde(rename = "PreflightInvalidStatus")]
        PreflightInvalidStatus,
        #[serde(rename = "PreflightDisallowedRedirect")]
        PreflightDisallowedRedirect,
        #[serde(rename = "PreflightWildcardOriginNotAllowed")]
        PreflightWildcardOriginNotAllowed,
        #[serde(rename = "PreflightMissingAllowOriginHeader")]
        PreflightMissingAllowOriginHeader,
        #[serde(rename = "PreflightMultipleAllowOriginValues")]
        PreflightMultipleAllowOriginValues,
        #[serde(rename = "PreflightInvalidAllowOriginValue")]
        PreflightInvalidAllowOriginValue,
        #[serde(rename = "PreflightAllowOriginMismatch")]
        PreflightAllowOriginMismatch,
        #[serde(rename = "PreflightInvalidAllowCredentials")]
        PreflightInvalidAllowCredentials,
        #[serde(rename = "PreflightMissingAllowExternal")]
        PreflightMissingAllowExternal,
        #[serde(rename = "PreflightInvalidAllowExternal")]
        PreflightInvalidAllowExternal,
        #[serde(rename = "PreflightMissingAllowPrivateNetwork")]
        PreflightMissingAllowPrivateNetwork,
        #[serde(rename = "PreflightInvalidAllowPrivateNetwork")]
        PreflightInvalidAllowPrivateNetwork,
        #[serde(rename = "InvalidAllowMethodsPreflightResponse")]
        InvalidAllowMethodsPreflightResponse,
        #[serde(rename = "InvalidAllowHeadersPreflightResponse")]
        InvalidAllowHeadersPreflightResponse,
        #[serde(rename = "MethodDisallowedByPreflightResponse")]
        MethodDisallowedByPreflightResponse,
        #[serde(rename = "HeaderDisallowedByPreflightResponse")]
        HeaderDisallowedByPreflightResponse,
        #[serde(rename = "RedirectContainsCredentials")]
        RedirectContainsCredentials,
        #[serde(rename = "InsecurePrivateNetwork")]
        InsecurePrivateNetwork,
        #[serde(rename = "InvalidPrivateNetworkAccess")]
        InvalidPrivateNetworkAccess,
        #[serde(rename = "UnexpectedPrivateNetworkAccess")]
        UnexpectedPrivateNetworkAccess,
        #[serde(rename = "NoCorsRedirectModeNotFollow")]
        NoCorsRedirectModeNotFollow,
        #[serde(rename = "PreflightMissingPrivateNetworkAccessId")]
        PreflightMissingPrivateNetworkAccessId,
        #[serde(rename = "PreflightMissingPrivateNetworkAccessName")]
        PreflightMissingPrivateNetworkAccessName,
        #[serde(rename = "PrivateNetworkAccessPermissionUnavailable")]
        PrivateNetworkAccessPermissionUnavailable,
        #[serde(rename = "PrivateNetworkAccessPermissionDenied")]
        PrivateNetworkAccessPermissionDenied,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CorsErrorStatus {
        #[serde(rename = "corsError")]
        pub cors_error: CorsError,
        #[serde(rename = "failedParameter")]
        pub failed_parameter: String,
    }
    ///Source of serviceworker response.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ServiceWorkerResponseSource {
        #[serde(rename = "cache-storage")]
        CacheStorage,
        #[serde(rename = "http-cache")]
        HttpCache,
        #[serde(rename = "fallback-code")]
        FallbackCode,
        #[serde(rename = "network")]
        Network,
    }
    ///
    /// Enum for [TrustTokenParams]'s `refresh_policy`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum TrustTokenParamsRefreshPolicy {
        #[serde(rename = "UseCached")]
        UseCached,
        #[serde(rename = "Refresh")]
        Refresh,
    }
    ///Determines what type of Trust Token operation is executed and
    ///depending on the type, some additional parameters. The values
    ///are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrustTokenParams {
        #[serde(rename = "operation")]
        pub operation: TrustTokenOperationType,
        ///Only set for "token-redemption" operation and determine whether
        ///to request a fresh SRR or use a still valid cached SRR.
        #[serde(rename = "refreshPolicy")]
        pub refresh_policy: TrustTokenParamsRefreshPolicy,
        ///Origins of issuers from whom to request tokens or redemption
        ///records.
        #[serde(rename = "issuers")]
        pub issuers: Option<Vec<String>>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum TrustTokenOperationType {
        #[serde(rename = "Issuance")]
        Issuance,
        #[serde(rename = "Redemption")]
        Redemption,
        #[serde(rename = "Signing")]
        Signing,
    }
    ///The reason why Chrome uses a specific transport protocol for HTTP semantics.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AlternateProtocolUsage {
        #[serde(rename = "alternativeJobWonWithoutRace")]
        AlternativeJobWonWithoutRace,
        #[serde(rename = "alternativeJobWonRace")]
        AlternativeJobWonRace,
        #[serde(rename = "mainJobWonRace")]
        MainJobWonRace,
        #[serde(rename = "mappingMissing")]
        MappingMissing,
        #[serde(rename = "broken")]
        Broken,
        #[serde(rename = "dnsAlpnH3JobWonWithoutRace")]
        DnsAlpnH3JobWonWithoutRace,
        #[serde(rename = "dnsAlpnH3JobWonRace")]
        DnsAlpnH3JobWonRace,
        #[serde(rename = "unspecifiedReason")]
        UnspecifiedReason,
    }
    ///HTTP response data.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Response {
        ///Response URL. This URL can be different from CachedResource.url in case of redirect.
        #[serde(rename = "url")]
        pub url: String,
        ///HTTP response status code.
        #[serde(rename = "status")]
        pub status: i64,
        ///HTTP response status text.
        #[serde(rename = "statusText")]
        pub status_text: String,
        ///HTTP response headers.
        #[serde(rename = "headers")]
        pub headers: Headers,
        ///HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.
        #[deprecated]
        #[serde(rename = "headersText")]
        pub headers_text: Option<String>,
        ///Resource mimeType as determined by the browser.
        #[serde(rename = "mimeType")]
        pub mime_type: String,
        ///Refined HTTP request headers that were actually transmitted over the network.
        #[serde(rename = "requestHeaders")]
        pub request_headers: Option<Headers>,
        ///HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.
        #[deprecated]
        #[serde(rename = "requestHeadersText")]
        pub request_headers_text: Option<String>,
        ///Specifies whether physical connection was actually reused for this request.
        #[serde(rename = "connectionReused")]
        pub connection_reused: bool,
        ///Physical connection id that was actually used for this request.
        #[serde(rename = "connectionId")]
        pub connection_id: f64,
        ///Remote IP address.
        #[serde(rename = "remoteIPAddress")]
        pub remote_ip_address: Option<String>,
        ///Remote port.
        #[serde(rename = "remotePort")]
        pub remote_port: Option<i64>,
        ///Specifies that the request was served from the disk cache.
        #[serde(rename = "fromDiskCache")]
        pub from_disk_cache: Option<bool>,
        ///Specifies that the request was served from the ServiceWorker.
        #[serde(rename = "fromServiceWorker")]
        pub from_service_worker: Option<bool>,
        ///Specifies that the request was served from the prefetch cache.
        #[serde(rename = "fromPrefetchCache")]
        pub from_prefetch_cache: Option<bool>,
        ///Total number of bytes received for this request so far.
        #[serde(rename = "encodedDataLength")]
        pub encoded_data_length: f64,
        ///Timing information for the given request.
        #[serde(rename = "timing")]
        pub timing: Option<ResourceTiming>,
        ///Response source of response from ServiceWorker.
        #[serde(rename = "serviceWorkerResponseSource")]
        pub service_worker_response_source: Option<ServiceWorkerResponseSource>,
        ///The time at which the returned response was generated.
        #[serde(rename = "responseTime")]
        pub response_time: Option<TimeSinceEpoch>,
        ///Cache Storage Cache Name.
        #[serde(rename = "cacheStorageCacheName")]
        pub cache_storage_cache_name: Option<String>,
        ///Protocol used to fetch this request.
        #[serde(rename = "protocol")]
        pub protocol: Option<String>,
        ///The reason why Chrome uses a specific transport protocol for HTTP semantics.
        #[serde(rename = "alternateProtocolUsage")]
        pub alternate_protocol_usage: Option<AlternateProtocolUsage>,
        ///Security state of the request resource.
        #[serde(rename = "securityState")]
        pub security_state: crate::protocol_test::security::SecurityState,
        ///Security details for the request.
        #[serde(rename = "securityDetails")]
        pub security_details: Option<SecurityDetails>,
    }
    ///WebSocket request data.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketRequest {
        ///HTTP request headers.
        #[serde(rename = "headers")]
        pub headers: Headers,
    }
    ///WebSocket response data.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketResponse {
        ///HTTP response status code.
        #[serde(rename = "status")]
        pub status: i64,
        ///HTTP response status text.
        #[serde(rename = "statusText")]
        pub status_text: String,
        ///HTTP response headers.
        #[serde(rename = "headers")]
        pub headers: Headers,
        ///HTTP response headers text.
        #[serde(rename = "headersText")]
        pub headers_text: Option<String>,
        ///HTTP request headers.
        #[serde(rename = "requestHeaders")]
        pub request_headers: Option<Headers>,
        ///HTTP request headers text.
        #[serde(rename = "requestHeadersText")]
        pub request_headers_text: Option<String>,
    }
    ///WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketFrame {
        ///WebSocket message opcode.
        #[serde(rename = "opcode")]
        pub opcode: f64,
        ///WebSocket message mask.
        #[serde(rename = "mask")]
        pub mask: bool,
        ///WebSocket message payload data.
        ///If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
        ///If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
        #[serde(rename = "payloadData")]
        pub payload_data: String,
    }
    ///Information about the cached resource.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CachedResource {
        ///Resource URL. This is the url of the original network request.
        #[serde(rename = "url")]
        pub url: String,
        ///Type of this resource.
        #[serde(rename = "type")]
        pub type_: ResourceType,
        ///Cached response data.
        #[serde(rename = "response")]
        pub response: Option<Response>,
        ///Cached response body size.
        #[serde(rename = "bodySize")]
        pub body_size: f64,
    }
    ///
    /// Enum for [Initiator]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum InitiatorType {
        #[serde(rename = "parser")]
        Parser,
        #[serde(rename = "script")]
        Script,
        #[serde(rename = "preload")]
        Preload,
        #[serde(rename = "SignedExchange")]
        SignedExchange,
        #[serde(rename = "preflight")]
        Preflight,
        #[serde(rename = "other")]
        Other,
    }
    ///Information about the request initiator.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Initiator {
        ///Type of this initiator.
        #[serde(rename = "type")]
        pub type_: InitiatorType,
        ///Initiator JavaScript stack trace, set for Script only.
        #[serde(rename = "stack")]
        pub stack: Option<crate::protocol_test::runtime::StackTrace>,
        ///Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///Initiator line number, set for Parser type or for Script type (when script is importing
        ///module) (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: Option<f64>,
        ///Initiator column number, set for Parser type or for Script type (when script is importing
        ///module) (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: Option<f64>,
        ///Set if another request triggered this request (e.g. preflight).
        #[serde(rename = "requestId")]
        pub request_id: Option<RequestId>,
    }
    ///Cookie object
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Cookie {
        ///Cookie name.
        #[serde(rename = "name")]
        pub name: String,
        ///Cookie value.
        #[serde(rename = "value")]
        pub value: String,
        ///Cookie domain.
        #[serde(rename = "domain")]
        pub domain: String,
        ///Cookie path.
        #[serde(rename = "path")]
        pub path: String,
        ///Cookie expiration date as the number of seconds since the UNIX epoch.
        #[serde(rename = "expires")]
        pub expires: f64,
        ///Cookie size.
        #[serde(rename = "size")]
        pub size: i64,
        ///True if cookie is http-only.
        #[serde(rename = "httpOnly")]
        pub http_only: bool,
        ///True if cookie is secure.
        #[serde(rename = "secure")]
        pub secure: bool,
        ///True in case of session cookie.
        #[serde(rename = "session")]
        pub session: bool,
        ///Cookie SameSite type.
        #[serde(rename = "sameSite")]
        pub same_site: Option<CookieSameSite>,
        ///Cookie Priority
        #[serde(rename = "priority")]
        pub priority: CookiePriority,
        ///True if cookie is SameParty.
        #[serde(rename = "sameParty")]
        pub same_party: bool,
        ///Cookie source scheme type.
        #[serde(rename = "sourceScheme")]
        pub source_scheme: CookieSourceScheme,
        ///Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
        ///An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
        ///This is a temporary ability and it will be removed in the future.
        #[serde(rename = "sourcePort")]
        pub source_port: i64,
        ///Cookie partition key. The site of the top-level URL the browser was visiting at the start
        ///of the request to the endpoint that set the cookie.
        #[serde(rename = "partitionKey")]
        pub partition_key: Option<String>,
        ///True if cookie partition key is opaque.
        #[serde(rename = "partitionKeyOpaque")]
        pub partition_key_opaque: Option<bool>,
    }
    ///Types of reasons why a cookie may not be stored from a response.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetCookieBlockedReason {
        #[serde(rename = "SecureOnly")]
        SecureOnly,
        #[serde(rename = "SameSiteStrict")]
        SameSiteStrict,
        #[serde(rename = "SameSiteLax")]
        SameSiteLax,
        #[serde(rename = "SameSiteUnspecifiedTreatedAsLax")]
        SameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "SameSiteNoneInsecure")]
        SameSiteNoneInsecure,
        #[serde(rename = "UserPreferences")]
        UserPreferences,
        #[serde(rename = "ThirdPartyBlockedInFirstPartySet")]
        ThirdPartyBlockedInFirstPartySet,
        #[serde(rename = "SyntaxError")]
        SyntaxError,
        #[serde(rename = "SchemeNotSupported")]
        SchemeNotSupported,
        #[serde(rename = "OverwriteSecure")]
        OverwriteSecure,
        #[serde(rename = "InvalidDomain")]
        InvalidDomain,
        #[serde(rename = "InvalidPrefix")]
        InvalidPrefix,
        #[serde(rename = "UnknownError")]
        UnknownError,
        #[serde(rename = "SchemefulSameSiteStrict")]
        SchemefulSameSiteStrict,
        #[serde(rename = "SchemefulSameSiteLax")]
        SchemefulSameSiteLax,
        #[serde(rename = "SchemefulSameSiteUnspecifiedTreatedAsLax")]
        SchemefulSameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "SamePartyFromCrossPartyContext")]
        SamePartyFromCrossPartyContext,
        #[serde(rename = "SamePartyConflictsWithOtherAttributes")]
        SamePartyConflictsWithOtherAttributes,
        #[serde(rename = "NameValuePairExceedsMaxSize")]
        NameValuePairExceedsMaxSize,
        #[serde(rename = "DisallowedCharacter")]
        DisallowedCharacter,
    }
    ///Types of reasons why a cookie may not be sent with a request.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CookieBlockedReason {
        #[serde(rename = "SecureOnly")]
        SecureOnly,
        #[serde(rename = "NotOnPath")]
        NotOnPath,
        #[serde(rename = "DomainMismatch")]
        DomainMismatch,
        #[serde(rename = "SameSiteStrict")]
        SameSiteStrict,
        #[serde(rename = "SameSiteLax")]
        SameSiteLax,
        #[serde(rename = "SameSiteUnspecifiedTreatedAsLax")]
        SameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "SameSiteNoneInsecure")]
        SameSiteNoneInsecure,
        #[serde(rename = "UserPreferences")]
        UserPreferences,
        #[serde(rename = "ThirdPartyBlockedInFirstPartySet")]
        ThirdPartyBlockedInFirstPartySet,
        #[serde(rename = "UnknownError")]
        UnknownError,
        #[serde(rename = "SchemefulSameSiteStrict")]
        SchemefulSameSiteStrict,
        #[serde(rename = "SchemefulSameSiteLax")]
        SchemefulSameSiteLax,
        #[serde(rename = "SchemefulSameSiteUnspecifiedTreatedAsLax")]
        SchemefulSameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "SamePartyFromCrossPartyContext")]
        SamePartyFromCrossPartyContext,
        #[serde(rename = "NameValuePairExceedsMaxSize")]
        NameValuePairExceedsMaxSize,
    }
    ///A cookie which was not stored from a response with the corresponding reason.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BlockedSetCookieWithReason {
        ///The reason(s) this cookie was blocked.
        #[serde(rename = "blockedReasons")]
        pub blocked_reasons: Vec<SetCookieBlockedReason>,
        ///The string representing this individual cookie as it would appear in the header.
        ///This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
        #[serde(rename = "cookieLine")]
        pub cookie_line: String,
        ///The cookie object which represents the cookie which was not stored. It is optional because
        ///sometimes complete cookie information is not available, such as in the case of parsing
        ///errors.
        #[serde(rename = "cookie")]
        pub cookie: Option<Cookie>,
    }
    ///A cookie with was not sent with a request with the corresponding reason.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BlockedCookieWithReason {
        ///The reason(s) the cookie was blocked.
        #[serde(rename = "blockedReasons")]
        pub blocked_reasons: Vec<CookieBlockedReason>,
        ///The cookie object representing the cookie which was not sent.
        #[serde(rename = "cookie")]
        pub cookie: Cookie,
    }
    ///Cookie parameter object
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CookieParam {
        ///Cookie name.
        #[serde(rename = "name")]
        pub name: String,
        ///Cookie value.
        #[serde(rename = "value")]
        pub value: String,
        ///The request-URI to associate with the setting of the cookie. This value can affect the
        ///default domain, path, source port, and source scheme values of the created cookie.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///Cookie domain.
        #[serde(rename = "domain")]
        pub domain: Option<String>,
        ///Cookie path.
        #[serde(rename = "path")]
        pub path: Option<String>,
        ///True if cookie is secure.
        #[serde(rename = "secure")]
        pub secure: Option<bool>,
        ///True if cookie is http-only.
        #[serde(rename = "httpOnly")]
        pub http_only: Option<bool>,
        ///Cookie SameSite type.
        #[serde(rename = "sameSite")]
        pub same_site: Option<CookieSameSite>,
        ///Cookie expiration date, session cookie if not set
        #[serde(rename = "expires")]
        pub expires: Option<TimeSinceEpoch>,
        ///Cookie Priority.
        #[serde(rename = "priority")]
        pub priority: Option<CookiePriority>,
        ///True if cookie is SameParty.
        #[serde(rename = "sameParty")]
        pub same_party: Option<bool>,
        ///Cookie source scheme type.
        #[serde(rename = "sourceScheme")]
        pub source_scheme: Option<CookieSourceScheme>,
        ///Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
        ///An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
        ///This is a temporary ability and it will be removed in the future.
        #[serde(rename = "sourcePort")]
        pub source_port: Option<i64>,
        ///Cookie partition key. The site of the top-level URL the browser was visiting at the start
        ///of the request to the endpoint that set the cookie.
        ///If not set, the cookie will be set as not partitioned.
        #[serde(rename = "partitionKey")]
        pub partition_key: Option<String>,
    }
    ///
    /// Enum for [AuthChallenge]'s `source`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AuthChallengeSource {
        #[serde(rename = "Server")]
        Server,
        #[serde(rename = "Proxy")]
        Proxy,
    }
    ///Authorization challenge for HTTP status code 401 or 407.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AuthChallenge {
        ///Source of the authentication challenge.
        #[serde(rename = "source")]
        pub source: Option<Option<AuthChallengeSource>>,
        ///Origin of the challenger.
        #[serde(rename = "origin")]
        pub origin: String,
        ///The authentication scheme used, such as basic or digest
        #[serde(rename = "scheme")]
        pub scheme: String,
        ///The realm of the challenge. May be empty.
        #[serde(rename = "realm")]
        pub realm: String,
    }
    ///
    /// Enum for [AuthChallengeResponse]'s `response`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AuthChallengeResponseResponse {
        #[serde(rename = "Default")]
        Default,
        #[serde(rename = "CancelAuth")]
        CancelAuth,
        #[serde(rename = "ProvideCredentials")]
        ProvideCredentials,
    }
    ///Response to an AuthChallenge.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AuthChallengeResponse {
        ///The decision on what to do in response to the authorization challenge.  Default means
        ///deferring to the default behavior of the net stack, which will likely either the Cancel
        ///authentication or display a popup dialog box.
        #[serde(rename = "response")]
        pub response: AuthChallengeResponseResponse,
        ///The username to provide, possibly empty. Should only be set if response is
        ///ProvideCredentials.
        #[serde(rename = "username")]
        pub username: Option<String>,
        ///The password to provide, possibly empty. Should only be set if response is
        ///ProvideCredentials.
        #[serde(rename = "password")]
        pub password: Option<String>,
    }
    ///Stages of the interception to begin intercepting. Request will intercept before the request is
    ///sent. Response will intercept after the response is received.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum InterceptionStage {
        #[serde(rename = "Request")]
        Request,
        #[serde(rename = "HeadersReceived")]
        HeadersReceived,
    }
    ///Request pattern for interception.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestPattern {
        ///Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
        ///backslash. Omitting is equivalent to `"*"`.
        #[serde(rename = "urlPattern")]
        pub url_pattern: Option<String>,
        ///If set, only requests for matching resource types will be intercepted.
        #[serde(rename = "resourceType")]
        pub resource_type: Option<ResourceType>,
        ///Stage at which to begin intercepting requests. Default is Request.
        #[serde(rename = "interceptionStage")]
        pub interception_stage: Option<InterceptionStage>,
    }
    ///Information about a signed exchange signature.
    ///https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignedExchangeSignature {
        ///Signed exchange signature label.
        #[serde(rename = "label")]
        pub label: String,
        ///The hex string of signed exchange signature.
        #[serde(rename = "signature")]
        pub signature: String,
        ///Signed exchange signature integrity.
        #[serde(rename = "integrity")]
        pub integrity: String,
        ///Signed exchange signature cert Url.
        #[serde(rename = "certUrl")]
        pub cert_url: Option<String>,
        ///The hex string of signed exchange signature cert sha256.
        #[serde(rename = "certSha256")]
        pub cert_sha_256: Option<String>,
        ///Signed exchange signature validity Url.
        #[serde(rename = "validityUrl")]
        pub validity_url: String,
        ///Signed exchange signature date.
        #[serde(rename = "date")]
        pub date: i64,
        ///Signed exchange signature expires.
        #[serde(rename = "expires")]
        pub expires: i64,
        ///The encoded certificates.
        #[serde(rename = "certificates")]
        pub certificates: Option<Vec<String>>,
    }
    ///Information about a signed exchange header.
    ///https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignedExchangeHeader {
        ///Signed exchange request URL.
        #[serde(rename = "requestUrl")]
        pub request_url: String,
        ///Signed exchange response code.
        #[serde(rename = "responseCode")]
        pub response_code: i64,
        ///Signed exchange response headers.
        #[serde(rename = "responseHeaders")]
        pub response_headers: Headers,
        ///Signed exchange response signature.
        #[serde(rename = "signatures")]
        pub signatures: Vec<SignedExchangeSignature>,
        ///Signed exchange header integrity hash in the form of `sha256-<base64-hash-value>`.
        #[serde(rename = "headerIntegrity")]
        pub header_integrity: String,
    }
    ///Field type for a signed exchange related error.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SignedExchangeErrorField {
        #[serde(rename = "signatureSig")]
        SignatureSig,
        #[serde(rename = "signatureIntegrity")]
        SignatureIntegrity,
        #[serde(rename = "signatureCertUrl")]
        SignatureCertUrl,
        #[serde(rename = "signatureCertSha256")]
        SignatureCertSha256,
        #[serde(rename = "signatureValidityUrl")]
        SignatureValidityUrl,
        #[serde(rename = "signatureTimestamps")]
        SignatureTimestamps,
    }
    ///Information about a signed exchange response.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignedExchangeError {
        ///Error message.
        #[serde(rename = "message")]
        pub message: String,
        ///The index of the signature which caused the error.
        #[serde(rename = "signatureIndex")]
        pub signature_index: Option<i64>,
        ///The field which caused the error.
        #[serde(rename = "errorField")]
        pub error_field: Option<SignedExchangeErrorField>,
    }
    ///Information about a signed exchange response.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignedExchangeInfo {
        ///The outer response of signed HTTP exchange which was received from network.
        #[serde(rename = "outerResponse")]
        pub outer_response: Response,
        ///Information about the signed exchange header.
        #[serde(rename = "header")]
        pub header: Option<SignedExchangeHeader>,
        ///Security details for the signed exchange header.
        #[serde(rename = "securityDetails")]
        pub security_details: Option<SecurityDetails>,
        ///Errors occurred while handling the signed exchagne.
        #[serde(rename = "errors")]
        pub errors: Option<Vec<SignedExchangeError>>,
    }
    ///List of content encodings supported by the backend.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ContentEncoding {
        #[serde(rename = "deflate")]
        Deflate,
        #[serde(rename = "gzip")]
        Gzip,
        #[serde(rename = "br")]
        Br,
        #[serde(rename = "zstd")]
        Zstd,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PrivateNetworkRequestPolicy {
        #[serde(rename = "Allow")]
        Allow,
        #[serde(rename = "BlockFromInsecureToMorePrivate")]
        BlockFromInsecureToMorePrivate,
        #[serde(rename = "WarnFromInsecureToMorePrivate")]
        WarnFromInsecureToMorePrivate,
        #[serde(rename = "PreflightBlock")]
        PreflightBlock,
        #[serde(rename = "PreflightWarn")]
        PreflightWarn,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum IpAddressSpace {
        #[serde(rename = "Local")]
        Local,
        #[serde(rename = "Private")]
        Private,
        #[serde(rename = "Public")]
        Public,
        #[serde(rename = "Unknown")]
        Unknown,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ConnectTiming {
        ///Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
        ///milliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for
        ///the same request (but not for redirected requests).
        #[serde(rename = "requestTime")]
        pub request_time: f64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClientSecurityState {
        #[serde(rename = "initiatorIsSecureContext")]
        pub initiator_is_secure_context: bool,
        #[serde(rename = "initiatorIPAddressSpace")]
        pub initiator_ip_address_space: IpAddressSpace,
        #[serde(rename = "privateNetworkRequestPolicy")]
        pub private_network_request_policy: PrivateNetworkRequestPolicy,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CrossOriginOpenerPolicyValue {
        #[serde(rename = "SameOrigin")]
        SameOrigin,
        #[serde(rename = "SameOriginAllowPopups")]
        SameOriginAllowPopups,
        #[serde(rename = "RestrictProperties")]
        RestrictProperties,
        #[serde(rename = "UnsafeNone")]
        UnsafeNone,
        #[serde(rename = "SameOriginPlusCoep")]
        SameOriginPlusCoep,
        #[serde(rename = "RestrictPropertiesPlusCoep")]
        RestrictPropertiesPlusCoep,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CrossOriginOpenerPolicyStatus {
        #[serde(rename = "value")]
        pub value: CrossOriginOpenerPolicyValue,
        #[serde(rename = "reportOnlyValue")]
        pub report_only_value: CrossOriginOpenerPolicyValue,
        #[serde(rename = "reportingEndpoint")]
        pub reporting_endpoint: Option<String>,
        #[serde(rename = "reportOnlyReportingEndpoint")]
        pub report_only_reporting_endpoint: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CrossOriginEmbedderPolicyValue {
        #[serde(rename = "None")]
        None,
        #[serde(rename = "Credentialless")]
        Credentialless,
        #[serde(rename = "RequireCorp")]
        RequireCorp,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CrossOriginEmbedderPolicyStatus {
        #[serde(rename = "value")]
        pub value: CrossOriginEmbedderPolicyValue,
        #[serde(rename = "reportOnlyValue")]
        pub report_only_value: CrossOriginEmbedderPolicyValue,
        #[serde(rename = "reportingEndpoint")]
        pub reporting_endpoint: Option<String>,
        #[serde(rename = "reportOnlyReportingEndpoint")]
        pub report_only_reporting_endpoint: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ContentSecurityPolicySource {
        #[serde(rename = "HTTP")]
        Http,
        #[serde(rename = "Meta")]
        Meta,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContentSecurityPolicyStatus {
        #[serde(rename = "effectiveDirectives")]
        pub effective_directives: String,
        #[serde(rename = "isEnforced")]
        pub is_enforced: bool,
        #[serde(rename = "source")]
        pub source: ContentSecurityPolicySource,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SecurityIsolationStatus {
        #[serde(rename = "coop")]
        pub coop: Option<CrossOriginOpenerPolicyStatus>,
        #[serde(rename = "coep")]
        pub coep: Option<CrossOriginEmbedderPolicyStatus>,
        #[serde(rename = "csp")]
        pub csp: Option<Vec<ContentSecurityPolicyStatus>>,
    }
    ///The status of a Reporting API report.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ReportStatus {
        #[serde(rename = "Queued")]
        Queued,
        #[serde(rename = "Pending")]
        Pending,
        #[serde(rename = "MarkedForRemoval")]
        MarkedForRemoval,
        #[serde(rename = "Success")]
        Success,
    }
    pub type ReportId = String;
    ///An object representing a report generated by the Reporting API.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReportingApiReport {
        #[serde(rename = "id")]
        pub id: ReportId,
        ///The URL of the document that triggered the report.
        #[serde(rename = "initiatorUrl")]
        pub initiator_url: String,
        ///The name of the endpoint group that should be used to deliver the report.
        #[serde(rename = "destination")]
        pub destination: String,
        ///The type of the report (specifies the set of data that is contained in the report body).
        #[serde(rename = "type")]
        pub type_: String,
        ///When the report was generated.
        #[serde(rename = "timestamp")]
        pub timestamp: crate::protocol_test::network::TimeSinceEpoch,
        ///How many uploads deep the related request was.
        #[serde(rename = "depth")]
        pub depth: i64,
        ///The number of delivery attempts made so far, not including an active attempt.
        #[serde(rename = "completedAttempts")]
        pub completed_attempts: i64,
        #[serde(rename = "body")]
        pub body: serde_json::Map<String, serde_json::Value>,
        #[serde(rename = "status")]
        pub status: ReportStatus,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReportingApiEndpoint {
        ///The URL of the endpoint to which reports may be delivered.
        #[serde(rename = "url")]
        pub url: String,
        ///Name of the endpoint group.
        #[serde(rename = "groupName")]
        pub group_name: String,
    }
    ///An object providing the result of a network resource load.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadNetworkResourcePageResult {
        #[serde(rename = "success")]
        pub success: bool,
        ///Optional values used for error reporting.
        #[serde(rename = "netError")]
        pub net_error: Option<f64>,
        #[serde(rename = "netErrorName")]
        pub net_error_name: Option<String>,
        #[serde(rename = "httpStatusCode")]
        pub http_status_code: Option<f64>,
        ///If successful, one of the following two fields holds the result.
        #[serde(rename = "stream")]
        pub stream: Option<crate::protocol_test::io::StreamHandle>,
        ///Response headers.
        #[serde(rename = "headers")]
        pub headers: Option<crate::protocol_test::network::Headers>,
    }
    ///An options object that may be extended later to better support CORS,
    ///CORB and streaming.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadNetworkResourceOptions {
        #[serde(rename = "disableCache")]
        pub disable_cache: bool,
        #[serde(rename = "includeCredentials")]
        pub include_credentials: bool,
    }
    ///
    /// Parameter value for [SetAcceptedEncodings].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAcceptedEncodingsParams {
        ///List of accepted content encodings.
        #[serde(rename = "encodings")]
        pub encodings: Vec<ContentEncoding>,
    }
    ///Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
    ///---
    ///Parameter Type: [SetAcceptedEncodingsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAcceptedEncodings;
    impl crate::util::Command for SetAcceptedEncodings {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAcceptedEncodings"
        }
    }
    ///Clears accepted encodings set by setAcceptedEncodings
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearAcceptedEncodingsOverride;
    impl crate::util::Command for ClearAcceptedEncodingsOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearAcceptedEncodingsOverride"
        }
    }
    ///
    /// Return value for [CanClearBrowserCache].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CanClearBrowserCacheReturns {
        ///True if browser cache can be cleared.
        #[serde(rename = "result")]
        pub result: bool,
    }
    ///Tells whether clearing browser cache is supported.
    ///---
    ///Return Type: [CanClearBrowserCacheReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CanClearBrowserCache;
    impl crate::util::Command for CanClearBrowserCache {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "canClearBrowserCache"
        }
    }
    ///
    /// Return value for [CanClearBrowserCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CanClearBrowserCookiesReturns {
        ///True if browser cookies can be cleared.
        #[serde(rename = "result")]
        pub result: bool,
    }
    ///Tells whether clearing browser cookies is supported.
    ///---
    ///Return Type: [CanClearBrowserCookiesReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CanClearBrowserCookies;
    impl crate::util::Command for CanClearBrowserCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "canClearBrowserCookies"
        }
    }
    ///
    /// Return value for [CanEmulateNetworkConditions].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CanEmulateNetworkConditionsReturns {
        ///True if emulation of network conditions is supported.
        #[serde(rename = "result")]
        pub result: bool,
    }
    ///Tells whether emulation of network conditions is supported.
    ///---
    ///Return Type: [CanEmulateNetworkConditionsReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CanEmulateNetworkConditions;
    impl crate::util::Command for CanEmulateNetworkConditions {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "canEmulateNetworkConditions"
        }
    }
    ///Clears browser cache.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearBrowserCache;
    impl crate::util::Command for ClearBrowserCache {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearBrowserCache"
        }
    }
    ///Clears browser cookies.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearBrowserCookies;
    impl crate::util::Command for ClearBrowserCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearBrowserCookies"
        }
    }
    ///
    /// Parameter value for [ContinueInterceptedRequest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueInterceptedRequestParams {
        #[serde(rename = "interceptionId")]
        pub interception_id: InterceptionId,
        ///If set this causes the request to fail with the given reason. Passing `Aborted` for requests
        ///marked with `isNavigationRequest` also cancels the navigation. Must not be set in response
        ///to an authChallenge.
        #[serde(rename = "errorReason")]
        pub error_reason: Option<ErrorReason>,
        ///If set the requests completes using with the provided base64 encoded raw response, including
        ///HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "rawResponse")]
        pub raw_response: Option<String>,
        ///If set the request url will be modified in a way that's not observable by page. Must not be
        ///set in response to an authChallenge.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///If set this allows the request method to be overridden. Must not be set in response to an
        ///authChallenge.
        #[serde(rename = "method")]
        pub method: Option<String>,
        ///If set this allows postData to be set. Must not be set in response to an authChallenge.
        #[serde(rename = "postData")]
        pub post_data: Option<String>,
        ///If set this allows the request headers to be changed. Must not be set in response to an
        ///authChallenge.
        #[serde(rename = "headers")]
        pub headers: Option<Headers>,
        ///Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
        #[serde(rename = "authChallengeResponse")]
        pub auth_challenge_response: Option<AuthChallengeResponse>,
    }
    ///Response to Network.requestIntercepted which either modifies the request to continue with any
    ///modifications, or blocks it, or completes it with the provided response bytes. If a network
    ///fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
    ///event will be sent with the same InterceptionId.
    ///Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
    ///---
    ///Parameter Type: [ContinueInterceptedRequestParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueInterceptedRequest;
    impl crate::util::Command for ContinueInterceptedRequest {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "continueInterceptedRequest"
        }
    }
    ///
    /// Parameter value for [DeleteCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteCookiesParams {
        ///Name of the cookies to remove.
        #[serde(rename = "name")]
        pub name: String,
        ///If specified, deletes all the cookies with the given name where domain and path match
        ///provided URL.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///If specified, deletes only cookies with the exact domain.
        #[serde(rename = "domain")]
        pub domain: Option<String>,
        ///If specified, deletes only cookies with the exact path.
        #[serde(rename = "path")]
        pub path: Option<String>,
    }
    ///Deletes browser cookies with matching name and url or domain/path pair.
    ///---
    ///Parameter Type: [DeleteCookiesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteCookies;
    impl crate::util::Command for DeleteCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deleteCookies"
        }
    }
    ///Disables network tracking, prevents network events from being sent to the client.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [EmulateNetworkConditions].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EmulateNetworkConditionsParams {
        ///True to emulate internet disconnection.
        #[serde(rename = "offline")]
        pub offline: bool,
        ///Minimum latency from request sent to response headers received (ms).
        #[serde(rename = "latency")]
        pub latency: f64,
        ///Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
        #[serde(rename = "downloadThroughput")]
        pub download_throughput: f64,
        ///Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
        #[serde(rename = "uploadThroughput")]
        pub upload_throughput: f64,
        ///Connection type if known.
        #[serde(rename = "connectionType")]
        pub connection_type: Option<ConnectionType>,
    }
    ///Activates emulation of network conditions.
    ///---
    ///Parameter Type: [EmulateNetworkConditionsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EmulateNetworkConditions;
    impl crate::util::Command for EmulateNetworkConditions {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "emulateNetworkConditions"
        }
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        ///Buffer size in bytes to use when preserving network payloads (XHRs, etc).
        #[serde(rename = "maxTotalBufferSize")]
        pub max_total_buffer_size: Option<i64>,
        ///Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
        #[serde(rename = "maxResourceBufferSize")]
        pub max_resource_buffer_size: Option<i64>,
        ///Longest post body size (in bytes) that would be included in requestWillBeSent notification
        #[serde(rename = "maxPostDataSize")]
        pub max_post_data_size: Option<i64>,
    }
    ///Enables network tracking, network events will now be delivered to the client.
    ///---
    ///Parameter Type: [EnableParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Return value for [GetAllCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAllCookiesReturns {
        ///Array of cookie objects.
        #[serde(rename = "cookies")]
        pub cookies: Vec<Cookie>,
    }
    ///Returns all browser cookies. Depending on the backend support, will return detailed cookie
    ///information in the `cookies` field.
    ///Deprecated. Use Storage.getCookies instead.
    ///---
    ///Return Type: [GetAllCookiesReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAllCookies;
    impl crate::util::Command for GetAllCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getAllCookies"
        }
    }
    ///
    /// Parameter value for [GetCertificate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCertificateParams {
        ///Origin to get certificate for.
        #[serde(rename = "origin")]
        pub origin: String,
    }
    ///
    /// Return value for [GetCertificate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCertificateReturns {
        #[serde(rename = "tableNames")]
        pub table_names: Vec<String>,
    }
    ///Returns the DER-encoded certificate.
    ///---
    ///Parameter Type: [GetCertificateParams]
    ///Return Type: [GetCertificateReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCertificate;
    impl crate::util::Command for GetCertificate {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getCertificate"
        }
    }
    ///
    /// Parameter value for [GetCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCookiesParams {
        ///The list of URLs for which applicable cookies will be fetched.
        ///If not specified, it's assumed to be set to the list containing
        ///the URLs of the page and all of its subframes.
        #[serde(rename = "urls")]
        pub urls: Option<Vec<String>>,
    }
    ///
    /// Return value for [GetCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCookiesReturns {
        ///Array of cookie objects.
        #[serde(rename = "cookies")]
        pub cookies: Vec<Cookie>,
    }
    ///Returns all browser cookies for the current URL. Depending on the backend support, will return
    ///detailed cookie information in the `cookies` field.
    ///---
    ///Parameter Type: [GetCookiesParams]
    ///Return Type: [GetCookiesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCookies;
    impl crate::util::Command for GetCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getCookies"
        }
    }
    ///
    /// Parameter value for [GetResponseBody].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBodyParams {
        ///Identifier of the network request to get content for.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
    }
    ///
    /// Return value for [GetResponseBody].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBodyReturns {
        ///Response body.
        #[serde(rename = "body")]
        pub body: String,
        ///True, if content was sent as base64.
        #[serde(rename = "base64Encoded")]
        pub base_64_encoded: bool,
    }
    ///Returns content served for the given request.
    ///---
    ///Parameter Type: [GetResponseBodyParams]
    ///Return Type: [GetResponseBodyReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBody;
    impl crate::util::Command for GetResponseBody {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getResponseBody"
        }
    }
    ///
    /// Parameter value for [GetRequestPostData].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRequestPostDataParams {
        ///Identifier of the network request to get content for.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
    }
    ///
    /// Return value for [GetRequestPostData].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRequestPostDataReturns {
        ///Request body string, omitting files from multipart requests
        #[serde(rename = "postData")]
        pub post_data: String,
    }
    ///Returns post data sent with the request. Returns an error when no data was sent with the request.
    ///---
    ///Parameter Type: [GetRequestPostDataParams]
    ///Return Type: [GetRequestPostDataReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRequestPostData;
    impl crate::util::Command for GetRequestPostData {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getRequestPostData"
        }
    }
    ///
    /// Parameter value for [GetResponseBodyForInterception].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBodyForInterceptionParams {
        ///Identifier for the intercepted request to get body for.
        #[serde(rename = "interceptionId")]
        pub interception_id: InterceptionId,
    }
    ///
    /// Return value for [GetResponseBodyForInterception].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBodyForInterceptionReturns {
        ///Response body.
        #[serde(rename = "body")]
        pub body: String,
        ///True, if content was sent as base64.
        #[serde(rename = "base64Encoded")]
        pub base_64_encoded: bool,
    }
    ///Returns content served for the given currently intercepted request.
    ///---
    ///Parameter Type: [GetResponseBodyForInterceptionParams]
    ///Return Type: [GetResponseBodyForInterceptionReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBodyForInterception;
    impl crate::util::Command for GetResponseBodyForInterception {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getResponseBodyForInterception"
        }
    }
    ///
    /// Parameter value for [TakeResponseBodyForInterceptionAsStream].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeResponseBodyForInterceptionAsStreamParams {
        #[serde(rename = "interceptionId")]
        pub interception_id: InterceptionId,
    }
    ///
    /// Return value for [TakeResponseBodyForInterceptionAsStream].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeResponseBodyForInterceptionAsStreamReturns {
        #[serde(rename = "stream")]
        pub stream: crate::protocol_test::io::StreamHandle,
    }
    ///Returns a handle to the stream representing the response body. Note that after this command,
    ///the intercepted request can't be continued as is -- you either need to cancel it or to provide
    ///the response body. The stream only supports sequential read, IO.read will fail if the position
    ///is specified.
    ///---
    ///Parameter Type: [TakeResponseBodyForInterceptionAsStreamParams]
    ///Return Type: [TakeResponseBodyForInterceptionAsStreamReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeResponseBodyForInterceptionAsStream;
    impl crate::util::Command for TakeResponseBodyForInterceptionAsStream {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "takeResponseBodyForInterceptionAsStream"
        }
    }
    ///
    /// Parameter value for [ReplayXhr].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReplayXhrParams {
        ///Identifier of XHR to replay.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
    }
    ///This method sends a new XMLHttpRequest which is identical to the original one. The following
    ///parameters should be identical: method, url, async, request body, extra headers, withCredentials
    ///attribute, user, password.
    ///---
    ///Parameter Type: [ReplayXhrParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReplayXhr;
    impl crate::util::Command for ReplayXhr {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "replayXHR"
        }
    }
    ///
    /// Parameter value for [SearchInResponseBody].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInResponseBodyParams {
        ///Identifier of the network response to search.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///String to search for.
        #[serde(rename = "query")]
        pub query: String,
        ///If true, search is case sensitive.
        #[serde(rename = "caseSensitive")]
        pub case_sensitive: Option<bool>,
        ///If true, treats string parameter as regex.
        #[serde(rename = "isRegex")]
        pub is_regex: Option<bool>,
    }
    ///
    /// Return value for [SearchInResponseBody].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInResponseBodyReturns {
        ///List of search matches.
        #[serde(rename = "result")]
        pub result: Vec<crate::protocol_test::debugger::SearchMatch>,
    }
    ///Searches for given string in response content.
    ///---
    ///Parameter Type: [SearchInResponseBodyParams]
    ///Return Type: [SearchInResponseBodyReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInResponseBody;
    impl crate::util::Command for SearchInResponseBody {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "searchInResponseBody"
        }
    }
    ///
    /// Parameter value for [SetBlockedUrLs].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBlockedUrLsParams {
        ///URL patterns to block. Wildcards ('*') are allowed.
        #[serde(rename = "urls")]
        pub urls: Vec<String>,
    }
    ///Blocks URLs from loading.
    ///---
    ///Parameter Type: [SetBlockedUrLsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBlockedUrLs;
    impl crate::util::Command for SetBlockedUrLs {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBlockedURLs"
        }
    }
    ///
    /// Parameter value for [SetBypassServiceWorker].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBypassServiceWorkerParams {
        ///Bypass service worker and load from network.
        #[serde(rename = "bypass")]
        pub bypass: bool,
    }
    ///Toggles ignoring of service worker for each request.
    ///---
    ///Parameter Type: [SetBypassServiceWorkerParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBypassServiceWorker;
    impl crate::util::Command for SetBypassServiceWorker {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBypassServiceWorker"
        }
    }
    ///
    /// Parameter value for [SetCacheDisabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCacheDisabledParams {
        ///Cache disabled state.
        #[serde(rename = "cacheDisabled")]
        pub cache_disabled: bool,
    }
    ///Toggles ignoring cache for each request. If `true`, cache will not be used.
    ///---
    ///Parameter Type: [SetCacheDisabledParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCacheDisabled;
    impl crate::util::Command for SetCacheDisabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setCacheDisabled"
        }
    }
    ///
    /// Parameter value for [SetCookie].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCookieParams {
        ///Cookie name.
        #[serde(rename = "name")]
        pub name: String,
        ///Cookie value.
        #[serde(rename = "value")]
        pub value: String,
        ///The request-URI to associate with the setting of the cookie. This value can affect the
        ///default domain, path, source port, and source scheme values of the created cookie.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///Cookie domain.
        #[serde(rename = "domain")]
        pub domain: Option<String>,
        ///Cookie path.
        #[serde(rename = "path")]
        pub path: Option<String>,
        ///True if cookie is secure.
        #[serde(rename = "secure")]
        pub secure: Option<bool>,
        ///True if cookie is http-only.
        #[serde(rename = "httpOnly")]
        pub http_only: Option<bool>,
        ///Cookie SameSite type.
        #[serde(rename = "sameSite")]
        pub same_site: Option<CookieSameSite>,
        ///Cookie expiration date, session cookie if not set
        #[serde(rename = "expires")]
        pub expires: Option<TimeSinceEpoch>,
        ///Cookie Priority type.
        #[serde(rename = "priority")]
        pub priority: Option<CookiePriority>,
        ///True if cookie is SameParty.
        #[serde(rename = "sameParty")]
        pub same_party: Option<bool>,
        ///Cookie source scheme type.
        #[serde(rename = "sourceScheme")]
        pub source_scheme: Option<CookieSourceScheme>,
        ///Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
        ///An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
        ///This is a temporary ability and it will be removed in the future.
        #[serde(rename = "sourcePort")]
        pub source_port: Option<i64>,
        ///Cookie partition key. The site of the top-level URL the browser was visiting at the start
        ///of the request to the endpoint that set the cookie.
        ///If not set, the cookie will be set as not partitioned.
        #[serde(rename = "partitionKey")]
        pub partition_key: Option<String>,
    }
    ///
    /// Return value for [SetCookie].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCookieReturns {
        ///Always set to true. If an error occurs, the response indicates protocol error.
        #[deprecated]
        #[serde(rename = "success")]
        pub success: bool,
    }
    ///Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
    ///---
    ///Parameter Type: [SetCookieParams]
    ///Return Type: [SetCookieReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCookie;
    impl crate::util::Command for SetCookie {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setCookie"
        }
    }
    ///
    /// Parameter value for [SetCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCookiesParams {
        ///Cookies to be set.
        #[serde(rename = "cookies")]
        pub cookies: Vec<CookieParam>,
    }
    ///Sets given cookies.
    ///---
    ///Parameter Type: [SetCookiesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCookies;
    impl crate::util::Command for SetCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setCookies"
        }
    }
    ///
    /// Parameter value for [SetExtraHttpHeaders].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetExtraHttpHeadersParams {
        ///Map with extra HTTP headers.
        #[serde(rename = "headers")]
        pub headers: Headers,
    }
    ///Specifies whether to always send extra HTTP headers with the requests from this page.
    ///---
    ///Parameter Type: [SetExtraHttpHeadersParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetExtraHttpHeaders;
    impl crate::util::Command for SetExtraHttpHeaders {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setExtraHTTPHeaders"
        }
    }
    ///
    /// Parameter value for [SetAttachDebugStack].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttachDebugStackParams {
        ///Whether to attach a page script stack for debugging purpose.
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Specifies whether to attach a page script stack id in requests
    ///---
    ///Parameter Type: [SetAttachDebugStackParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttachDebugStack;
    impl crate::util::Command for SetAttachDebugStack {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAttachDebugStack"
        }
    }
    ///
    /// Parameter value for [SetRequestInterception].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRequestInterceptionParams {
        ///Requests matching any of these patterns will be forwarded and wait for the corresponding
        ///continueInterceptedRequest call.
        #[serde(rename = "patterns")]
        pub patterns: Vec<RequestPattern>,
    }
    ///Sets the requests to intercept that match the provided patterns and optionally resource types.
    ///Deprecated, please use Fetch.enable instead.
    ///---
    ///Parameter Type: [SetRequestInterceptionParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRequestInterception;
    impl crate::util::Command for SetRequestInterception {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setRequestInterception"
        }
    }
    ///
    /// Parameter value for [SetUserAgentOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetUserAgentOverrideParams {
        ///User agent to use.
        #[serde(rename = "userAgent")]
        pub user_agent: String,
        ///Browser langugage to emulate.
        #[serde(rename = "acceptLanguage")]
        pub accept_language: Option<String>,
        ///The platform navigator.platform should return.
        #[serde(rename = "platform")]
        pub platform: Option<String>,
        ///To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
        #[serde(rename = "userAgentMetadata")]
        pub user_agent_metadata: Option<
            crate::protocol_test::emulation::UserAgentMetadata,
        >,
    }
    ///Allows overriding user agent with the given string.
    ///---
    ///Parameter Type: [SetUserAgentOverrideParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetUserAgentOverride;
    impl crate::util::Command for SetUserAgentOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setUserAgentOverride"
        }
    }
    ///
    /// Parameter value for [GetSecurityIsolationStatus].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSecurityIsolationStatusParams {
        ///If no frameId is provided, the status of the target is provided.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
    }
    ///
    /// Return value for [GetSecurityIsolationStatus].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSecurityIsolationStatusReturns {
        #[serde(rename = "status")]
        pub status: SecurityIsolationStatus,
    }
    ///Returns information about the COEP/COOP isolation status.
    ///---
    ///Parameter Type: [GetSecurityIsolationStatusParams]
    ///Return Type: [GetSecurityIsolationStatusReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSecurityIsolationStatus;
    impl crate::util::Command for GetSecurityIsolationStatus {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getSecurityIsolationStatus"
        }
    }
    ///
    /// Parameter value for [EnableReportingApi].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableReportingApiParams {
        ///Whether to enable or disable events for the Reporting API
        #[serde(rename = "enable")]
        pub enable: bool,
    }
    ///Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
    ///Enabling triggers 'reportingApiReportAdded' for all existing reports.
    ///---
    ///Parameter Type: [EnableReportingApiParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableReportingApi;
    impl crate::util::Command for EnableReportingApi {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enableReportingApi"
        }
    }
    ///
    /// Parameter value for [LoadNetworkResource].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadNetworkResourceParams {
        ///Frame id to get the resource for. Mandatory for frame targets, and
        ///should be omitted for worker targets.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
        ///URL of the resource to get content for.
        #[serde(rename = "url")]
        pub url: String,
        ///Options for the request.
        #[serde(rename = "options")]
        pub options: LoadNetworkResourceOptions,
    }
    ///
    /// Return value for [LoadNetworkResource].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadNetworkResourceReturns {
        #[serde(rename = "resource")]
        pub resource: LoadNetworkResourcePageResult,
    }
    ///Fetches the resource and returns the content.
    ///---
    ///Parameter Type: [LoadNetworkResourceParams]
    ///Return Type: [LoadNetworkResourceReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadNetworkResource;
    impl crate::util::Command for LoadNetworkResource {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "loadNetworkResource"
        }
    }
    ///Fired when data chunk was received over the network.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DataReceivedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///Data chunk length.
        #[serde(rename = "dataLength")]
        pub data_length: i64,
        ///Actual bytes received (might be less than dataLength for compressed encodings).
        #[serde(rename = "encodedDataLength")]
        pub encoded_data_length: i64,
    }
    ///Fired when EventSource message is received.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EventSourceMessageReceivedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///Message type.
        #[serde(rename = "eventName")]
        pub event_name: String,
        ///Message identifier.
        #[serde(rename = "eventId")]
        pub event_id: String,
        ///Message content.
        #[serde(rename = "data")]
        pub data: String,
    }
    ///Fired when HTTP request has failed to load.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadingFailedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///Resource type.
        #[serde(rename = "type")]
        pub type_: ResourceType,
        ///User friendly error message.
        #[serde(rename = "errorText")]
        pub error_text: String,
        ///True if loading was canceled.
        #[serde(rename = "canceled")]
        pub canceled: Option<bool>,
        ///The reason why loading was blocked, if any.
        #[serde(rename = "blockedReason")]
        pub blocked_reason: Option<BlockedReason>,
        ///The reason why loading was blocked by CORS, if any.
        #[serde(rename = "corsErrorStatus")]
        pub cors_error_status: Option<CorsErrorStatus>,
    }
    ///Fired when HTTP request has finished loading.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadingFinishedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///Total number of bytes received for this request.
        #[serde(rename = "encodedDataLength")]
        pub encoded_data_length: f64,
    }
    ///Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    ///mocked.
    ///Deprecated, use Fetch.requestPaused instead.
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestInterceptedEvent {
        ///Each request the page makes will have a unique id, however if any redirects are encountered
        ///while processing that fetch, they will be reported with the same id as the original fetch.
        ///Likewise if HTTP authentication is needed then the same fetch id will be used.
        #[serde(rename = "interceptionId")]
        pub interception_id: InterceptionId,
        #[serde(rename = "request")]
        pub request: Request,
        ///The id of the frame that initiated the request.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        ///How the requested resource will be used.
        #[serde(rename = "resourceType")]
        pub resource_type: ResourceType,
        ///Whether this is a navigation request, which can abort the navigation completely.
        #[serde(rename = "isNavigationRequest")]
        pub is_navigation_request: bool,
        ///Set if the request is a navigation that will result in a download.
        ///Only present after response is received from the server (i.e. HeadersReceived stage).
        #[serde(rename = "isDownload")]
        pub is_download: Option<bool>,
        ///Redirect location, only sent if a redirect was intercepted.
        #[serde(rename = "redirectUrl")]
        pub redirect_url: Option<String>,
        ///Details of the Authorization Challenge encountered. If this is set then
        ///continueInterceptedRequest must contain an authChallengeResponse.
        #[serde(rename = "authChallenge")]
        pub auth_challenge: Option<AuthChallenge>,
        ///Response error if intercepted at response stage or if redirect occurred while intercepting
        ///request.
        #[serde(rename = "responseErrorReason")]
        pub response_error_reason: Option<ErrorReason>,
        ///Response code if intercepted at response stage or if redirect occurred while intercepting
        ///request or auth retry occurred.
        #[serde(rename = "responseStatusCode")]
        pub response_status_code: Option<i64>,
        ///Response headers if intercepted at the response stage or if redirect occurred while
        ///intercepting request or auth retry occurred.
        #[serde(rename = "responseHeaders")]
        pub response_headers: Option<Headers>,
        ///If the intercepted request had a corresponding requestWillBeSent event fired for it, then
        ///this requestId will be the same as the requestId present in the requestWillBeSent event.
        #[serde(rename = "requestId")]
        pub request_id: Option<RequestId>,
    }
    ///Fired if request ended up loading from cache.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestServedFromCacheEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
    }
    ///Fired when page is about to send HTTP request.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestWillBeSentEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Loader identifier. Empty string if the request is fetched from worker.
        #[serde(rename = "loaderId")]
        pub loader_id: LoaderId,
        ///URL of the document this request is loaded for.
        #[serde(rename = "documentURL")]
        pub document_url: String,
        ///Request data.
        #[serde(rename = "request")]
        pub request: Request,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///Timestamp.
        #[serde(rename = "wallTime")]
        pub wall_time: TimeSinceEpoch,
        ///Request initiator.
        #[serde(rename = "initiator")]
        pub initiator: Initiator,
        ///In the case that redirectResponse is populated, this flag indicates whether
        ///requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted
        ///for the request which was just redirected.
        #[serde(rename = "redirectHasExtraInfo")]
        pub redirect_has_extra_info: bool,
        ///Redirect response data.
        #[serde(rename = "redirectResponse")]
        pub redirect_response: Option<Response>,
        ///Type of this resource.
        #[serde(rename = "type")]
        pub type_: Option<ResourceType>,
        ///Frame identifier.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
        ///Whether the request is initiated by a user gesture. Defaults to false.
        #[serde(rename = "hasUserGesture")]
        pub has_user_gesture: Option<bool>,
    }
    ///Fired when resource loading priority is changed
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResourceChangedPriorityEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///New priority
        #[serde(rename = "newPriority")]
        pub new_priority: ResourcePriority,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
    }
    ///Fired when a signed exchange was received over the network
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignedExchangeReceivedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Information about the signed exchange response.
        #[serde(rename = "info")]
        pub info: SignedExchangeInfo,
    }
    ///Fired when HTTP response is available.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResponseReceivedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Loader identifier. Empty string if the request is fetched from worker.
        #[serde(rename = "loaderId")]
        pub loader_id: LoaderId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///Resource type.
        #[serde(rename = "type")]
        pub type_: ResourceType,
        ///Response data.
        #[serde(rename = "response")]
        pub response: Response,
        ///Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be
        ///or were emitted for this request.
        #[serde(rename = "hasExtraInfo")]
        pub has_extra_info: bool,
        ///Frame identifier.
        #[serde(rename = "frameId")]
        pub frame_id: Option<crate::protocol_test::page::FrameId>,
    }
    ///Fired when WebSocket is closed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketClosedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
    }
    ///Fired upon WebSocket creation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketCreatedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///WebSocket request URL.
        #[serde(rename = "url")]
        pub url: String,
        ///Request initiator.
        #[serde(rename = "initiator")]
        pub initiator: Option<Initiator>,
    }
    ///Fired when WebSocket message error occurs.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketFrameErrorEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///WebSocket error message.
        #[serde(rename = "errorMessage")]
        pub error_message: String,
    }
    ///Fired when WebSocket message is received.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketFrameReceivedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///WebSocket response data.
        #[serde(rename = "response")]
        pub response: WebSocketFrame,
    }
    ///Fired when WebSocket message is sent.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketFrameSentEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///WebSocket response data.
        #[serde(rename = "response")]
        pub response: WebSocketFrame,
    }
    ///Fired when WebSocket handshake response becomes available.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketHandshakeResponseReceivedEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///WebSocket response data.
        #[serde(rename = "response")]
        pub response: WebSocketResponse,
    }
    ///Fired when WebSocket is about to initiate handshake.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebSocketWillSendHandshakeRequestEvent {
        ///Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///UTC Timestamp.
        #[serde(rename = "wallTime")]
        pub wall_time: TimeSinceEpoch,
        ///WebSocket request data.
        #[serde(rename = "request")]
        pub request: WebSocketRequest,
    }
    ///Fired upon WebTransport creation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebTransportCreatedEvent {
        ///WebTransport identifier.
        #[serde(rename = "transportId")]
        pub transport_id: RequestId,
        ///WebTransport request URL.
        #[serde(rename = "url")]
        pub url: String,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
        ///Request initiator.
        #[serde(rename = "initiator")]
        pub initiator: Option<Initiator>,
    }
    ///Fired when WebTransport handshake is finished.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebTransportConnectionEstablishedEvent {
        ///WebTransport identifier.
        #[serde(rename = "transportId")]
        pub transport_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
    }
    ///Fired when WebTransport is disposed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WebTransportClosedEvent {
        ///WebTransport identifier.
        #[serde(rename = "transportId")]
        pub transport_id: RequestId,
        ///Timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: MonotonicTime,
    }
    ///Fired when additional information about a requestWillBeSent event is available from the
    ///network stack. Not every requestWillBeSent event will have an additional
    ///requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
    ///or requestWillBeSentExtraInfo will be fired first for the same request.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestWillBeSentExtraInfoEvent {
        ///Request identifier. Used to match this information to an existing requestWillBeSent event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///A list of cookies potentially associated to the requested URL. This includes both cookies sent with
        ///the request and the ones not sent; the latter are distinguished by having blockedReason field set.
        #[serde(rename = "associatedCookies")]
        pub associated_cookies: Vec<BlockedCookieWithReason>,
        ///Raw request headers as they will be sent over the wire.
        #[serde(rename = "headers")]
        pub headers: Headers,
        ///Connection timing information for the request.
        #[serde(rename = "connectTiming")]
        pub connect_timing: ConnectTiming,
        ///The client security state set for the request.
        #[serde(rename = "clientSecurityState")]
        pub client_security_state: Option<ClientSecurityState>,
        ///Whether the site has partitioned cookies stored in a partition different than the current one.
        #[serde(rename = "siteHasCookieInOtherPartition")]
        pub site_has_cookie_in_other_partition: Option<bool>,
    }
    ///Fired when additional information about a responseReceived event is available from the network
    ///stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
    ///it, and responseReceivedExtraInfo may be fired before or after responseReceived.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResponseReceivedExtraInfoEvent {
        ///Request identifier. Used to match this information to another responseReceived event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///A list of cookies which were not stored from the response along with the corresponding
        ///reasons for blocking. The cookies here may not be valid due to syntax errors, which
        ///are represented by the invalid cookie line string instead of a proper cookie.
        #[serde(rename = "blockedCookies")]
        pub blocked_cookies: Vec<BlockedSetCookieWithReason>,
        ///Raw response headers as they were received over the wire.
        #[serde(rename = "headers")]
        pub headers: Headers,
        ///The IP address space of the resource. The address space can only be determined once the transport
        ///established the connection, so we can't send it in `requestWillBeSentExtraInfo`.
        #[serde(rename = "resourceIPAddressSpace")]
        pub resource_ip_address_space: IpAddressSpace,
        ///The status code of the response. This is useful in cases the request failed and no responseReceived
        ///event is triggered, which is the case for, e.g., CORS errors. This is also the correct status code
        ///for cached requests, where the status in responseReceived is a 200 and this will be 304.
        #[serde(rename = "statusCode")]
        pub status_code: i64,
        ///Raw response header text as it was received over the wire. The raw text may not always be
        ///available, such as in the case of HTTP/2 or QUIC.
        #[serde(rename = "headersText")]
        pub headers_text: Option<String>,
        ///The cookie partition key that will be used to store partitioned cookies set in this response.
        ///Only sent when partitioned cookies are enabled.
        #[serde(rename = "cookiePartitionKey")]
        pub cookie_partition_key: Option<String>,
        ///True if partitioned cookies are enabled, but the partition key is not serializeable to string.
        #[serde(rename = "cookiePartitionKeyOpaque")]
        pub cookie_partition_key_opaque: Option<bool>,
    }
    ///
    /// Enum for [TrustTokenOperationDoneEvent]'s `status`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum TrustTokenOperationDoneEventStatus {
        #[serde(rename = "Ok")]
        Ok,
        #[serde(rename = "InvalidArgument")]
        InvalidArgument,
        #[serde(rename = "MissingIssuerKeys")]
        MissingIssuerKeys,
        #[serde(rename = "FailedPrecondition")]
        FailedPrecondition,
        #[serde(rename = "ResourceExhausted")]
        ResourceExhausted,
        #[serde(rename = "AlreadyExists")]
        AlreadyExists,
        #[serde(rename = "Unavailable")]
        Unavailable,
        #[serde(rename = "Unauthorized")]
        Unauthorized,
        #[serde(rename = "BadResponse")]
        BadResponse,
        #[serde(rename = "InternalError")]
        InternalError,
        #[serde(rename = "UnknownError")]
        UnknownError,
        #[serde(rename = "FulfilledLocally")]
        FulfilledLocally,
    }
    ///Fired exactly once for each Trust Token operation. Depending on
    ///the type of the operation and whether the operation succeeded or
    ///failed, the event is fired before the corresponding request was sent
    ///or after the response was received.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrustTokenOperationDoneEvent {
        ///Detailed success or error status of the operation.
        ///'AlreadyExists' also signifies a successful operation, as the result
        ///of the operation already exists und thus, the operation was abort
        ///preemptively (e.g. a cache hit).
        #[serde(rename = "status")]
        pub status: TrustTokenOperationDoneEventStatus,
        #[serde(rename = "type")]
        pub type_: TrustTokenOperationType,
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Top level origin. The context in which the operation was attempted.
        #[serde(rename = "topLevelOrigin")]
        pub top_level_origin: Option<String>,
        ///Origin of the issuer in case of a "Issuance" or "Redemption" operation.
        #[serde(rename = "issuerOrigin")]
        pub issuer_origin: Option<String>,
        ///The number of obtained Trust Tokens on a successful "Issuance" operation.
        #[serde(rename = "issuedTokenCount")]
        pub issued_token_count: Option<i64>,
    }
    ///Fired once when parsing the .wbn file has succeeded.
    ///The event contains the information about the web bundle contents.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SubresourceWebBundleMetadataReceivedEvent {
        ///Request identifier. Used to match this information to another event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///A list of URLs of resources in the subresource Web Bundle.
        #[serde(rename = "urls")]
        pub urls: Vec<String>,
    }
    ///Fired once when parsing the .wbn file has failed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SubresourceWebBundleMetadataErrorEvent {
        ///Request identifier. Used to match this information to another event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Error message
        #[serde(rename = "errorMessage")]
        pub error_message: String,
    }
    ///Fired when handling requests for resources within a .wbn file.
    ///Note: this will only be fired for resources that are requested by the webpage.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SubresourceWebBundleInnerResponseParsedEvent {
        ///Request identifier of the subresource request
        #[serde(rename = "innerRequestId")]
        pub inner_request_id: RequestId,
        ///URL of the subresource resource.
        #[serde(rename = "innerRequestURL")]
        pub inner_request_url: String,
        ///Bundle request identifier. Used to match this information to another event.
        ///This made be absent in case when the instrumentation was enabled only
        ///after webbundle was parsed.
        #[serde(rename = "bundleRequestId")]
        pub bundle_request_id: Option<RequestId>,
    }
    ///Fired when request for resources within a .wbn file failed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SubresourceWebBundleInnerResponseErrorEvent {
        ///Request identifier of the subresource request
        #[serde(rename = "innerRequestId")]
        pub inner_request_id: RequestId,
        ///URL of the subresource resource.
        #[serde(rename = "innerRequestURL")]
        pub inner_request_url: String,
        ///Error message
        #[serde(rename = "errorMessage")]
        pub error_message: String,
        ///Bundle request identifier. Used to match this information to another event.
        ///This made be absent in case when the instrumentation was enabled only
        ///after webbundle was parsed.
        #[serde(rename = "bundleRequestId")]
        pub bundle_request_id: Option<RequestId>,
    }
    ///Is sent whenever a new report is added.
    ///And after 'enableReportingApi' for all existing reports.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReportingApiReportAddedEvent {
        #[serde(rename = "report")]
        pub report: ReportingApiReport,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReportingApiReportUpdatedEvent {
        #[serde(rename = "report")]
        pub report: ReportingApiReport,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReportingApiEndpointsChangedForOriginEvent {
        ///Origin of the document(s) which configured the endpoints.
        #[serde(rename = "origin")]
        pub origin: String,
        #[serde(rename = "endpoints")]
        pub endpoints: Vec<ReportingApiEndpoint>,
    }
}
///This domain provides various functionality related to drawing atop the inspected page.
pub mod overlay {
    ///Configuration data for drawing the source order of an elements children.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SourceOrderConfig {
        ///the color to outline the givent element in.
        #[serde(rename = "parentOutlineColor")]
        pub parent_outline_color: crate::protocol_test::dom::Rgba,
        ///the color to outline the child elements in.
        #[serde(rename = "childOutlineColor")]
        pub child_outline_color: crate::protocol_test::dom::Rgba,
    }
    ///Configuration data for the highlighting of Grid elements.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GridHighlightConfig {
        ///Whether the extension lines from grid cells to the rulers should be shown (default: false).
        #[serde(rename = "showGridExtensionLines")]
        pub show_grid_extension_lines: Option<bool>,
        ///Show Positive line number labels (default: false).
        #[serde(rename = "showPositiveLineNumbers")]
        pub show_positive_line_numbers: Option<bool>,
        ///Show Negative line number labels (default: false).
        #[serde(rename = "showNegativeLineNumbers")]
        pub show_negative_line_numbers: Option<bool>,
        ///Show area name labels (default: false).
        #[serde(rename = "showAreaNames")]
        pub show_area_names: Option<bool>,
        ///Show line name labels (default: false).
        #[serde(rename = "showLineNames")]
        pub show_line_names: Option<bool>,
        ///Show track size labels (default: false).
        #[serde(rename = "showTrackSizes")]
        pub show_track_sizes: Option<bool>,
        ///The grid container border highlight color (default: transparent).
        #[serde(rename = "gridBorderColor")]
        pub grid_border_color: Option<crate::protocol_test::dom::Rgba>,
        ///The cell border color (default: transparent). Deprecated, please use rowLineColor and columnLineColor instead.
        #[deprecated]
        #[serde(rename = "cellBorderColor")]
        pub cell_border_color: Option<crate::protocol_test::dom::Rgba>,
        ///The row line color (default: transparent).
        #[serde(rename = "rowLineColor")]
        pub row_line_color: Option<crate::protocol_test::dom::Rgba>,
        ///The column line color (default: transparent).
        #[serde(rename = "columnLineColor")]
        pub column_line_color: Option<crate::protocol_test::dom::Rgba>,
        ///Whether the grid border is dashed (default: false).
        #[serde(rename = "gridBorderDash")]
        pub grid_border_dash: Option<bool>,
        ///Whether the cell border is dashed (default: false). Deprecated, please us rowLineDash and columnLineDash instead.
        #[deprecated]
        #[serde(rename = "cellBorderDash")]
        pub cell_border_dash: Option<bool>,
        ///Whether row lines are dashed (default: false).
        #[serde(rename = "rowLineDash")]
        pub row_line_dash: Option<bool>,
        ///Whether column lines are dashed (default: false).
        #[serde(rename = "columnLineDash")]
        pub column_line_dash: Option<bool>,
        ///The row gap highlight fill color (default: transparent).
        #[serde(rename = "rowGapColor")]
        pub row_gap_color: Option<crate::protocol_test::dom::Rgba>,
        ///The row gap hatching fill color (default: transparent).
        #[serde(rename = "rowHatchColor")]
        pub row_hatch_color: Option<crate::protocol_test::dom::Rgba>,
        ///The column gap highlight fill color (default: transparent).
        #[serde(rename = "columnGapColor")]
        pub column_gap_color: Option<crate::protocol_test::dom::Rgba>,
        ///The column gap hatching fill color (default: transparent).
        #[serde(rename = "columnHatchColor")]
        pub column_hatch_color: Option<crate::protocol_test::dom::Rgba>,
        ///The named grid areas border color (Default: transparent).
        #[serde(rename = "areaBorderColor")]
        pub area_border_color: Option<crate::protocol_test::dom::Rgba>,
        ///The grid container background color (Default: transparent).
        #[serde(rename = "gridBackgroundColor")]
        pub grid_background_color: Option<crate::protocol_test::dom::Rgba>,
    }
    ///Configuration data for the highlighting of Flex container elements.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FlexContainerHighlightConfig {
        ///The style of the container border
        #[serde(rename = "containerBorder")]
        pub container_border: Option<LineStyle>,
        ///The style of the separator between lines
        #[serde(rename = "lineSeparator")]
        pub line_separator: Option<LineStyle>,
        ///The style of the separator between items
        #[serde(rename = "itemSeparator")]
        pub item_separator: Option<LineStyle>,
        ///Style of content-distribution space on the main axis (justify-content).
        #[serde(rename = "mainDistributedSpace")]
        pub main_distributed_space: Option<BoxStyle>,
        ///Style of content-distribution space on the cross axis (align-content).
        #[serde(rename = "crossDistributedSpace")]
        pub cross_distributed_space: Option<BoxStyle>,
        ///Style of empty space caused by row gaps (gap/row-gap).
        #[serde(rename = "rowGapSpace")]
        pub row_gap_space: Option<BoxStyle>,
        ///Style of empty space caused by columns gaps (gap/column-gap).
        #[serde(rename = "columnGapSpace")]
        pub column_gap_space: Option<BoxStyle>,
        ///Style of the self-alignment line (align-items).
        #[serde(rename = "crossAlignment")]
        pub cross_alignment: Option<LineStyle>,
    }
    ///Configuration data for the highlighting of Flex item elements.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FlexItemHighlightConfig {
        ///Style of the box representing the item's base size
        #[serde(rename = "baseSizeBox")]
        pub base_size_box: Option<BoxStyle>,
        ///Style of the border around the box representing the item's base size
        #[serde(rename = "baseSizeBorder")]
        pub base_size_border: Option<LineStyle>,
        ///Style of the arrow representing if the item grew or shrank
        #[serde(rename = "flexibilityArrow")]
        pub flexibility_arrow: Option<LineStyle>,
    }
    ///
    /// Enum for [LineStyle]'s `pattern`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum LineStylePattern {
        #[serde(rename = "dashed")]
        Dashed,
        #[serde(rename = "dotted")]
        Dotted,
    }
    ///Style information for drawing a line.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LineStyle {
        ///The color of the line (default: transparent)
        #[serde(rename = "color")]
        pub color: Option<crate::protocol_test::dom::Rgba>,
        ///The line pattern (default: solid)
        #[serde(rename = "pattern")]
        pub pattern: Option<Option<LineStylePattern>>,
    }
    ///Style information for drawing a box.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BoxStyle {
        ///The background color for the box (default: transparent)
        #[serde(rename = "fillColor")]
        pub fill_color: Option<crate::protocol_test::dom::Rgba>,
        ///The hatching color for the box (default: transparent)
        #[serde(rename = "hatchColor")]
        pub hatch_color: Option<crate::protocol_test::dom::Rgba>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ContrastAlgorithm {
        #[serde(rename = "aa")]
        Aa,
        #[serde(rename = "aaa")]
        Aaa,
        #[serde(rename = "apca")]
        Apca,
    }
    ///Configuration data for the highlighting of page elements.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightConfig {
        ///Whether the node info tooltip should be shown (default: false).
        #[serde(rename = "showInfo")]
        pub show_info: Option<bool>,
        ///Whether the node styles in the tooltip (default: false).
        #[serde(rename = "showStyles")]
        pub show_styles: Option<bool>,
        ///Whether the rulers should be shown (default: false).
        #[serde(rename = "showRulers")]
        pub show_rulers: Option<bool>,
        ///Whether the a11y info should be shown (default: true).
        #[serde(rename = "showAccessibilityInfo")]
        pub show_accessibility_info: Option<bool>,
        ///Whether the extension lines from node to the rulers should be shown (default: false).
        #[serde(rename = "showExtensionLines")]
        pub show_extension_lines: Option<bool>,
        ///The content box highlight fill color (default: transparent).
        #[serde(rename = "contentColor")]
        pub content_color: Option<crate::protocol_test::dom::Rgba>,
        ///The padding highlight fill color (default: transparent).
        #[serde(rename = "paddingColor")]
        pub padding_color: Option<crate::protocol_test::dom::Rgba>,
        ///The border highlight fill color (default: transparent).
        #[serde(rename = "borderColor")]
        pub border_color: Option<crate::protocol_test::dom::Rgba>,
        ///The margin highlight fill color (default: transparent).
        #[serde(rename = "marginColor")]
        pub margin_color: Option<crate::protocol_test::dom::Rgba>,
        ///The event target element highlight fill color (default: transparent).
        #[serde(rename = "eventTargetColor")]
        pub event_target_color: Option<crate::protocol_test::dom::Rgba>,
        ///The shape outside fill color (default: transparent).
        #[serde(rename = "shapeColor")]
        pub shape_color: Option<crate::protocol_test::dom::Rgba>,
        ///The shape margin fill color (default: transparent).
        #[serde(rename = "shapeMarginColor")]
        pub shape_margin_color: Option<crate::protocol_test::dom::Rgba>,
        ///The grid layout color (default: transparent).
        #[serde(rename = "cssGridColor")]
        pub css_grid_color: Option<crate::protocol_test::dom::Rgba>,
        ///The color format used to format color styles (default: hex).
        #[serde(rename = "colorFormat")]
        pub color_format: Option<ColorFormat>,
        ///The grid layout highlight configuration (default: all transparent).
        #[serde(rename = "gridHighlightConfig")]
        pub grid_highlight_config: Option<GridHighlightConfig>,
        ///The flex container highlight configuration (default: all transparent).
        #[serde(rename = "flexContainerHighlightConfig")]
        pub flex_container_highlight_config: Option<FlexContainerHighlightConfig>,
        ///The flex item highlight configuration (default: all transparent).
        #[serde(rename = "flexItemHighlightConfig")]
        pub flex_item_highlight_config: Option<FlexItemHighlightConfig>,
        ///The contrast algorithm to use for the contrast ratio (default: aa).
        #[serde(rename = "contrastAlgorithm")]
        pub contrast_algorithm: Option<ContrastAlgorithm>,
        ///The container query container highlight configuration (default: all transparent).
        #[serde(rename = "containerQueryContainerHighlightConfig")]
        pub container_query_container_highlight_config: Option<
            ContainerQueryContainerHighlightConfig,
        >,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ColorFormat {
        #[serde(rename = "rgb")]
        Rgb,
        #[serde(rename = "hsl")]
        Hsl,
        #[serde(rename = "hwb")]
        Hwb,
        #[serde(rename = "hex")]
        Hex,
    }
    ///Configurations for Persistent Grid Highlight
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GridNodeHighlightConfig {
        ///A descriptor for the highlight appearance.
        #[serde(rename = "gridHighlightConfig")]
        pub grid_highlight_config: GridHighlightConfig,
        ///Identifier of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FlexNodeHighlightConfig {
        ///A descriptor for the highlight appearance of flex containers.
        #[serde(rename = "flexContainerHighlightConfig")]
        pub flex_container_highlight_config: FlexContainerHighlightConfig,
        ///Identifier of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScrollSnapContainerHighlightConfig {
        ///The style of the snapport border (default: transparent)
        #[serde(rename = "snapportBorder")]
        pub snapport_border: Option<LineStyle>,
        ///The style of the snap area border (default: transparent)
        #[serde(rename = "snapAreaBorder")]
        pub snap_area_border: Option<LineStyle>,
        ///The margin highlight fill color (default: transparent).
        #[serde(rename = "scrollMarginColor")]
        pub scroll_margin_color: Option<crate::protocol_test::dom::Rgba>,
        ///The padding highlight fill color (default: transparent).
        #[serde(rename = "scrollPaddingColor")]
        pub scroll_padding_color: Option<crate::protocol_test::dom::Rgba>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScrollSnapHighlightConfig {
        ///A descriptor for the highlight appearance of scroll snap containers.
        #[serde(rename = "scrollSnapContainerHighlightConfig")]
        pub scroll_snap_container_highlight_config: ScrollSnapContainerHighlightConfig,
        ///Identifier of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///Configuration for dual screen hinge
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HingeConfig {
        ///A rectangle represent hinge
        #[serde(rename = "rect")]
        pub rect: crate::protocol_test::dom::Rect,
        ///The content box highlight fill color (default: a dark color).
        #[serde(rename = "contentColor")]
        pub content_color: Option<crate::protocol_test::dom::Rgba>,
        ///The content box highlight outline color (default: transparent).
        #[serde(rename = "outlineColor")]
        pub outline_color: Option<crate::protocol_test::dom::Rgba>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContainerQueryHighlightConfig {
        ///A descriptor for the highlight appearance of container query containers.
        #[serde(rename = "containerQueryContainerHighlightConfig")]
        pub container_query_container_highlight_config: ContainerQueryContainerHighlightConfig,
        ///Identifier of the container node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContainerQueryContainerHighlightConfig {
        ///The style of the container border.
        #[serde(rename = "containerBorder")]
        pub container_border: Option<LineStyle>,
        ///The style of the descendants' borders.
        #[serde(rename = "descendantBorder")]
        pub descendant_border: Option<LineStyle>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct IsolatedElementHighlightConfig {
        ///A descriptor for the highlight appearance of an element in isolation mode.
        #[serde(rename = "isolationModeHighlightConfig")]
        pub isolation_mode_highlight_config: IsolationModeHighlightConfig,
        ///Identifier of the isolated element to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct IsolationModeHighlightConfig {
        ///The fill color of the resizers (default: transparent).
        #[serde(rename = "resizerColor")]
        pub resizer_color: Option<crate::protocol_test::dom::Rgba>,
        ///The fill color for resizer handles (default: transparent).
        #[serde(rename = "resizerHandleColor")]
        pub resizer_handle_color: Option<crate::protocol_test::dom::Rgba>,
        ///The fill color for the mask covering non-isolated elements (default: transparent).
        #[serde(rename = "maskColor")]
        pub mask_color: Option<crate::protocol_test::dom::Rgba>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum InspectMode {
        #[serde(rename = "searchForNode")]
        SearchForNode,
        #[serde(rename = "searchForUAShadowDOM")]
        SearchForUaShadowDom,
        #[serde(rename = "captureAreaScreenshot")]
        CaptureAreaScreenshot,
        #[serde(rename = "showDistances")]
        ShowDistances,
        #[serde(rename = "none")]
        None,
    }
    ///Disables domain notifications.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables domain notifications.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [GetHighlightObjectForTest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHighlightObjectForTestParams {
        ///Id of the node to get highlight object for.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
        ///Whether to include distance info.
        #[serde(rename = "includeDistance")]
        pub include_distance: Option<bool>,
        ///Whether to include style info.
        #[serde(rename = "includeStyle")]
        pub include_style: Option<bool>,
        ///The color format to get config with (default: hex).
        #[serde(rename = "colorFormat")]
        pub color_format: Option<ColorFormat>,
        ///Whether to show accessibility info (default: true).
        #[serde(rename = "showAccessibilityInfo")]
        pub show_accessibility_info: Option<bool>,
    }
    ///
    /// Return value for [GetHighlightObjectForTest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHighlightObjectForTestReturns {
        ///Highlight data for the node.
        #[serde(rename = "highlight")]
        pub highlight: serde_json::Map<String, serde_json::Value>,
    }
    ///For testing.
    ///---
    ///Parameter Type: [GetHighlightObjectForTestParams]
    ///Return Type: [GetHighlightObjectForTestReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHighlightObjectForTest;
    impl crate::util::Command for GetHighlightObjectForTest {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getHighlightObjectForTest"
        }
    }
    ///
    /// Parameter value for [GetGridHighlightObjectsForTest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetGridHighlightObjectsForTestParams {
        ///Ids of the node to get highlight object for.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<crate::protocol_test::dom::NodeId>,
    }
    ///
    /// Return value for [GetGridHighlightObjectsForTest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetGridHighlightObjectsForTestReturns {
        ///Grid Highlight data for the node ids provided.
        #[serde(rename = "highlights")]
        pub highlights: serde_json::Map<String, serde_json::Value>,
    }
    ///For Persistent Grid testing.
    ///---
    ///Parameter Type: [GetGridHighlightObjectsForTestParams]
    ///Return Type: [GetGridHighlightObjectsForTestReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetGridHighlightObjectsForTest;
    impl crate::util::Command for GetGridHighlightObjectsForTest {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getGridHighlightObjectsForTest"
        }
    }
    ///
    /// Parameter value for [GetSourceOrderHighlightObjectForTest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSourceOrderHighlightObjectForTestParams {
        ///Id of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///
    /// Return value for [GetSourceOrderHighlightObjectForTest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSourceOrderHighlightObjectForTestReturns {
        ///Source order highlight data for the node id provided.
        #[serde(rename = "highlight")]
        pub highlight: serde_json::Map<String, serde_json::Value>,
    }
    ///For Source Order Viewer testing.
    ///---
    ///Parameter Type: [GetSourceOrderHighlightObjectForTestParams]
    ///Return Type: [GetSourceOrderHighlightObjectForTestReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSourceOrderHighlightObjectForTest;
    impl crate::util::Command for GetSourceOrderHighlightObjectForTest {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getSourceOrderHighlightObjectForTest"
        }
    }
    ///Hides any highlight.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HideHighlight;
    impl crate::util::Command for HideHighlight {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "hideHighlight"
        }
    }
    ///
    /// Parameter value for [HighlightFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightFrameParams {
        ///Identifier of the frame to highlight.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        ///The content box highlight fill color (default: transparent).
        #[serde(rename = "contentColor")]
        pub content_color: Option<crate::protocol_test::dom::Rgba>,
        ///The content box highlight outline color (default: transparent).
        #[serde(rename = "contentOutlineColor")]
        pub content_outline_color: Option<crate::protocol_test::dom::Rgba>,
    }
    ///Highlights owner element of the frame with given id.
    ///Deprecated: Doesn't work reliablity and cannot be fixed due to process
    ///separatation (the owner node might be in a different process). Determine
    ///the owner node in the client and use highlightNode.
    ///---
    ///Parameter Type: [HighlightFrameParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightFrame;
    impl crate::util::Command for HighlightFrame {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "highlightFrame"
        }
    }
    ///
    /// Parameter value for [HighlightNode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightNodeParams {
        ///A descriptor for the highlight appearance.
        #[serde(rename = "highlightConfig")]
        pub highlight_config: HighlightConfig,
        ///Identifier of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: Option<crate::protocol_test::dom::NodeId>,
        ///Identifier of the backend node to highlight.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///JavaScript object id of the node to be highlighted.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
        ///Selectors to highlight relevant nodes.
        #[serde(rename = "selector")]
        pub selector: Option<String>,
    }
    ///Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
    ///objectId must be specified.
    ///---
    ///Parameter Type: [HighlightNodeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightNode;
    impl crate::util::Command for HighlightNode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "highlightNode"
        }
    }
    ///
    /// Parameter value for [HighlightQuad].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightQuadParams {
        ///Quad to highlight
        #[serde(rename = "quad")]
        pub quad: crate::protocol_test::dom::Quad,
        ///The highlight fill color (default: transparent).
        #[serde(rename = "color")]
        pub color: Option<crate::protocol_test::dom::Rgba>,
        ///The highlight outline color (default: transparent).
        #[serde(rename = "outlineColor")]
        pub outline_color: Option<crate::protocol_test::dom::Rgba>,
    }
    ///Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
    ///---
    ///Parameter Type: [HighlightQuadParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightQuad;
    impl crate::util::Command for HighlightQuad {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "highlightQuad"
        }
    }
    ///
    /// Parameter value for [HighlightRect].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightRectParams {
        ///X coordinate
        #[serde(rename = "x")]
        pub x: i64,
        ///Y coordinate
        #[serde(rename = "y")]
        pub y: i64,
        ///Rectangle width
        #[serde(rename = "width")]
        pub width: i64,
        ///Rectangle height
        #[serde(rename = "height")]
        pub height: i64,
        ///The highlight fill color (default: transparent).
        #[serde(rename = "color")]
        pub color: Option<crate::protocol_test::dom::Rgba>,
        ///The highlight outline color (default: transparent).
        #[serde(rename = "outlineColor")]
        pub outline_color: Option<crate::protocol_test::dom::Rgba>,
    }
    ///Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
    ///---
    ///Parameter Type: [HighlightRectParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightRect;
    impl crate::util::Command for HighlightRect {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "highlightRect"
        }
    }
    ///
    /// Parameter value for [HighlightSourceOrder].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightSourceOrderParams {
        ///A descriptor for the appearance of the overlay drawing.
        #[serde(rename = "sourceOrderConfig")]
        pub source_order_config: SourceOrderConfig,
        ///Identifier of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: Option<crate::protocol_test::dom::NodeId>,
        ///Identifier of the backend node to highlight.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        ///JavaScript object id of the node to be highlighted.
        #[serde(rename = "objectId")]
        pub object_id: Option<crate::protocol_test::runtime::RemoteObjectId>,
    }
    ///Highlights the source order of the children of the DOM node with given id or with the given
    ///JavaScript object wrapper. Either nodeId or objectId must be specified.
    ///---
    ///Parameter Type: [HighlightSourceOrderParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HighlightSourceOrder;
    impl crate::util::Command for HighlightSourceOrder {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "highlightSourceOrder"
        }
    }
    ///
    /// Parameter value for [SetInspectMode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInspectModeParams {
        ///Set an inspection mode.
        #[serde(rename = "mode")]
        pub mode: InspectMode,
        ///A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled
        ///== false`.
        #[serde(rename = "highlightConfig")]
        pub highlight_config: Option<HighlightConfig>,
    }
    ///Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
    ///Backend then generates 'inspectNodeRequested' event upon element selection.
    ///---
    ///Parameter Type: [SetInspectModeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInspectMode;
    impl crate::util::Command for SetInspectMode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setInspectMode"
        }
    }
    ///
    /// Parameter value for [SetShowAdHighlights].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowAdHighlightsParams {
        ///True for showing ad highlights
        #[serde(rename = "show")]
        pub show: bool,
    }
    ///Highlights owner element of all frames detected to be ads.
    ///---
    ///Parameter Type: [SetShowAdHighlightsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowAdHighlights;
    impl crate::util::Command for SetShowAdHighlights {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowAdHighlights"
        }
    }
    ///
    /// Parameter value for [SetPausedInDebuggerMessage].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPausedInDebuggerMessageParams {
        ///The message to display, also triggers resume and step over controls.
        #[serde(rename = "message")]
        pub message: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPausedInDebuggerMessage;
    impl crate::util::Command for SetPausedInDebuggerMessage {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setPausedInDebuggerMessage"
        }
    }
    ///
    /// Parameter value for [SetShowDebugBorders].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowDebugBordersParams {
        ///True for showing debug borders
        #[serde(rename = "show")]
        pub show: bool,
    }
    ///Requests that backend shows debug borders on layers
    ///---
    ///Parameter Type: [SetShowDebugBordersParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowDebugBorders;
    impl crate::util::Command for SetShowDebugBorders {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowDebugBorders"
        }
    }
    ///
    /// Parameter value for [SetShowFpsCounter].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowFpsCounterParams {
        ///True for showing the FPS counter
        #[serde(rename = "show")]
        pub show: bool,
    }
    ///Requests that backend shows the FPS counter
    ///---
    ///Parameter Type: [SetShowFpsCounterParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowFpsCounter;
    impl crate::util::Command for SetShowFpsCounter {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowFPSCounter"
        }
    }
    ///
    /// Parameter value for [SetShowGridOverlays].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowGridOverlaysParams {
        ///An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "gridNodeHighlightConfigs")]
        pub grid_node_highlight_configs: Vec<GridNodeHighlightConfig>,
    }
    ///Highlight multiple elements with the CSS Grid overlay.
    ///---
    ///Parameter Type: [SetShowGridOverlaysParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowGridOverlays;
    impl crate::util::Command for SetShowGridOverlays {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowGridOverlays"
        }
    }
    ///
    /// Parameter value for [SetShowFlexOverlays].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowFlexOverlaysParams {
        ///An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "flexNodeHighlightConfigs")]
        pub flex_node_highlight_configs: Vec<FlexNodeHighlightConfig>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowFlexOverlays;
    impl crate::util::Command for SetShowFlexOverlays {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowFlexOverlays"
        }
    }
    ///
    /// Parameter value for [SetShowScrollSnapOverlays].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowScrollSnapOverlaysParams {
        ///An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "scrollSnapHighlightConfigs")]
        pub scroll_snap_highlight_configs: Vec<ScrollSnapHighlightConfig>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowScrollSnapOverlays;
    impl crate::util::Command for SetShowScrollSnapOverlays {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowScrollSnapOverlays"
        }
    }
    ///
    /// Parameter value for [SetShowContainerQueryOverlays].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowContainerQueryOverlaysParams {
        ///An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "containerQueryHighlightConfigs")]
        pub container_query_highlight_configs: Vec<ContainerQueryHighlightConfig>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowContainerQueryOverlays;
    impl crate::util::Command for SetShowContainerQueryOverlays {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowContainerQueryOverlays"
        }
    }
    ///
    /// Parameter value for [SetShowPaintRects].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowPaintRectsParams {
        ///True for showing paint rectangles
        #[serde(rename = "result")]
        pub result: bool,
    }
    ///Requests that backend shows paint rectangles
    ///---
    ///Parameter Type: [SetShowPaintRectsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowPaintRects;
    impl crate::util::Command for SetShowPaintRects {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowPaintRects"
        }
    }
    ///
    /// Parameter value for [SetShowLayoutShiftRegions].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowLayoutShiftRegionsParams {
        ///True for showing layout shift regions
        #[serde(rename = "result")]
        pub result: bool,
    }
    ///Requests that backend shows layout shift regions
    ///---
    ///Parameter Type: [SetShowLayoutShiftRegionsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowLayoutShiftRegions;
    impl crate::util::Command for SetShowLayoutShiftRegions {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowLayoutShiftRegions"
        }
    }
    ///
    /// Parameter value for [SetShowScrollBottleneckRects].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowScrollBottleneckRectsParams {
        ///True for showing scroll bottleneck rects
        #[serde(rename = "show")]
        pub show: bool,
    }
    ///Requests that backend shows scroll bottleneck rects
    ///---
    ///Parameter Type: [SetShowScrollBottleneckRectsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowScrollBottleneckRects;
    impl crate::util::Command for SetShowScrollBottleneckRects {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowScrollBottleneckRects"
        }
    }
    ///
    /// Parameter value for [SetShowHitTestBorders].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowHitTestBordersParams {
        ///True for showing hit-test borders
        #[serde(rename = "show")]
        pub show: bool,
    }
    ///Deprecated, no longer has any effect.
    ///---
    ///Parameter Type: [SetShowHitTestBordersParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowHitTestBorders;
    impl crate::util::Command for SetShowHitTestBorders {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowHitTestBorders"
        }
    }
    ///
    /// Parameter value for [SetShowWebVitals].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowWebVitalsParams {
        #[serde(rename = "show")]
        pub show: bool,
    }
    ///Request that backend shows an overlay with web vital metrics.
    ///---
    ///Parameter Type: [SetShowWebVitalsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowWebVitals;
    impl crate::util::Command for SetShowWebVitals {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowWebVitals"
        }
    }
    ///
    /// Parameter value for [SetShowViewportSizeOnResize].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowViewportSizeOnResizeParams {
        ///Whether to paint size or not.
        #[serde(rename = "show")]
        pub show: bool,
    }
    ///Paints viewport size upon main frame resize.
    ///---
    ///Parameter Type: [SetShowViewportSizeOnResizeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowViewportSizeOnResize;
    impl crate::util::Command for SetShowViewportSizeOnResize {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowViewportSizeOnResize"
        }
    }
    ///
    /// Parameter value for [SetShowHinge].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowHingeParams {
        ///hinge data, null means hideHinge
        #[serde(rename = "hingeConfig")]
        pub hinge_config: Option<HingeConfig>,
    }
    ///Add a dual screen device hinge
    ///---
    ///Parameter Type: [SetShowHingeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowHinge;
    impl crate::util::Command for SetShowHinge {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowHinge"
        }
    }
    ///
    /// Parameter value for [SetShowIsolatedElements].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowIsolatedElementsParams {
        ///An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "isolatedElementHighlightConfigs")]
        pub isolated_element_highlight_configs: Vec<IsolatedElementHighlightConfig>,
    }
    ///Show elements in isolation mode with overlays.
    ///---
    ///Parameter Type: [SetShowIsolatedElementsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetShowIsolatedElements;
    impl crate::util::Command for SetShowIsolatedElements {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setShowIsolatedElements"
        }
    }
    ///Fired when the node should be inspected. This happens after call to `setInspectMode` or when
    ///user manually inspects an element.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InspectNodeRequestedEvent {
        ///Id of the node to inspect.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: crate::protocol_test::dom::BackendNodeId,
    }
    ///Fired when the node should be highlighted. This happens after call to `setInspectMode`.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NodeHighlightRequestedEvent {
        #[serde(rename = "nodeId")]
        pub node_id: crate::protocol_test::dom::NodeId,
    }
    ///Fired when user asks to capture screenshot of some area on the page.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScreenshotRequestedEvent {
        ///Viewport to capture, in device independent pixels (dip).
        #[serde(rename = "viewport")]
        pub viewport: crate::protocol_test::page::Viewport,
    }
    ///Fired when user cancels the inspect mode.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InspectModeCanceledEvent {}
}
///Actions and events related to the inspected page belong to the page domain.
pub mod page {
    ///Unique frame identifier.
    pub type FrameId = String;
    ///Indicates whether a frame has been identified as an ad.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AdFrameType {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "child")]
        Child,
        #[serde(rename = "root")]
        Root,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AdFrameExplanation {
        #[serde(rename = "ParentIsAd")]
        ParentIsAd,
        #[serde(rename = "CreatedByAdScript")]
        CreatedByAdScript,
        #[serde(rename = "MatchedBlockingRule")]
        MatchedBlockingRule,
    }
    ///Indicates whether a frame has been identified as an ad and why.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AdFrameStatus {
        #[serde(rename = "adFrameType")]
        pub ad_frame_type: AdFrameType,
        #[serde(rename = "explanations")]
        pub explanations: Option<Vec<AdFrameExplanation>>,
    }
    ///Identifies the bottom-most script which caused the frame to be labelled
    ///as an ad.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AdScriptId {
        ///Script Id of the bottom-most script which caused the frame to be labelled
        ///as an ad.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///Id of adScriptId's debugger.
        #[serde(rename = "debuggerId")]
        pub debugger_id: crate::protocol_test::runtime::UniqueDebuggerId,
    }
    ///Indicates whether the frame is a secure context and why it is the case.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SecureContextType {
        #[serde(rename = "Secure")]
        Secure,
        #[serde(rename = "SecureLocalhost")]
        SecureLocalhost,
        #[serde(rename = "InsecureScheme")]
        InsecureScheme,
        #[serde(rename = "InsecureAncestor")]
        InsecureAncestor,
    }
    ///Indicates whether the frame is cross-origin isolated and why it is the case.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CrossOriginIsolatedContextType {
        #[serde(rename = "Isolated")]
        Isolated,
        #[serde(rename = "NotIsolated")]
        NotIsolated,
        #[serde(rename = "NotIsolatedFeatureDisabled")]
        NotIsolatedFeatureDisabled,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum GatedApiFeatures {
        #[serde(rename = "SharedArrayBuffers")]
        SharedArrayBuffers,
        #[serde(rename = "SharedArrayBuffersTransferAllowed")]
        SharedArrayBuffersTransferAllowed,
        #[serde(rename = "PerformanceMeasureMemory")]
        PerformanceMeasureMemory,
        #[serde(rename = "PerformanceProfile")]
        PerformanceProfile,
    }
    ///All Permissions Policy features. This enum should match the one defined
    ///in third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PermissionsPolicyFeature {
        #[serde(rename = "accelerometer")]
        Accelerometer,
        #[serde(rename = "ambient-light-sensor")]
        AmbientLightSensor,
        #[serde(rename = "attribution-reporting")]
        AttributionReporting,
        #[serde(rename = "autoplay")]
        Autoplay,
        #[serde(rename = "bluetooth")]
        Bluetooth,
        #[serde(rename = "browsing-topics")]
        BrowsingTopics,
        #[serde(rename = "camera")]
        Camera,
        #[serde(rename = "ch-dpr")]
        ChDpr,
        #[serde(rename = "ch-device-memory")]
        ChDeviceMemory,
        #[serde(rename = "ch-downlink")]
        ChDownlink,
        #[serde(rename = "ch-ect")]
        ChEct,
        #[serde(rename = "ch-prefers-color-scheme")]
        ChPrefersColorScheme,
        #[serde(rename = "ch-prefers-reduced-motion")]
        ChPrefersReducedMotion,
        #[serde(rename = "ch-rtt")]
        ChRtt,
        #[serde(rename = "ch-save-data")]
        ChSaveData,
        #[serde(rename = "ch-ua")]
        ChUa,
        #[serde(rename = "ch-ua-arch")]
        ChUaArch,
        #[serde(rename = "ch-ua-bitness")]
        ChUaBitness,
        #[serde(rename = "ch-ua-platform")]
        ChUaPlatform,
        #[serde(rename = "ch-ua-model")]
        ChUaModel,
        #[serde(rename = "ch-ua-mobile")]
        ChUaMobile,
        #[serde(rename = "ch-ua-form-factor")]
        ChUaFormFactor,
        #[serde(rename = "ch-ua-full-version")]
        ChUaFullVersion,
        #[serde(rename = "ch-ua-full-version-list")]
        ChUaFullVersionList,
        #[serde(rename = "ch-ua-platform-version")]
        ChUaPlatformVersion,
        #[serde(rename = "ch-ua-wow64")]
        ChUaWow64,
        #[serde(rename = "ch-viewport-height")]
        ChViewportHeight,
        #[serde(rename = "ch-viewport-width")]
        ChViewportWidth,
        #[serde(rename = "ch-width")]
        ChWidth,
        #[serde(rename = "clipboard-read")]
        ClipboardRead,
        #[serde(rename = "clipboard-write")]
        ClipboardWrite,
        #[serde(rename = "compute-pressure")]
        ComputePressure,
        #[serde(rename = "cross-origin-isolated")]
        CrossOriginIsolated,
        #[serde(rename = "direct-sockets")]
        DirectSockets,
        #[serde(rename = "display-capture")]
        DisplayCapture,
        #[serde(rename = "document-domain")]
        DocumentDomain,
        #[serde(rename = "encrypted-media")]
        EncryptedMedia,
        #[serde(rename = "execution-while-out-of-viewport")]
        ExecutionWhileOutOfViewport,
        #[serde(rename = "execution-while-not-rendered")]
        ExecutionWhileNotRendered,
        #[serde(rename = "focus-without-user-activation")]
        FocusWithoutUserActivation,
        #[serde(rename = "fullscreen")]
        Fullscreen,
        #[serde(rename = "frobulate")]
        Frobulate,
        #[serde(rename = "gamepad")]
        Gamepad,
        #[serde(rename = "geolocation")]
        Geolocation,
        #[serde(rename = "gyroscope")]
        Gyroscope,
        #[serde(rename = "hid")]
        Hid,
        #[serde(rename = "identity-credentials-get")]
        IdentityCredentialsGet,
        #[serde(rename = "idle-detection")]
        IdleDetection,
        #[serde(rename = "interest-cohort")]
        InterestCohort,
        #[serde(rename = "join-ad-interest-group")]
        JoinAdInterestGroup,
        #[serde(rename = "keyboard-map")]
        KeyboardMap,
        #[serde(rename = "local-fonts")]
        LocalFonts,
        #[serde(rename = "magnetometer")]
        Magnetometer,
        #[serde(rename = "microphone")]
        Microphone,
        #[serde(rename = "midi")]
        Midi,
        #[serde(rename = "otp-credentials")]
        OtpCredentials,
        #[serde(rename = "payment")]
        Payment,
        #[serde(rename = "picture-in-picture")]
        PictureInPicture,
        #[serde(rename = "private-aggregation")]
        PrivateAggregation,
        #[serde(rename = "private-state-token-issuance")]
        PrivateStateTokenIssuance,
        #[serde(rename = "private-state-token-redemption")]
        PrivateStateTokenRedemption,
        #[serde(rename = "publickey-credentials-get")]
        PublickeyCredentialsGet,
        #[serde(rename = "run-ad-auction")]
        RunAdAuction,
        #[serde(rename = "screen-wake-lock")]
        ScreenWakeLock,
        #[serde(rename = "serial")]
        Serial,
        #[serde(rename = "shared-autofill")]
        SharedAutofill,
        #[serde(rename = "shared-storage")]
        SharedStorage,
        #[serde(rename = "shared-storage-select-url")]
        SharedStorageSelectUrl,
        #[serde(rename = "smart-card")]
        SmartCard,
        #[serde(rename = "storage-access")]
        StorageAccess,
        #[serde(rename = "sync-xhr")]
        SyncXhr,
        #[serde(rename = "unload")]
        Unload,
        #[serde(rename = "usb")]
        Usb,
        #[serde(rename = "vertical-scroll")]
        VerticalScroll,
        #[serde(rename = "web-share")]
        WebShare,
        #[serde(rename = "window-management")]
        WindowManagement,
        #[serde(rename = "window-placement")]
        WindowPlacement,
        #[serde(rename = "xr-spatial-tracking")]
        XrSpatialTracking,
    }
    ///Reason for a permissions policy feature to be disabled.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PermissionsPolicyBlockReason {
        #[serde(rename = "Header")]
        Header,
        #[serde(rename = "IframeAttribute")]
        IframeAttribute,
        #[serde(rename = "InFencedFrameTree")]
        InFencedFrameTree,
        #[serde(rename = "InIsolatedApp")]
        InIsolatedApp,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PermissionsPolicyBlockLocator {
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        #[serde(rename = "blockReason")]
        pub block_reason: PermissionsPolicyBlockReason,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PermissionsPolicyFeatureState {
        #[serde(rename = "feature")]
        pub feature: PermissionsPolicyFeature,
        #[serde(rename = "allowed")]
        pub allowed: bool,
        #[serde(rename = "locator")]
        pub locator: Option<PermissionsPolicyBlockLocator>,
    }
    ///Origin Trial(https://www.chromium.org/blink/origin-trials) support.
    ///Status for an Origin Trial token.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum OriginTrialTokenStatus {
        #[serde(rename = "Success")]
        Success,
        #[serde(rename = "NotSupported")]
        NotSupported,
        #[serde(rename = "Insecure")]
        Insecure,
        #[serde(rename = "Expired")]
        Expired,
        #[serde(rename = "WrongOrigin")]
        WrongOrigin,
        #[serde(rename = "InvalidSignature")]
        InvalidSignature,
        #[serde(rename = "Malformed")]
        Malformed,
        #[serde(rename = "WrongVersion")]
        WrongVersion,
        #[serde(rename = "FeatureDisabled")]
        FeatureDisabled,
        #[serde(rename = "TokenDisabled")]
        TokenDisabled,
        #[serde(rename = "FeatureDisabledForUser")]
        FeatureDisabledForUser,
        #[serde(rename = "UnknownTrial")]
        UnknownTrial,
    }
    ///Status for an Origin Trial.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum OriginTrialStatus {
        #[serde(rename = "Enabled")]
        Enabled,
        #[serde(rename = "ValidTokenNotProvided")]
        ValidTokenNotProvided,
        #[serde(rename = "OSNotSupported")]
        OsNotSupported,
        #[serde(rename = "TrialNotAllowed")]
        TrialNotAllowed,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum OriginTrialUsageRestriction {
        #[serde(rename = "None")]
        None,
        #[serde(rename = "Subset")]
        Subset,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct OriginTrialToken {
        #[serde(rename = "origin")]
        pub origin: String,
        #[serde(rename = "matchSubDomains")]
        pub match_sub_domains: bool,
        #[serde(rename = "trialName")]
        pub trial_name: String,
        #[serde(rename = "expiryTime")]
        pub expiry_time: crate::protocol_test::network::TimeSinceEpoch,
        #[serde(rename = "isThirdParty")]
        pub is_third_party: bool,
        #[serde(rename = "usageRestriction")]
        pub usage_restriction: OriginTrialUsageRestriction,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct OriginTrialTokenWithStatus {
        #[serde(rename = "rawTokenText")]
        pub raw_token_text: String,
        ///`parsedToken` is present only when the token is extractable and
        ///parsable.
        #[serde(rename = "parsedToken")]
        pub parsed_token: Option<OriginTrialToken>,
        #[serde(rename = "status")]
        pub status: OriginTrialTokenStatus,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct OriginTrial {
        #[serde(rename = "trialName")]
        pub trial_name: String,
        #[serde(rename = "status")]
        pub status: OriginTrialStatus,
        #[serde(rename = "tokensWithStatus")]
        pub tokens_with_status: Vec<OriginTrialTokenWithStatus>,
    }
    ///Information about the Frame on the page.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Frame {
        ///Frame unique identifier.
        #[serde(rename = "id")]
        pub id: FrameId,
        ///Parent frame identifier.
        #[serde(rename = "parentId")]
        pub parent_id: Option<FrameId>,
        ///Identifier of the loader associated with this frame.
        #[serde(rename = "loaderId")]
        pub loader_id: crate::protocol_test::network::LoaderId,
        ///Frame's name as specified in the tag.
        #[serde(rename = "name")]
        pub name: Option<String>,
        ///Frame document's URL without fragment.
        #[serde(rename = "url")]
        pub url: String,
        ///Frame document's URL fragment including the '#'.
        #[serde(rename = "urlFragment")]
        pub url_fragment: Option<String>,
        ///Frame document's registered domain, taking the public suffixes list into account.
        ///Extracted from the Frame's url.
        ///Example URLs: http://www.google.com/file.html -> "google.com"
        ///              http://a.b.co.uk/file.html      -> "b.co.uk"
        #[serde(rename = "domainAndRegistry")]
        pub domain_and_registry: String,
        ///Frame document's security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: String,
        ///Frame document's mimeType as determined by the browser.
        #[serde(rename = "mimeType")]
        pub mime_type: String,
        ///If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
        #[serde(rename = "unreachableUrl")]
        pub unreachable_url: Option<String>,
        ///Indicates whether this frame was tagged as an ad and why.
        #[serde(rename = "adFrameStatus")]
        pub ad_frame_status: Option<AdFrameStatus>,
        ///Indicates whether the main document is a secure context and explains why that is the case.
        #[serde(rename = "secureContextType")]
        pub secure_context_type: SecureContextType,
        ///Indicates whether this is a cross origin isolated context.
        #[serde(rename = "crossOriginIsolatedContextType")]
        pub cross_origin_isolated_context_type: CrossOriginIsolatedContextType,
        ///Indicated which gated APIs / features are available.
        #[serde(rename = "gatedAPIFeatures")]
        pub gated_api_features: Vec<GatedApiFeatures>,
    }
    ///Information about the Resource on the page.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameResource {
        ///Resource URL.
        #[serde(rename = "url")]
        pub url: String,
        ///Type of this resource.
        #[serde(rename = "type")]
        pub type_: crate::protocol_test::network::ResourceType,
        ///Resource mimeType as determined by the browser.
        #[serde(rename = "mimeType")]
        pub mime_type: String,
        ///last-modified timestamp as reported by server.
        #[serde(rename = "lastModified")]
        pub last_modified: Option<crate::protocol_test::network::TimeSinceEpoch>,
        ///Resource content size.
        #[serde(rename = "contentSize")]
        pub content_size: Option<f64>,
        ///True if the resource failed to load.
        #[serde(rename = "failed")]
        pub failed: Option<bool>,
        ///True if the resource was canceled during loading.
        #[serde(rename = "canceled")]
        pub canceled: Option<bool>,
    }
    ///Information about the Frame hierarchy along with their cached resources.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameResourceTree {
        ///Frame information for this tree item.
        #[serde(rename = "frame")]
        pub frame: Frame,
        ///Child frames.
        #[serde(rename = "childFrames")]
        pub child_frames: Option<Vec<FrameResourceTree>>,
        ///Information about frame resources.
        #[serde(rename = "resources")]
        pub resources: Vec<FrameResource>,
    }
    ///Information about the Frame hierarchy.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameTree {
        ///Frame information for this tree item.
        #[serde(rename = "frame")]
        pub frame: Frame,
        ///Child frames.
        #[serde(rename = "childFrames")]
        pub child_frames: Option<Vec<FrameTree>>,
    }
    ///Unique script identifier.
    pub type ScriptIdentifier = String;
    ///Transition type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum TransitionType {
        #[serde(rename = "link")]
        Link,
        #[serde(rename = "typed")]
        Typed,
        #[serde(rename = "address_bar")]
        AddressBar,
        #[serde(rename = "auto_bookmark")]
        AutoBookmark,
        #[serde(rename = "auto_subframe")]
        AutoSubframe,
        #[serde(rename = "manual_subframe")]
        ManualSubframe,
        #[serde(rename = "generated")]
        Generated,
        #[serde(rename = "auto_toplevel")]
        AutoToplevel,
        #[serde(rename = "form_submit")]
        FormSubmit,
        #[serde(rename = "reload")]
        Reload,
        #[serde(rename = "keyword")]
        Keyword,
        #[serde(rename = "keyword_generated")]
        KeywordGenerated,
        #[serde(rename = "other")]
        Other,
    }
    ///Navigation history entry.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NavigationEntry {
        ///Unique id of the navigation history entry.
        #[serde(rename = "id")]
        pub id: i64,
        ///URL of the navigation history entry.
        #[serde(rename = "url")]
        pub url: String,
        ///URL that the user typed in the url bar.
        #[serde(rename = "userTypedURL")]
        pub user_typed_url: String,
        ///Title of the navigation history entry.
        #[serde(rename = "title")]
        pub title: String,
        ///Transition type.
        #[serde(rename = "transitionType")]
        pub transition_type: TransitionType,
    }
    ///Screencast frame metadata.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScreencastFrameMetadata {
        ///Top offset in DIP.
        #[serde(rename = "offsetTop")]
        pub offset_top: f64,
        ///Page scale factor.
        #[serde(rename = "pageScaleFactor")]
        pub page_scale_factor: f64,
        ///Device screen width in DIP.
        #[serde(rename = "deviceWidth")]
        pub device_width: f64,
        ///Device screen height in DIP.
        #[serde(rename = "deviceHeight")]
        pub device_height: f64,
        ///Position of horizontal scroll in CSS pixels.
        #[serde(rename = "scrollOffsetX")]
        pub scroll_offset_x: f64,
        ///Position of vertical scroll in CSS pixels.
        #[serde(rename = "scrollOffsetY")]
        pub scroll_offset_y: f64,
        ///Frame swap timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: Option<crate::protocol_test::network::TimeSinceEpoch>,
    }
    ///Javascript dialog type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DialogType {
        #[serde(rename = "alert")]
        Alert,
        #[serde(rename = "confirm")]
        Confirm,
        #[serde(rename = "prompt")]
        Prompt,
        #[serde(rename = "beforeunload")]
        Beforeunload,
    }
    ///Error while paring app manifest.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AppManifestError {
        ///Error message.
        #[serde(rename = "message")]
        pub message: String,
        ///If criticial, this is a non-recoverable parse error.
        #[serde(rename = "critical")]
        pub critical: i64,
        ///Error line.
        #[serde(rename = "line")]
        pub line: i64,
        ///Error column.
        #[serde(rename = "column")]
        pub column: i64,
    }
    ///Parsed app manifest properties.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AppManifestParsedProperties {
        ///Computed scope value
        #[serde(rename = "scope")]
        pub scope: String,
    }
    ///Layout viewport position and dimensions.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LayoutViewport {
        ///Horizontal offset relative to the document (CSS pixels).
        #[serde(rename = "pageX")]
        pub page_x: i64,
        ///Vertical offset relative to the document (CSS pixels).
        #[serde(rename = "pageY")]
        pub page_y: i64,
        ///Width (CSS pixels), excludes scrollbar if present.
        #[serde(rename = "clientWidth")]
        pub client_width: i64,
        ///Height (CSS pixels), excludes scrollbar if present.
        #[serde(rename = "clientHeight")]
        pub client_height: i64,
    }
    ///Visual viewport position, dimensions, and scale.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct VisualViewport {
        ///Horizontal offset relative to the layout viewport (CSS pixels).
        #[serde(rename = "offsetX")]
        pub offset_x: f64,
        ///Vertical offset relative to the layout viewport (CSS pixels).
        #[serde(rename = "offsetY")]
        pub offset_y: f64,
        ///Horizontal offset relative to the document (CSS pixels).
        #[serde(rename = "pageX")]
        pub page_x: f64,
        ///Vertical offset relative to the document (CSS pixels).
        #[serde(rename = "pageY")]
        pub page_y: f64,
        ///Width (CSS pixels), excludes scrollbar if present.
        #[serde(rename = "clientWidth")]
        pub client_width: f64,
        ///Height (CSS pixels), excludes scrollbar if present.
        #[serde(rename = "clientHeight")]
        pub client_height: f64,
        ///Scale relative to the ideal viewport (size at width=device-width).
        #[serde(rename = "scale")]
        pub scale: f64,
        ///Page zoom factor (CSS to device independent pixels ratio).
        #[serde(rename = "zoom")]
        pub zoom: Option<f64>,
    }
    ///Viewport for capturing screenshot.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Viewport {
        ///X offset in device independent pixels (dip).
        #[serde(rename = "x")]
        pub x: f64,
        ///Y offset in device independent pixels (dip).
        #[serde(rename = "y")]
        pub y: f64,
        ///Rectangle width in device independent pixels (dip).
        #[serde(rename = "width")]
        pub width: f64,
        ///Rectangle height in device independent pixels (dip).
        #[serde(rename = "height")]
        pub height: f64,
        ///Page scale factor.
        #[serde(rename = "scale")]
        pub scale: f64,
    }
    ///Generic font families collection.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FontFamilies {
        ///The standard font-family.
        #[serde(rename = "standard")]
        pub standard: Option<String>,
        ///The fixed font-family.
        #[serde(rename = "fixed")]
        pub fixed: Option<String>,
        ///The serif font-family.
        #[serde(rename = "serif")]
        pub serif: Option<String>,
        ///The sansSerif font-family.
        #[serde(rename = "sansSerif")]
        pub sans_serif: Option<String>,
        ///The cursive font-family.
        #[serde(rename = "cursive")]
        pub cursive: Option<String>,
        ///The fantasy font-family.
        #[serde(rename = "fantasy")]
        pub fantasy: Option<String>,
        ///The math font-family.
        #[serde(rename = "math")]
        pub math: Option<String>,
    }
    ///Font families collection for a script.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScriptFontFamilies {
        ///Name of the script which these font families are defined for.
        #[serde(rename = "script")]
        pub script: String,
        ///Generic font families collection for the script.
        #[serde(rename = "fontFamilies")]
        pub font_families: FontFamilies,
    }
    ///Default font sizes.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FontSizes {
        ///Default standard font size.
        #[serde(rename = "standard")]
        pub standard: Option<i64>,
        ///Default fixed font size.
        #[serde(rename = "fixed")]
        pub fixed: Option<i64>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ClientNavigationReason {
        #[serde(rename = "formSubmissionGet")]
        FormSubmissionGet,
        #[serde(rename = "formSubmissionPost")]
        FormSubmissionPost,
        #[serde(rename = "httpHeaderRefresh")]
        HttpHeaderRefresh,
        #[serde(rename = "scriptInitiated")]
        ScriptInitiated,
        #[serde(rename = "metaTagRefresh")]
        MetaTagRefresh,
        #[serde(rename = "pageBlockInterstitial")]
        PageBlockInterstitial,
        #[serde(rename = "reload")]
        Reload,
        #[serde(rename = "anchorClick")]
        AnchorClick,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ClientNavigationDisposition {
        #[serde(rename = "currentTab")]
        CurrentTab,
        #[serde(rename = "newTab")]
        NewTab,
        #[serde(rename = "newWindow")]
        NewWindow,
        #[serde(rename = "download")]
        Download,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InstallabilityErrorArgument {
        ///Argument name (e.g. name:'minimum-icon-size-in-pixels').
        #[serde(rename = "name")]
        pub name: String,
        ///Argument value (e.g. value:'64').
        #[serde(rename = "value")]
        pub value: String,
    }
    ///The installability error
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InstallabilityError {
        ///The error id (e.g. 'manifest-missing-suitable-icon').
        #[serde(rename = "errorId")]
        pub error_id: String,
        ///The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'}).
        #[serde(rename = "errorArguments")]
        pub error_arguments: Vec<InstallabilityErrorArgument>,
    }
    ///The referring-policy used for the navigation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ReferrerPolicy {
        #[serde(rename = "noReferrer")]
        NoReferrer,
        #[serde(rename = "noReferrerWhenDowngrade")]
        NoReferrerWhenDowngrade,
        #[serde(rename = "origin")]
        Origin,
        #[serde(rename = "originWhenCrossOrigin")]
        OriginWhenCrossOrigin,
        #[serde(rename = "sameOrigin")]
        SameOrigin,
        #[serde(rename = "strictOrigin")]
        StrictOrigin,
        #[serde(rename = "strictOriginWhenCrossOrigin")]
        StrictOriginWhenCrossOrigin,
        #[serde(rename = "unsafeUrl")]
        UnsafeUrl,
    }
    ///Per-script compilation cache parameters for `Page.produceCompilationCache`
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CompilationCacheParams {
        ///The URL of the script to produce a compilation cache entry for.
        #[serde(rename = "url")]
        pub url: String,
        ///A hint to the backend whether eager compilation is recommended.
        ///(the actual compilation mode used is upon backend discretion).
        #[serde(rename = "eager")]
        pub eager: Option<bool>,
    }
    ///Enum of possible auto-reponse for permisison / prompt dialogs.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AutoResponseMode {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "autoAccept")]
        AutoAccept,
        #[serde(rename = "autoReject")]
        AutoReject,
        #[serde(rename = "autoOptOut")]
        AutoOptOut,
    }
    ///The type of a frameNavigated event.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum NavigationType {
        #[serde(rename = "Navigation")]
        Navigation,
        #[serde(rename = "BackForwardCacheRestore")]
        BackForwardCacheRestore,
    }
    ///List of not restored reasons for back-forward cache.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum BackForwardCacheNotRestoredReason {
        #[serde(rename = "NotPrimaryMainFrame")]
        NotPrimaryMainFrame,
        #[serde(rename = "BackForwardCacheDisabled")]
        BackForwardCacheDisabled,
        #[serde(rename = "RelatedActiveContentsExist")]
        RelatedActiveContentsExist,
        #[serde(rename = "HTTPStatusNotOK")]
        HttpStatusNotOk,
        #[serde(rename = "SchemeNotHTTPOrHTTPS")]
        SchemeNotHttpOrHttps,
        #[serde(rename = "Loading")]
        Loading,
        #[serde(rename = "WasGrantedMediaAccess")]
        WasGrantedMediaAccess,
        #[serde(rename = "DisableForRenderFrameHostCalled")]
        DisableForRenderFrameHostCalled,
        #[serde(rename = "DomainNotAllowed")]
        DomainNotAllowed,
        #[serde(rename = "HTTPMethodNotGET")]
        HttpMethodNotGet,
        #[serde(rename = "SubframeIsNavigating")]
        SubframeIsNavigating,
        #[serde(rename = "Timeout")]
        Timeout,
        #[serde(rename = "CacheLimit")]
        CacheLimit,
        #[serde(rename = "JavaScriptExecution")]
        JavaScriptExecution,
        #[serde(rename = "RendererProcessKilled")]
        RendererProcessKilled,
        #[serde(rename = "RendererProcessCrashed")]
        RendererProcessCrashed,
        #[serde(rename = "SchedulerTrackedFeatureUsed")]
        SchedulerTrackedFeatureUsed,
        #[serde(rename = "ConflictingBrowsingInstance")]
        ConflictingBrowsingInstance,
        #[serde(rename = "CacheFlushed")]
        CacheFlushed,
        #[serde(rename = "ServiceWorkerVersionActivation")]
        ServiceWorkerVersionActivation,
        #[serde(rename = "SessionRestored")]
        SessionRestored,
        #[serde(rename = "ServiceWorkerPostMessage")]
        ServiceWorkerPostMessage,
        #[serde(rename = "EnteredBackForwardCacheBeforeServiceWorkerHostAdded")]
        EnteredBackForwardCacheBeforeServiceWorkerHostAdded,
        #[serde(rename = "RenderFrameHostReused_SameSite")]
        RenderFrameHostReusedSameSite,
        #[serde(rename = "RenderFrameHostReused_CrossSite")]
        RenderFrameHostReusedCrossSite,
        #[serde(rename = "ServiceWorkerClaim")]
        ServiceWorkerClaim,
        #[serde(rename = "IgnoreEventAndEvict")]
        IgnoreEventAndEvict,
        #[serde(rename = "HaveInnerContents")]
        HaveInnerContents,
        #[serde(rename = "TimeoutPuttingInCache")]
        TimeoutPuttingInCache,
        #[serde(rename = "BackForwardCacheDisabledByLowMemory")]
        BackForwardCacheDisabledByLowMemory,
        #[serde(rename = "BackForwardCacheDisabledByCommandLine")]
        BackForwardCacheDisabledByCommandLine,
        #[serde(rename = "NetworkRequestDatapipeDrainedAsBytesConsumer")]
        NetworkRequestDatapipeDrainedAsBytesConsumer,
        #[serde(rename = "NetworkRequestRedirected")]
        NetworkRequestRedirected,
        #[serde(rename = "NetworkRequestTimeout")]
        NetworkRequestTimeout,
        #[serde(rename = "NetworkExceedsBufferLimit")]
        NetworkExceedsBufferLimit,
        #[serde(rename = "NavigationCancelledWhileRestoring")]
        NavigationCancelledWhileRestoring,
        #[serde(rename = "NotMostRecentNavigationEntry")]
        NotMostRecentNavigationEntry,
        #[serde(rename = "BackForwardCacheDisabledForPrerender")]
        BackForwardCacheDisabledForPrerender,
        #[serde(rename = "UserAgentOverrideDiffers")]
        UserAgentOverrideDiffers,
        #[serde(rename = "ForegroundCacheLimit")]
        ForegroundCacheLimit,
        #[serde(rename = "BrowsingInstanceNotSwapped")]
        BrowsingInstanceNotSwapped,
        #[serde(rename = "BackForwardCacheDisabledForDelegate")]
        BackForwardCacheDisabledForDelegate,
        #[serde(rename = "UnloadHandlerExistsInMainFrame")]
        UnloadHandlerExistsInMainFrame,
        #[serde(rename = "UnloadHandlerExistsInSubFrame")]
        UnloadHandlerExistsInSubFrame,
        #[serde(rename = "ServiceWorkerUnregistration")]
        ServiceWorkerUnregistration,
        #[serde(rename = "CacheControlNoStore")]
        CacheControlNoStore,
        #[serde(rename = "CacheControlNoStoreCookieModified")]
        CacheControlNoStoreCookieModified,
        #[serde(rename = "CacheControlNoStoreHTTPOnlyCookieModified")]
        CacheControlNoStoreHttpOnlyCookieModified,
        #[serde(rename = "NoResponseHead")]
        NoResponseHead,
        #[serde(rename = "Unknown")]
        Unknown,
        #[serde(rename = "ActivationNavigationsDisallowedForBug1234857")]
        ActivationNavigationsDisallowedForBug1234857,
        #[serde(rename = "ErrorDocument")]
        ErrorDocument,
        #[serde(rename = "FencedFramesEmbedder")]
        FencedFramesEmbedder,
        #[serde(rename = "CookieDisabled")]
        CookieDisabled,
        #[serde(rename = "HTTPAuthRequired")]
        HttpAuthRequired,
        #[serde(rename = "CookieFlushed")]
        CookieFlushed,
        #[serde(rename = "WebSocket")]
        WebSocket,
        #[serde(rename = "WebTransport")]
        WebTransport,
        #[serde(rename = "WebRTC")]
        WebRtc,
        #[serde(rename = "MainResourceHasCacheControlNoStore")]
        MainResourceHasCacheControlNoStore,
        #[serde(rename = "MainResourceHasCacheControlNoCache")]
        MainResourceHasCacheControlNoCache,
        #[serde(rename = "SubresourceHasCacheControlNoStore")]
        SubresourceHasCacheControlNoStore,
        #[serde(rename = "SubresourceHasCacheControlNoCache")]
        SubresourceHasCacheControlNoCache,
        #[serde(rename = "ContainsPlugins")]
        ContainsPlugins,
        #[serde(rename = "DocumentLoaded")]
        DocumentLoaded,
        #[serde(rename = "DedicatedWorkerOrWorklet")]
        DedicatedWorkerOrWorklet,
        #[serde(rename = "OutstandingNetworkRequestOthers")]
        OutstandingNetworkRequestOthers,
        #[serde(rename = "RequestedMIDIPermission")]
        RequestedMidiPermission,
        #[serde(rename = "RequestedAudioCapturePermission")]
        RequestedAudioCapturePermission,
        #[serde(rename = "RequestedVideoCapturePermission")]
        RequestedVideoCapturePermission,
        #[serde(rename = "RequestedBackForwardCacheBlockedSensors")]
        RequestedBackForwardCacheBlockedSensors,
        #[serde(rename = "RequestedBackgroundWorkPermission")]
        RequestedBackgroundWorkPermission,
        #[serde(rename = "BroadcastChannel")]
        BroadcastChannel,
        #[serde(rename = "WebXR")]
        WebXr,
        #[serde(rename = "SharedWorker")]
        SharedWorker,
        #[serde(rename = "WebLocks")]
        WebLocks,
        #[serde(rename = "WebHID")]
        WebHid,
        #[serde(rename = "WebShare")]
        WebShare,
        #[serde(rename = "RequestedStorageAccessGrant")]
        RequestedStorageAccessGrant,
        #[serde(rename = "WebNfc")]
        WebNfc,
        #[serde(rename = "OutstandingNetworkRequestFetch")]
        OutstandingNetworkRequestFetch,
        #[serde(rename = "OutstandingNetworkRequestXHR")]
        OutstandingNetworkRequestXhr,
        #[serde(rename = "AppBanner")]
        AppBanner,
        #[serde(rename = "Printing")]
        Printing,
        #[serde(rename = "WebDatabase")]
        WebDatabase,
        #[serde(rename = "PictureInPicture")]
        PictureInPicture,
        #[serde(rename = "Portal")]
        Portal,
        #[serde(rename = "SpeechRecognizer")]
        SpeechRecognizer,
        #[serde(rename = "IdleManager")]
        IdleManager,
        #[serde(rename = "PaymentManager")]
        PaymentManager,
        #[serde(rename = "SpeechSynthesis")]
        SpeechSynthesis,
        #[serde(rename = "KeyboardLock")]
        KeyboardLock,
        #[serde(rename = "WebOTPService")]
        WebOtpService,
        #[serde(rename = "OutstandingNetworkRequestDirectSocket")]
        OutstandingNetworkRequestDirectSocket,
        #[serde(rename = "InjectedJavascript")]
        InjectedJavascript,
        #[serde(rename = "InjectedStyleSheet")]
        InjectedStyleSheet,
        #[serde(rename = "KeepaliveRequest")]
        KeepaliveRequest,
        #[serde(rename = "IndexedDBEvent")]
        IndexedDbEvent,
        #[serde(rename = "Dummy")]
        Dummy,
        #[serde(rename = "JsNetworkRequestReceivedCacheControlNoStoreResource")]
        JsNetworkRequestReceivedCacheControlNoStoreResource,
        #[serde(rename = "WebRTCSticky")]
        WebRtcSticky,
        #[serde(rename = "WebTransportSticky")]
        WebTransportSticky,
        #[serde(rename = "WebSocketSticky")]
        WebSocketSticky,
        #[serde(rename = "ContentSecurityHandler")]
        ContentSecurityHandler,
        #[serde(rename = "ContentWebAuthenticationAPI")]
        ContentWebAuthenticationApi,
        #[serde(rename = "ContentFileChooser")]
        ContentFileChooser,
        #[serde(rename = "ContentSerial")]
        ContentSerial,
        #[serde(rename = "ContentFileSystemAccess")]
        ContentFileSystemAccess,
        #[serde(rename = "ContentMediaDevicesDispatcherHost")]
        ContentMediaDevicesDispatcherHost,
        #[serde(rename = "ContentWebBluetooth")]
        ContentWebBluetooth,
        #[serde(rename = "ContentWebUSB")]
        ContentWebUsb,
        #[serde(rename = "ContentMediaSessionService")]
        ContentMediaSessionService,
        #[serde(rename = "ContentScreenReader")]
        ContentScreenReader,
        #[serde(rename = "EmbedderPopupBlockerTabHelper")]
        EmbedderPopupBlockerTabHelper,
        #[serde(rename = "EmbedderSafeBrowsingTriggeredPopupBlocker")]
        EmbedderSafeBrowsingTriggeredPopupBlocker,
        #[serde(rename = "EmbedderSafeBrowsingThreatDetails")]
        EmbedderSafeBrowsingThreatDetails,
        #[serde(rename = "EmbedderAppBannerManager")]
        EmbedderAppBannerManager,
        #[serde(rename = "EmbedderDomDistillerViewerSource")]
        EmbedderDomDistillerViewerSource,
        #[serde(rename = "EmbedderDomDistillerSelfDeletingRequestDelegate")]
        EmbedderDomDistillerSelfDeletingRequestDelegate,
        #[serde(rename = "EmbedderOomInterventionTabHelper")]
        EmbedderOomInterventionTabHelper,
        #[serde(rename = "EmbedderOfflinePage")]
        EmbedderOfflinePage,
        #[serde(rename = "EmbedderChromePasswordManagerClientBindCredentialManager")]
        EmbedderChromePasswordManagerClientBindCredentialManager,
        #[serde(rename = "EmbedderPermissionRequestManager")]
        EmbedderPermissionRequestManager,
        #[serde(rename = "EmbedderModalDialog")]
        EmbedderModalDialog,
        #[serde(rename = "EmbedderExtensions")]
        EmbedderExtensions,
        #[serde(rename = "EmbedderExtensionMessaging")]
        EmbedderExtensionMessaging,
        #[serde(rename = "EmbedderExtensionMessagingForOpenPort")]
        EmbedderExtensionMessagingForOpenPort,
        #[serde(rename = "EmbedderExtensionSentMessageToCachedFrame")]
        EmbedderExtensionSentMessageToCachedFrame,
    }
    ///Types of not restored reasons for back-forward cache.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum BackForwardCacheNotRestoredReasonType {
        #[serde(rename = "SupportPending")]
        SupportPending,
        #[serde(rename = "PageSupportNeeded")]
        PageSupportNeeded,
        #[serde(rename = "Circumstantial")]
        Circumstantial,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BackForwardCacheNotRestoredExplanation {
        ///Type of the reason
        #[serde(rename = "type")]
        pub type_: BackForwardCacheNotRestoredReasonType,
        ///Not restored reason
        #[serde(rename = "reason")]
        pub reason: BackForwardCacheNotRestoredReason,
        ///Context associated with the reason. The meaning of this context is
        ///dependent on the reason:
        ///- EmbedderExtensionSentMessageToCachedFrame: the extension ID.
        #[serde(rename = "context")]
        pub context: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BackForwardCacheNotRestoredExplanationTree {
        ///URL of each frame
        #[serde(rename = "url")]
        pub url: String,
        ///Not restored reasons of each frame
        #[serde(rename = "explanations")]
        pub explanations: Vec<BackForwardCacheNotRestoredExplanation>,
        ///Array of children frame
        #[serde(rename = "children")]
        pub children: Vec<BackForwardCacheNotRestoredExplanationTree>,
    }
    ///
    /// Parameter value for [AddScriptToEvaluateOnLoad].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddScriptToEvaluateOnLoadParams {
        #[serde(rename = "scriptSource")]
        pub script_source: String,
    }
    ///
    /// Return value for [AddScriptToEvaluateOnLoad].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddScriptToEvaluateOnLoadReturns {
        ///Identifier of the added script.
        #[serde(rename = "identifier")]
        pub identifier: ScriptIdentifier,
    }
    ///Deprecated, please use addScriptToEvaluateOnNewDocument instead.
    ///---
    ///Parameter Type: [AddScriptToEvaluateOnLoadParams]
    ///Return Type: [AddScriptToEvaluateOnLoadReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddScriptToEvaluateOnLoad;
    impl crate::util::Command for AddScriptToEvaluateOnLoad {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addScriptToEvaluateOnLoad"
        }
    }
    ///
    /// Parameter value for [AddScriptToEvaluateOnNewDocument].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddScriptToEvaluateOnNewDocumentParams {
        #[serde(rename = "source")]
        pub source: String,
        ///If specified, creates an isolated world with the given name and evaluates given script in it.
        ///This world name will be used as the ExecutionContextDescription::name when the corresponding
        ///event is emitted.
        #[serde(rename = "worldName")]
        pub world_name: Option<String>,
        ///Specifies whether command line API should be available to the script, defaults
        ///to false.
        #[serde(rename = "includeCommandLineAPI")]
        pub include_command_line_api: Option<bool>,
        ///If true, runs the script immediately on existing execution contexts or worlds.
        ///Default: false.
        #[serde(rename = "runImmediately")]
        pub run_immediately: Option<bool>,
    }
    ///
    /// Return value for [AddScriptToEvaluateOnNewDocument].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddScriptToEvaluateOnNewDocumentReturns {
        ///Identifier of the added script.
        #[serde(rename = "identifier")]
        pub identifier: ScriptIdentifier,
    }
    ///Evaluates given script in every frame upon creation (before loading frame's scripts).
    ///---
    ///Parameter Type: [AddScriptToEvaluateOnNewDocumentParams]
    ///Return Type: [AddScriptToEvaluateOnNewDocumentReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddScriptToEvaluateOnNewDocument;
    impl crate::util::Command for AddScriptToEvaluateOnNewDocument {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addScriptToEvaluateOnNewDocument"
        }
    }
    ///Brings page to front (activates tab).
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BringToFront;
    impl crate::util::Command for BringToFront {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "bringToFront"
        }
    }
    ///
    /// Enum for [CaptureScreenshot]'s `format`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CaptureScreenshotFormat {
        #[serde(rename = "jpeg")]
        Jpeg,
        #[serde(rename = "png")]
        Png,
        #[serde(rename = "webp")]
        Webp,
    }
    ///
    /// Parameter value for [CaptureScreenshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureScreenshotParams {
        ///Image compression format (defaults to png).
        #[serde(rename = "format")]
        pub format: Option<Option<CaptureScreenshotFormat>>,
        ///Compression quality from range [0..100] (jpeg only).
        #[serde(rename = "quality")]
        pub quality: Option<i64>,
        ///Capture the screenshot of a given region only.
        #[serde(rename = "clip")]
        pub clip: Option<Viewport>,
        ///Capture the screenshot from the surface, rather than the view. Defaults to true.
        #[serde(rename = "fromSurface")]
        pub from_surface: Option<bool>,
        ///Capture the screenshot beyond the viewport. Defaults to false.
        #[serde(rename = "captureBeyondViewport")]
        pub capture_beyond_viewport: Option<bool>,
        ///Optimize image encoding for speed, not for resulting size (defaults to false)
        #[serde(rename = "optimizeForSpeed")]
        pub optimize_for_speed: Option<bool>,
    }
    ///
    /// Return value for [CaptureScreenshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureScreenshotReturns {
        ///Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "data")]
        pub data: String,
    }
    ///Capture page screenshot.
    ///---
    ///Parameter Type: [CaptureScreenshotParams]
    ///Return Type: [CaptureScreenshotReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureScreenshot;
    impl crate::util::Command for CaptureScreenshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "captureScreenshot"
        }
    }
    ///
    /// Enum for [CaptureSnapshot]'s `format`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CaptureSnapshotFormat {
        #[serde(rename = "mhtml")]
        Mhtml,
    }
    ///
    /// Parameter value for [CaptureSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureSnapshotParams {
        ///Format (defaults to mhtml).
        #[serde(rename = "format")]
        pub format: Option<Option<CaptureSnapshotFormat>>,
    }
    ///
    /// Return value for [CaptureSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureSnapshotReturns {
        ///Serialized page data.
        #[serde(rename = "data")]
        pub data: String,
    }
    ///Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    ///iframes, shadow DOM, external resources, and element-inline styles.
    ///---
    ///Parameter Type: [CaptureSnapshotParams]
    ///Return Type: [CaptureSnapshotReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CaptureSnapshot;
    impl crate::util::Command for CaptureSnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "captureSnapshot"
        }
    }
    ///Clears the overridden device metrics.
    ///---
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearDeviceMetricsOverride;
    impl crate::util::Command for ClearDeviceMetricsOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearDeviceMetricsOverride"
        }
    }
    ///Clears the overridden Device Orientation.
    ///---
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearDeviceOrientationOverride;
    impl crate::util::Command for ClearDeviceOrientationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearDeviceOrientationOverride"
        }
    }
    ///Clears the overridden Geolocation Position and Error.
    ///---
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearGeolocationOverride;
    impl crate::util::Command for ClearGeolocationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearGeolocationOverride"
        }
    }
    ///
    /// Parameter value for [CreateIsolatedWorld].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateIsolatedWorldParams {
        ///Id of the frame in which the isolated world should be created.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///An optional name which is reported in the Execution Context.
        #[serde(rename = "worldName")]
        pub world_name: Option<String>,
        ///Whether or not universal access should be granted to the isolated world. This is a powerful
        ///option, use with caution.
        #[serde(rename = "grantUniveralAccess")]
        pub grant_univeral_access: Option<bool>,
    }
    ///
    /// Return value for [CreateIsolatedWorld].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateIsolatedWorldReturns {
        ///Execution context of the isolated world.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: crate::protocol_test::runtime::ExecutionContextId,
    }
    ///Creates an isolated world for the given frame.
    ///---
    ///Parameter Type: [CreateIsolatedWorldParams]
    ///Return Type: [CreateIsolatedWorldReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateIsolatedWorld;
    impl crate::util::Command for CreateIsolatedWorld {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "createIsolatedWorld"
        }
    }
    ///
    /// Parameter value for [DeleteCookie].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteCookieParams {
        ///Name of the cookie to remove.
        #[serde(rename = "cookieName")]
        pub cookie_name: String,
        ///URL to match cooke domain and path.
        #[serde(rename = "url")]
        pub url: String,
    }
    ///Deletes browser cookie with given name, domain and path.
    ///---
    ///Parameter Type: [DeleteCookieParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteCookie;
    impl crate::util::Command for DeleteCookie {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deleteCookie"
        }
    }
    ///Disables page domain notifications.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables page domain notifications.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Return value for [GetAppManifest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAppManifestReturns {
        ///Manifest location.
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "errors")]
        pub errors: Vec<AppManifestError>,
        ///Manifest content.
        #[serde(rename = "data")]
        pub data: Option<String>,
        ///Parsed manifest properties
        #[serde(rename = "parsed")]
        pub parsed: Option<AppManifestParsedProperties>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAppManifest;
    impl crate::util::Command for GetAppManifest {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getAppManifest"
        }
    }
    ///
    /// Return value for [GetInstallabilityErrors].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInstallabilityErrorsReturns {
        #[serde(rename = "installabilityErrors")]
        pub installability_errors: Vec<InstallabilityError>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInstallabilityErrors;
    impl crate::util::Command for GetInstallabilityErrors {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getInstallabilityErrors"
        }
    }
    ///
    /// Return value for [GetManifestIcons].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetManifestIconsReturns {
        #[serde(rename = "primaryIcon")]
        pub primary_icon: Option<String>,
    }
    ///Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.
    ///---
    ///Return Type: [GetManifestIconsReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetManifestIcons;
    impl crate::util::Command for GetManifestIcons {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getManifestIcons"
        }
    }
    ///
    /// Return value for [GetAppId].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAppIdReturns {
        ///App id, either from manifest's id attribute or computed from start_url
        #[serde(rename = "appId")]
        pub app_id: Option<String>,
        ///Recommendation for manifest's id attribute to match current id computed from start_url
        #[serde(rename = "recommendedId")]
        pub recommended_id: Option<String>,
    }
    ///Returns the unique (PWA) app id.
    ///Only returns values if the feature flag 'WebAppEnableManifestId' is enabled
    ///---
    ///Return Type: [GetAppIdReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAppId;
    impl crate::util::Command for GetAppId {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getAppId"
        }
    }
    ///
    /// Parameter value for [GetAdScriptId].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAdScriptIdParams {
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }
    ///
    /// Return value for [GetAdScriptId].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAdScriptIdReturns {
        ///Identifies the bottom-most script which caused the frame to be labelled
        ///as an ad. Only sent if frame is labelled as an ad and id is available.
        #[serde(rename = "adScriptId")]
        pub ad_script_id: Option<AdScriptId>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetAdScriptId;
    impl crate::util::Command for GetAdScriptId {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getAdScriptId"
        }
    }
    ///
    /// Return value for [GetCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCookiesReturns {
        ///Array of cookie objects.
        #[serde(rename = "cookies")]
        pub cookies: Vec<crate::protocol_test::network::Cookie>,
    }
    ///Returns all browser cookies for the page and all of its subframes. Depending
    ///on the backend support, will return detailed cookie information in the
    ///`cookies` field.
    ///---
    ///Return Type: [GetCookiesReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCookies;
    impl crate::util::Command for GetCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getCookies"
        }
    }
    ///
    /// Return value for [GetFrameTree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFrameTreeReturns {
        ///Present frame tree structure.
        #[serde(rename = "frameTree")]
        pub frame_tree: FrameTree,
    }
    ///Returns present frame tree structure.
    ///---
    ///Return Type: [GetFrameTreeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFrameTree;
    impl crate::util::Command for GetFrameTree {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getFrameTree"
        }
    }
    ///
    /// Return value for [GetLayoutMetrics].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetLayoutMetricsReturns {
        ///Deprecated metrics relating to the layout viewport. Is in device pixels. Use `cssLayoutViewport` instead.
        #[deprecated]
        #[serde(rename = "layoutViewport")]
        pub layout_viewport: LayoutViewport,
        ///Deprecated metrics relating to the visual viewport. Is in device pixels. Use `cssVisualViewport` instead.
        #[deprecated]
        #[serde(rename = "visualViewport")]
        pub visual_viewport: VisualViewport,
        ///Deprecated size of scrollable area. Is in DP. Use `cssContentSize` instead.
        #[deprecated]
        #[serde(rename = "contentSize")]
        pub content_size: crate::protocol_test::dom::Rect,
        ///Metrics relating to the layout viewport in CSS pixels.
        #[serde(rename = "cssLayoutViewport")]
        pub css_layout_viewport: LayoutViewport,
        ///Metrics relating to the visual viewport in CSS pixels.
        #[serde(rename = "cssVisualViewport")]
        pub css_visual_viewport: VisualViewport,
        ///Size of scrollable area in CSS pixels.
        #[serde(rename = "cssContentSize")]
        pub css_content_size: crate::protocol_test::dom::Rect,
    }
    ///Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
    ///---
    ///Return Type: [GetLayoutMetricsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetLayoutMetrics;
    impl crate::util::Command for GetLayoutMetrics {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getLayoutMetrics"
        }
    }
    ///
    /// Return value for [GetNavigationHistory].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNavigationHistoryReturns {
        ///Index of the current navigation history entry.
        #[serde(rename = "currentIndex")]
        pub current_index: i64,
        ///Array of navigation history entries.
        #[serde(rename = "entries")]
        pub entries: Vec<NavigationEntry>,
    }
    ///Returns navigation history for the current page.
    ///---
    ///Return Type: [GetNavigationHistoryReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetNavigationHistory;
    impl crate::util::Command for GetNavigationHistory {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getNavigationHistory"
        }
    }
    ///Resets navigation history for the current page.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResetNavigationHistory;
    impl crate::util::Command for ResetNavigationHistory {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resetNavigationHistory"
        }
    }
    ///
    /// Parameter value for [GetResourceContent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResourceContentParams {
        ///Frame id to get resource for.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///URL of the resource to get content for.
        #[serde(rename = "url")]
        pub url: String,
    }
    ///
    /// Return value for [GetResourceContent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResourceContentReturns {
        ///Resource content.
        #[serde(rename = "content")]
        pub content: String,
        ///True, if content was served as base64.
        #[serde(rename = "base64Encoded")]
        pub base_64_encoded: bool,
    }
    ///Returns content of the given resource.
    ///---
    ///Parameter Type: [GetResourceContentParams]
    ///Return Type: [GetResourceContentReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResourceContent;
    impl crate::util::Command for GetResourceContent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getResourceContent"
        }
    }
    ///
    /// Return value for [GetResourceTree].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResourceTreeReturns {
        ///Present frame / resource tree structure.
        #[serde(rename = "frameTree")]
        pub frame_tree: FrameResourceTree,
    }
    ///Returns present frame / resource tree structure.
    ///---
    ///Return Type: [GetResourceTreeReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResourceTree;
    impl crate::util::Command for GetResourceTree {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getResourceTree"
        }
    }
    ///
    /// Parameter value for [HandleJavaScriptDialog].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HandleJavaScriptDialogParams {
        ///Whether to accept or dismiss the dialog.
        #[serde(rename = "accept")]
        pub accept: bool,
        ///The text to enter into the dialog prompt before accepting. Used only if this is a prompt
        ///dialog.
        #[serde(rename = "promptText")]
        pub prompt_text: Option<String>,
    }
    ///Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
    ///---
    ///Parameter Type: [HandleJavaScriptDialogParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HandleJavaScriptDialog;
    impl crate::util::Command for HandleJavaScriptDialog {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "handleJavaScriptDialog"
        }
    }
    ///
    /// Parameter value for [Navigate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NavigateParams {
        ///URL to navigate the page to.
        #[serde(rename = "url")]
        pub url: String,
        ///Referrer URL.
        #[serde(rename = "referrer")]
        pub referrer: Option<String>,
        ///Intended transition type.
        #[serde(rename = "transitionType")]
        pub transition_type: Option<TransitionType>,
        ///Frame id to navigate, if not specified navigates the top frame.
        #[serde(rename = "frameId")]
        pub frame_id: Option<FrameId>,
        ///Referrer-policy used for the navigation.
        #[serde(rename = "referrerPolicy")]
        pub referrer_policy: Option<ReferrerPolicy>,
    }
    ///
    /// Return value for [Navigate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NavigateReturns {
        ///Frame id that has navigated (or failed to navigate)
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///Loader identifier. This is omitted in case of same-document navigation,
        ///as the previously committed loaderId would not change.
        #[serde(rename = "loaderId")]
        pub loader_id: Option<crate::protocol_test::network::LoaderId>,
        ///User friendly error message, present if and only if navigation has failed.
        #[serde(rename = "errorText")]
        pub error_text: Option<String>,
    }
    ///Navigates current page to the given URL.
    ///---
    ///Parameter Type: [NavigateParams]
    ///Return Type: [NavigateReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Navigate;
    impl crate::util::Command for Navigate {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "navigate"
        }
    }
    ///
    /// Parameter value for [NavigateToHistoryEntry].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NavigateToHistoryEntryParams {
        ///Unique id of the entry to navigate to.
        #[serde(rename = "entryId")]
        pub entry_id: i64,
    }
    ///Navigates current page to the given history entry.
    ///---
    ///Parameter Type: [NavigateToHistoryEntryParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NavigateToHistoryEntry;
    impl crate::util::Command for NavigateToHistoryEntry {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "navigateToHistoryEntry"
        }
    }
    ///
    /// Enum for [PrintToPdf]'s `transfer_mode`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PrintToPdfTransferMode {
        #[serde(rename = "ReturnAsBase64")]
        ReturnAsBase64,
        #[serde(rename = "ReturnAsStream")]
        ReturnAsStream,
    }
    ///
    /// Parameter value for [PrintToPdf].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PrintToPdfParams {
        ///Paper orientation. Defaults to false.
        #[serde(rename = "landscape")]
        pub landscape: Option<bool>,
        ///Display header and footer. Defaults to false.
        #[serde(rename = "displayHeaderFooter")]
        pub display_header_footer: Option<bool>,
        ///Print background graphics. Defaults to false.
        #[serde(rename = "printBackground")]
        pub print_background: Option<bool>,
        ///Scale of the webpage rendering. Defaults to 1.
        #[serde(rename = "scale")]
        pub scale: Option<f64>,
        ///Paper width in inches. Defaults to 8.5 inches.
        #[serde(rename = "paperWidth")]
        pub paper_width: Option<f64>,
        ///Paper height in inches. Defaults to 11 inches.
        #[serde(rename = "paperHeight")]
        pub paper_height: Option<f64>,
        ///Top margin in inches. Defaults to 1cm (~0.4 inches).
        #[serde(rename = "marginTop")]
        pub margin_top: Option<f64>,
        ///Bottom margin in inches. Defaults to 1cm (~0.4 inches).
        #[serde(rename = "marginBottom")]
        pub margin_bottom: Option<f64>,
        ///Left margin in inches. Defaults to 1cm (~0.4 inches).
        #[serde(rename = "marginLeft")]
        pub margin_left: Option<f64>,
        ///Right margin in inches. Defaults to 1cm (~0.4 inches).
        #[serde(rename = "marginRight")]
        pub margin_right: Option<f64>,
        ///Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are
        ///printed in the document order, not in the order specified, and no
        ///more than once.
        ///Defaults to empty string, which implies the entire document is printed.
        ///The page numbers are quietly capped to actual page count of the
        ///document, and ranges beyond the end of the document are ignored.
        ///If this results in no pages to print, an error is reported.
        ///It is an error to specify a range with start greater than end.
        #[serde(rename = "pageRanges")]
        pub page_ranges: Option<String>,
        ///HTML template for the print header. Should be valid HTML markup with following
        ///classes used to inject printing values into them:
        ///- `date`: formatted print date
        ///- `title`: document title
        ///- `url`: document location
        ///- `pageNumber`: current page number
        ///- `totalPages`: total pages in the document
        ///
        ///For example, `<span class=title></span>` would generate span containing the title.
        #[serde(rename = "headerTemplate")]
        pub header_template: Option<String>,
        ///HTML template for the print footer. Should use the same format as the `headerTemplate`.
        #[serde(rename = "footerTemplate")]
        pub footer_template: Option<String>,
        ///Whether or not to prefer page size as defined by css. Defaults to false,
        ///in which case the content will be scaled to fit the paper size.
        #[serde(rename = "preferCSSPageSize")]
        pub prefer_css_page_size: Option<bool>,
        ///return as stream
        #[serde(rename = "transferMode")]
        pub transfer_mode: Option<Option<PrintToPdfTransferMode>>,
        ///Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
        #[serde(rename = "generateTaggedPDF")]
        pub generate_tagged_pdf: Option<bool>,
    }
    ///
    /// Return value for [PrintToPdf].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PrintToPdfReturns {
        ///Base64-encoded pdf data. Empty if |returnAsStream| is specified. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "data")]
        pub data: String,
        ///A handle of the stream that holds resulting PDF data.
        #[serde(rename = "stream")]
        pub stream: Option<crate::protocol_test::io::StreamHandle>,
    }
    ///Print page as PDF.
    ///---
    ///Parameter Type: [PrintToPdfParams]
    ///Return Type: [PrintToPdfReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PrintToPdf;
    impl crate::util::Command for PrintToPdf {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "printToPDF"
        }
    }
    ///
    /// Parameter value for [Reload].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReloadParams {
        ///If true, browser cache is ignored (as if the user pressed Shift+refresh).
        #[serde(rename = "ignoreCache")]
        pub ignore_cache: Option<bool>,
        ///If set, the script will be injected into all frames of the inspected page after reload.
        ///Argument will be ignored if reloading dataURL origin.
        #[serde(rename = "scriptToEvaluateOnLoad")]
        pub script_to_evaluate_on_load: Option<String>,
    }
    ///Reloads given page optionally ignoring the cache.
    ///---
    ///Parameter Type: [ReloadParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Reload;
    impl crate::util::Command for Reload {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "reload"
        }
    }
    ///
    /// Parameter value for [RemoveScriptToEvaluateOnLoad].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveScriptToEvaluateOnLoadParams {
        #[serde(rename = "identifier")]
        pub identifier: ScriptIdentifier,
    }
    ///Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
    ///---
    ///Parameter Type: [RemoveScriptToEvaluateOnLoadParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveScriptToEvaluateOnLoad;
    impl crate::util::Command for RemoveScriptToEvaluateOnLoad {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeScriptToEvaluateOnLoad"
        }
    }
    ///
    /// Parameter value for [RemoveScriptToEvaluateOnNewDocument].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveScriptToEvaluateOnNewDocumentParams {
        #[serde(rename = "identifier")]
        pub identifier: ScriptIdentifier,
    }
    ///Removes given script from the list.
    ///---
    ///Parameter Type: [RemoveScriptToEvaluateOnNewDocumentParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveScriptToEvaluateOnNewDocument;
    impl crate::util::Command for RemoveScriptToEvaluateOnNewDocument {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeScriptToEvaluateOnNewDocument"
        }
    }
    ///
    /// Parameter value for [ScreencastFrameAck].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScreencastFrameAckParams {
        ///Frame number.
        #[serde(rename = "sessionId")]
        pub session_id: i64,
    }
    ///Acknowledges that a screencast frame has been received by the frontend.
    ///---
    ///Parameter Type: [ScreencastFrameAckParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScreencastFrameAck;
    impl crate::util::Command for ScreencastFrameAck {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "screencastFrameAck"
        }
    }
    ///
    /// Parameter value for [SearchInResource].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInResourceParams {
        ///Frame id for resource to search in.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///URL of the resource to search in.
        #[serde(rename = "url")]
        pub url: String,
        ///String to search for.
        #[serde(rename = "query")]
        pub query: String,
        ///If true, search is case sensitive.
        #[serde(rename = "caseSensitive")]
        pub case_sensitive: Option<bool>,
        ///If true, treats string parameter as regex.
        #[serde(rename = "isRegex")]
        pub is_regex: Option<bool>,
    }
    ///
    /// Return value for [SearchInResource].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInResourceReturns {
        ///List of search matches.
        #[serde(rename = "result")]
        pub result: Vec<crate::protocol_test::debugger::SearchMatch>,
    }
    ///Searches for given string in resource content.
    ///---
    ///Parameter Type: [SearchInResourceParams]
    ///Return Type: [SearchInResourceReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInResource;
    impl crate::util::Command for SearchInResource {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "searchInResource"
        }
    }
    ///
    /// Parameter value for [SetAdBlockingEnabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAdBlockingEnabledParams {
        ///Whether to block ads.
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Enable Chrome's experimental ad filter on all sites.
    ///---
    ///Parameter Type: [SetAdBlockingEnabledParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAdBlockingEnabled;
    impl crate::util::Command for SetAdBlockingEnabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAdBlockingEnabled"
        }
    }
    ///
    /// Parameter value for [SetBypassCsp].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBypassCspParams {
        ///Whether to bypass page CSP.
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Enable page Content Security Policy by-passing.
    ///---
    ///Parameter Type: [SetBypassCspParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBypassCsp;
    impl crate::util::Command for SetBypassCsp {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBypassCSP"
        }
    }
    ///
    /// Parameter value for [GetPermissionsPolicyState].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPermissionsPolicyStateParams {
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }
    ///
    /// Return value for [GetPermissionsPolicyState].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPermissionsPolicyStateReturns {
        #[serde(rename = "states")]
        pub states: Vec<PermissionsPolicyFeatureState>,
    }
    ///Get Permissions Policy state on given frame.
    ///---
    ///Parameter Type: [GetPermissionsPolicyStateParams]
    ///Return Type: [GetPermissionsPolicyStateReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPermissionsPolicyState;
    impl crate::util::Command for GetPermissionsPolicyState {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getPermissionsPolicyState"
        }
    }
    ///
    /// Parameter value for [GetOriginTrials].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetOriginTrialsParams {
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }
    ///
    /// Return value for [GetOriginTrials].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetOriginTrialsReturns {
        #[serde(rename = "originTrials")]
        pub origin_trials: Vec<OriginTrial>,
    }
    ///Get Origin Trials on given frame.
    ///---
    ///Parameter Type: [GetOriginTrialsParams]
    ///Return Type: [GetOriginTrialsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetOriginTrials;
    impl crate::util::Command for GetOriginTrials {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getOriginTrials"
        }
    }
    ///
    /// Parameter value for [SetDeviceMetricsOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDeviceMetricsOverrideParams {
        ///Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
        #[serde(rename = "width")]
        pub width: i64,
        ///Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
        #[serde(rename = "height")]
        pub height: i64,
        ///Overriding device scale factor value. 0 disables the override.
        #[serde(rename = "deviceScaleFactor")]
        pub device_scale_factor: f64,
        ///Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
        ///autosizing and more.
        #[serde(rename = "mobile")]
        pub mobile: bool,
        ///Scale to apply to resulting view image.
        #[serde(rename = "scale")]
        pub scale: Option<f64>,
        ///Overriding screen width value in pixels (minimum 0, maximum 10000000).
        #[serde(rename = "screenWidth")]
        pub screen_width: Option<i64>,
        ///Overriding screen height value in pixels (minimum 0, maximum 10000000).
        #[serde(rename = "screenHeight")]
        pub screen_height: Option<i64>,
        ///Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
        #[serde(rename = "positionX")]
        pub position_x: Option<i64>,
        ///Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
        #[serde(rename = "positionY")]
        pub position_y: Option<i64>,
        ///Do not set visible view size, rely upon explicit setVisibleSize call.
        #[serde(rename = "dontSetVisibleSize")]
        pub dont_set_visible_size: Option<bool>,
        ///Screen orientation override.
        #[serde(rename = "screenOrientation")]
        pub screen_orientation: Option<
            crate::protocol_test::emulation::ScreenOrientation,
        >,
        ///The viewport dimensions and scale. If not set, the override is cleared.
        #[serde(rename = "viewport")]
        pub viewport: Option<Viewport>,
    }
    ///Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    ///window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    ///query results).
    ///---
    ///Parameter Type: [SetDeviceMetricsOverrideParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDeviceMetricsOverride;
    impl crate::util::Command for SetDeviceMetricsOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDeviceMetricsOverride"
        }
    }
    ///
    /// Parameter value for [SetDeviceOrientationOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDeviceOrientationOverrideParams {
        ///Mock alpha
        #[serde(rename = "alpha")]
        pub alpha: f64,
        ///Mock beta
        #[serde(rename = "beta")]
        pub beta: f64,
        ///Mock gamma
        #[serde(rename = "gamma")]
        pub gamma: f64,
    }
    ///Overrides the Device Orientation.
    ///---
    ///Parameter Type: [SetDeviceOrientationOverrideParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDeviceOrientationOverride;
    impl crate::util::Command for SetDeviceOrientationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDeviceOrientationOverride"
        }
    }
    ///
    /// Parameter value for [SetFontFamilies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetFontFamiliesParams {
        ///Specifies font families to set. If a font family is not specified, it won't be changed.
        #[serde(rename = "fontFamilies")]
        pub font_families: FontFamilies,
        ///Specifies font families to set for individual scripts.
        #[serde(rename = "forScripts")]
        pub for_scripts: Option<Vec<ScriptFontFamilies>>,
    }
    ///Set generic font families.
    ///---
    ///Parameter Type: [SetFontFamiliesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetFontFamilies;
    impl crate::util::Command for SetFontFamilies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setFontFamilies"
        }
    }
    ///
    /// Parameter value for [SetFontSizes].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetFontSizesParams {
        ///Specifies font sizes to set. If a font size is not specified, it won't be changed.
        #[serde(rename = "fontSizes")]
        pub font_sizes: FontSizes,
    }
    ///Set default font sizes.
    ///---
    ///Parameter Type: [SetFontSizesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetFontSizes;
    impl crate::util::Command for SetFontSizes {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setFontSizes"
        }
    }
    ///
    /// Parameter value for [SetDocumentContent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDocumentContentParams {
        ///Frame id to set HTML for.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///HTML content to set.
        #[serde(rename = "html")]
        pub html: String,
    }
    ///Sets given markup as the document's HTML.
    ///---
    ///Parameter Type: [SetDocumentContentParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDocumentContent;
    impl crate::util::Command for SetDocumentContent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDocumentContent"
        }
    }
    ///
    /// Enum for [SetDownloadBehavior]'s `behavior`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetDownloadBehaviorBehavior {
        #[serde(rename = "deny")]
        Deny,
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "default")]
        Default,
    }
    ///
    /// Parameter value for [SetDownloadBehavior].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDownloadBehaviorParams {
        ///Whether to allow all or deny all download requests, or use default Chrome behavior if
        ///available (otherwise deny).
        #[serde(rename = "behavior")]
        pub behavior: SetDownloadBehaviorBehavior,
        ///The default path to save downloaded files to. This is required if behavior is set to 'allow'
        #[serde(rename = "downloadPath")]
        pub download_path: Option<String>,
    }
    ///Set the behavior when downloading a file.
    ///---
    ///Parameter Type: [SetDownloadBehaviorParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDownloadBehavior;
    impl crate::util::Command for SetDownloadBehavior {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDownloadBehavior"
        }
    }
    ///
    /// Parameter value for [SetGeolocationOverride].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetGeolocationOverrideParams {
        ///Mock latitude
        #[serde(rename = "latitude")]
        pub latitude: Option<f64>,
        ///Mock longitude
        #[serde(rename = "longitude")]
        pub longitude: Option<f64>,
        ///Mock accuracy
        #[serde(rename = "accuracy")]
        pub accuracy: Option<f64>,
    }
    ///Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    ///unavailable.
    ///---
    ///Parameter Type: [SetGeolocationOverrideParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetGeolocationOverride;
    impl crate::util::Command for SetGeolocationOverride {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setGeolocationOverride"
        }
    }
    ///
    /// Parameter value for [SetLifecycleEventsEnabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetLifecycleEventsEnabledParams {
        ///If true, starts emitting lifecycle events.
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Controls whether page will emit lifecycle events.
    ///---
    ///Parameter Type: [SetLifecycleEventsEnabledParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetLifecycleEventsEnabled;
    impl crate::util::Command for SetLifecycleEventsEnabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setLifecycleEventsEnabled"
        }
    }
    ///
    /// Enum for [SetTouchEmulationEnabled]'s `configuration`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetTouchEmulationEnabledConfiguration {
        #[serde(rename = "mobile")]
        Mobile,
        #[serde(rename = "desktop")]
        Desktop,
    }
    ///
    /// Parameter value for [SetTouchEmulationEnabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTouchEmulationEnabledParams {
        ///Whether the touch event emulation should be enabled.
        #[serde(rename = "enabled")]
        pub enabled: bool,
        ///Touch/gesture events configuration. Default: current platform.
        #[serde(rename = "configuration")]
        pub configuration: Option<Option<SetTouchEmulationEnabledConfiguration>>,
    }
    ///Toggles mouse event-based touch event emulation.
    ///---
    ///Parameter Type: [SetTouchEmulationEnabledParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTouchEmulationEnabled;
    impl crate::util::Command for SetTouchEmulationEnabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setTouchEmulationEnabled"
        }
    }
    ///
    /// Enum for [StartScreencast]'s `format`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum StartScreencastFormat {
        #[serde(rename = "jpeg")]
        Jpeg,
        #[serde(rename = "png")]
        Png,
    }
    ///
    /// Parameter value for [StartScreencast].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartScreencastParams {
        ///Image compression format.
        #[serde(rename = "format")]
        pub format: Option<Option<StartScreencastFormat>>,
        ///Compression quality from range [0..100].
        #[serde(rename = "quality")]
        pub quality: Option<i64>,
        ///Maximum screenshot width.
        #[serde(rename = "maxWidth")]
        pub max_width: Option<i64>,
        ///Maximum screenshot height.
        #[serde(rename = "maxHeight")]
        pub max_height: Option<i64>,
        ///Send every n-th frame.
        #[serde(rename = "everyNthFrame")]
        pub every_nth_frame: Option<i64>,
    }
    ///Starts sending each frame using the `screencastFrame` event.
    ///---
    ///Parameter Type: [StartScreencastParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartScreencast;
    impl crate::util::Command for StartScreencast {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startScreencast"
        }
    }
    ///Force the page stop all navigations and pending resource fetches.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopLoading;
    impl crate::util::Command for StopLoading {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopLoading"
        }
    }
    ///Crashes renderer on the IO thread, generates minidumps.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Crash;
    impl crate::util::Command for Crash {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "crash"
        }
    }
    ///Tries to close page, running its beforeunload hooks, if any.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Close;
    impl crate::util::Command for Close {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "close"
        }
    }
    ///
    /// Enum for [SetWebLifecycleState]'s `state`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetWebLifecycleStateState {
        #[serde(rename = "frozen")]
        Frozen,
        #[serde(rename = "active")]
        Active,
    }
    ///
    /// Parameter value for [SetWebLifecycleState].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetWebLifecycleStateParams {
        ///Target lifecycle state
        #[serde(rename = "state")]
        pub state: SetWebLifecycleStateState,
    }
    ///Tries to update the web lifecycle state of the page.
    ///It will transition the page to the given state according to:
    ///https://github.com/WICG/web-lifecycle/
    ///---
    ///Parameter Type: [SetWebLifecycleStateParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetWebLifecycleState;
    impl crate::util::Command for SetWebLifecycleState {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setWebLifecycleState"
        }
    }
    ///Stops sending each frame in the `screencastFrame`.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopScreencast;
    impl crate::util::Command for StopScreencast {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopScreencast"
        }
    }
    ///
    /// Parameter value for [ProduceCompilationCache].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ProduceCompilationCacheParams {
        #[serde(rename = "scripts")]
        pub scripts: Vec<CompilationCacheParams>,
    }
    ///Requests backend to produce compilation cache for the specified scripts.
    ///`scripts` are appeneded to the list of scripts for which the cache
    ///would be produced. The list may be reset during page navigation.
    ///When script with a matching URL is encountered, the cache is optionally
    ///produced upon backend discretion, based on internal heuristics.
    ///See also: `Page.compilationCacheProduced`.
    ///---
    ///Parameter Type: [ProduceCompilationCacheParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ProduceCompilationCache;
    impl crate::util::Command for ProduceCompilationCache {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "produceCompilationCache"
        }
    }
    ///
    /// Parameter value for [AddCompilationCache].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddCompilationCacheParams {
        #[serde(rename = "url")]
        pub url: String,
        ///Base64-encoded data (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "data")]
        pub data: String,
    }
    ///Seeds compilation cache for given url. Compilation cache does not survive
    ///cross-process navigation.
    ///---
    ///Parameter Type: [AddCompilationCacheParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddCompilationCache;
    impl crate::util::Command for AddCompilationCache {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addCompilationCache"
        }
    }
    ///Clears seeded compilation cache.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearCompilationCache;
    impl crate::util::Command for ClearCompilationCache {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearCompilationCache"
        }
    }
    ///
    /// Parameter value for [SetSpcTransactionMode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSpcTransactionModeParams {
        #[serde(rename = "mode")]
        pub mode: AutoResponseMode,
    }
    ///Sets the Secure Payment Confirmation transaction mode.
    ///https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
    ///---
    ///Parameter Type: [SetSpcTransactionModeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSpcTransactionMode;
    impl crate::util::Command for SetSpcTransactionMode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setSPCTransactionMode"
        }
    }
    ///
    /// Parameter value for [SetRphRegistrationMode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRphRegistrationModeParams {
        #[serde(rename = "mode")]
        pub mode: AutoResponseMode,
    }
    ///Extensions for Custom Handlers API:
    ///https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
    ///---
    ///Parameter Type: [SetRphRegistrationModeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRphRegistrationMode;
    impl crate::util::Command for SetRphRegistrationMode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setRPHRegistrationMode"
        }
    }
    ///
    /// Parameter value for [GenerateTestReport].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GenerateTestReportParams {
        ///Message to be displayed in the report.
        #[serde(rename = "message")]
        pub message: String,
        ///Specifies the endpoint group to deliver the report to.
        #[serde(rename = "group")]
        pub group: Option<String>,
    }
    ///Generates a report for testing.
    ///---
    ///Parameter Type: [GenerateTestReportParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GenerateTestReport;
    impl crate::util::Command for GenerateTestReport {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "generateTestReport"
        }
    }
    ///Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WaitForDebugger;
    impl crate::util::Command for WaitForDebugger {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "waitForDebugger"
        }
    }
    ///
    /// Parameter value for [SetInterceptFileChooserDialog].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInterceptFileChooserDialogParams {
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Intercept file chooser requests and transfer control to protocol clients.
    ///When file chooser interception is enabled, native file chooser dialog is not shown.
    ///Instead, a protocol event `Page.fileChooserOpened` is emitted.
    ///---
    ///Parameter Type: [SetInterceptFileChooserDialogParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInterceptFileChooserDialog;
    impl crate::util::Command for SetInterceptFileChooserDialog {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setInterceptFileChooserDialog"
        }
    }
    ///
    /// Parameter value for [SetPrerenderingAllowed].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPrerenderingAllowedParams {
        #[serde(rename = "isAllowed")]
        pub is_allowed: bool,
    }
    ///Enable/disable prerendering manually.
    ///
    ///This command is a short-term solution for https://crbug.com/1440085.
    ///See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    ///for more details.
    ///
    ///TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.
    ///---
    ///Parameter Type: [SetPrerenderingAllowedParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPrerenderingAllowed;
    impl crate::util::Command for SetPrerenderingAllowed {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setPrerenderingAllowed"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DomContentEventFiredEvent {
        #[serde(rename = "timestamp")]
        pub timestamp: crate::protocol_test::network::MonotonicTime,
    }
    ///
    /// Enum for [FileChooserOpenedEvent]'s `mode`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum FileChooserOpenedEventMode {
        #[serde(rename = "selectSingle")]
        SelectSingle,
        #[serde(rename = "selectMultiple")]
        SelectMultiple,
    }
    ///Emitted only when `page.interceptFileChooser` is enabled.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FileChooserOpenedEvent {
        ///Id of the frame containing input node.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///Input mode.
        #[serde(rename = "mode")]
        pub mode: FileChooserOpenedEventMode,
        ///Input node id. Only present for file choosers opened via an `<input type="file">` element.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
    }
    ///Fired when frame has been attached to its parent.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameAttachedEvent {
        ///Id of the frame that has been attached.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///Parent frame identifier.
        #[serde(rename = "parentFrameId")]
        pub parent_frame_id: FrameId,
        ///JavaScript stack trace of when frame was attached, only set if frame initiated from script.
        #[serde(rename = "stack")]
        pub stack: Option<crate::protocol_test::runtime::StackTrace>,
    }
    ///Fired when frame no longer has a scheduled navigation.
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameClearedScheduledNavigationEvent {
        ///Id of the frame that has cleared its scheduled navigation.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }
    ///
    /// Enum for [FrameDetachedEvent]'s `reason`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum FrameDetachedEventReason {
        #[serde(rename = "remove")]
        Remove,
        #[serde(rename = "swap")]
        Swap,
    }
    ///Fired when frame has been detached from its parent.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameDetachedEvent {
        ///Id of the frame that has been detached.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        #[serde(rename = "reason")]
        pub reason: FrameDetachedEventReason,
    }
    ///Fired once navigation of the frame has completed. Frame is now associated with the new loader.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameNavigatedEvent {
        ///Frame object.
        #[serde(rename = "frame")]
        pub frame: Frame,
        #[serde(rename = "type")]
        pub type_: NavigationType,
    }
    ///Fired when opening document to write to.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DocumentOpenedEvent {
        ///Frame object.
        #[serde(rename = "frame")]
        pub frame: Frame,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameResizedEvent {}
    ///Fired when a renderer-initiated navigation is requested.
    ///Navigation may still be cancelled after the event is issued.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameRequestedNavigationEvent {
        ///Id of the frame that is being navigated.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///The reason for the navigation.
        #[serde(rename = "reason")]
        pub reason: ClientNavigationReason,
        ///The destination URL for the requested navigation.
        #[serde(rename = "url")]
        pub url: String,
        ///The disposition for the navigation.
        #[serde(rename = "disposition")]
        pub disposition: ClientNavigationDisposition,
    }
    ///Fired when frame schedules a potential navigation.
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameScheduledNavigationEvent {
        ///Id of the frame that has scheduled a navigation.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///Delay (in seconds) until the navigation is scheduled to begin. The navigation is not
        ///guaranteed to start.
        #[serde(rename = "delay")]
        pub delay: f64,
        ///The reason for the navigation.
        #[serde(rename = "reason")]
        pub reason: ClientNavigationReason,
        ///The destination URL for the scheduled navigation.
        #[serde(rename = "url")]
        pub url: String,
    }
    ///Fired when frame has started loading.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameStartedLoadingEvent {
        ///Id of the frame that has started loading.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }
    ///Fired when frame has stopped loading.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FrameStoppedLoadingEvent {
        ///Id of the frame that has stopped loading.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }
    ///Fired when page is about to start a download.
    ///Deprecated. Use Browser.downloadWillBegin instead.
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DownloadWillBeginEvent {
        ///Id of the frame that caused download to begin.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///Global unique identifier of the download.
        #[serde(rename = "guid")]
        pub guid: String,
        ///URL of the resource being downloaded.
        #[serde(rename = "url")]
        pub url: String,
        ///Suggested file name of the resource (the actual name of the file saved on disk may differ).
        #[serde(rename = "suggestedFilename")]
        pub suggested_filename: String,
    }
    ///
    /// Enum for [DownloadProgressEvent]'s `state`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DownloadProgressEventState {
        #[serde(rename = "inProgress")]
        InProgress,
        #[serde(rename = "completed")]
        Completed,
        #[serde(rename = "canceled")]
        Canceled,
    }
    ///Fired when download makes progress. Last call has |done| == true.
    ///Deprecated. Use Browser.downloadProgress instead.
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DownloadProgressEvent {
        ///Global unique identifier of the download.
        #[serde(rename = "guid")]
        pub guid: String,
        ///Total expected bytes to download.
        #[serde(rename = "totalBytes")]
        pub total_bytes: f64,
        ///Total bytes received.
        #[serde(rename = "receivedBytes")]
        pub received_bytes: f64,
        ///Download status.
        #[serde(rename = "state")]
        pub state: DownloadProgressEventState,
    }
    ///Fired when interstitial page was hidden
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InterstitialHiddenEvent {}
    ///Fired when interstitial page was shown
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InterstitialShownEvent {}
    ///Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
    ///closed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct JavascriptDialogClosedEvent {
        ///Whether dialog was confirmed.
        #[serde(rename = "result")]
        pub result: bool,
        ///User input in case of prompt.
        #[serde(rename = "userInput")]
        pub user_input: String,
    }
    ///Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
    ///open.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct JavascriptDialogOpeningEvent {
        ///Frame url.
        #[serde(rename = "url")]
        pub url: String,
        ///Message that will be displayed by the dialog.
        #[serde(rename = "message")]
        pub message: String,
        ///Dialog type.
        #[serde(rename = "type")]
        pub type_: DialogType,
        ///True iff browser is capable showing or acting on the given dialog. When browser has no
        ///dialog handler for given target, calling alert while Page domain is engaged will stall
        ///the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
        #[serde(rename = "hasBrowserHandler")]
        pub has_browser_handler: bool,
        ///Default dialog prompt.
        #[serde(rename = "defaultPrompt")]
        pub default_prompt: Option<String>,
    }
    ///Fired for top level page lifecycle events such as navigation, load, paint, etc.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LifecycleEventEvent {
        ///Id of the frame.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///Loader identifier. Empty string if the request is fetched from worker.
        #[serde(rename = "loaderId")]
        pub loader_id: crate::protocol_test::network::LoaderId,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "timestamp")]
        pub timestamp: crate::protocol_test::network::MonotonicTime,
    }
    ///Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
    ///not assume any ordering with the Page.frameNavigated event. This event is fired only for
    ///main-frame history navigation where the document changes (non-same-document navigations),
    ///when bfcache navigation fails.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BackForwardCacheNotUsedEvent {
        ///The loader id for the associated navgation.
        #[serde(rename = "loaderId")]
        pub loader_id: crate::protocol_test::network::LoaderId,
        ///The frame id of the associated frame.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///Array of reasons why the page could not be cached. This must not be empty.
        #[serde(rename = "notRestoredExplanations")]
        pub not_restored_explanations: Vec<BackForwardCacheNotRestoredExplanation>,
        ///Tree structure of reasons why the page could not be cached for each frame.
        #[serde(rename = "notRestoredExplanationsTree")]
        pub not_restored_explanations_tree: Option<
            BackForwardCacheNotRestoredExplanationTree,
        >,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadEventFiredEvent {
        #[serde(rename = "timestamp")]
        pub timestamp: crate::protocol_test::network::MonotonicTime,
    }
    ///Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NavigatedWithinDocumentEvent {
        ///Id of the frame.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        ///Frame's new url.
        #[serde(rename = "url")]
        pub url: String,
    }
    ///Compressed image data requested by the `startScreencast`.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScreencastFrameEvent {
        ///Base64-encoded compressed image. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "data")]
        pub data: String,
        ///Screencast frame metadata.
        #[serde(rename = "metadata")]
        pub metadata: ScreencastFrameMetadata,
        ///Frame number.
        #[serde(rename = "sessionId")]
        pub session_id: i64,
    }
    ///Fired when the page with currently enabled screencast was shown or hidden `.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScreencastVisibilityChangedEvent {
        ///True if the page is visible.
        #[serde(rename = "visible")]
        pub visible: bool,
    }
    ///Fired when a new window is going to be opened, via window.open(), link click, form submission,
    ///etc.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WindowOpenEvent {
        ///The URL for the new window.
        #[serde(rename = "url")]
        pub url: String,
        ///Window name.
        #[serde(rename = "windowName")]
        pub window_name: String,
        ///An array of enabled window features.
        #[serde(rename = "windowFeatures")]
        pub window_features: Vec<String>,
        ///Whether or not it was triggered by user gesture.
        #[serde(rename = "userGesture")]
        pub user_gesture: bool,
    }
    ///Issued for every compilation cache generated. Is only available
    ///if Page.setGenerateCompilationCache is enabled.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CompilationCacheProducedEvent {
        #[serde(rename = "url")]
        pub url: String,
        ///Base64-encoded data (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "data")]
        pub data: String,
    }
}
pub mod performance {
    ///Run-time execution metric.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Metric {
        ///Metric name.
        #[serde(rename = "name")]
        pub name: String,
        ///Metric value.
        #[serde(rename = "value")]
        pub value: f64,
    }
    ///Disable collecting and reporting metrics.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Enum for [Enable]'s `time_domain`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum EnableTimeDomain {
        #[serde(rename = "timeTicks")]
        TimeTicks,
        #[serde(rename = "threadTicks")]
        ThreadTicks,
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        ///Time domain to use for collecting and reporting duration metrics.
        #[serde(rename = "timeDomain")]
        pub time_domain: Option<Option<EnableTimeDomain>>,
    }
    ///Enable collecting and reporting metrics.
    ///---
    ///Parameter Type: [EnableParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Enum for [SetTimeDomain]'s `time_domain`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetTimeDomainTimeDomain {
        #[serde(rename = "timeTicks")]
        TimeTicks,
        #[serde(rename = "threadTicks")]
        ThreadTicks,
    }
    ///
    /// Parameter value for [SetTimeDomain].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTimeDomainParams {
        ///Time domain
        #[serde(rename = "timeDomain")]
        pub time_domain: SetTimeDomainTimeDomain,
    }
    ///Sets time domain to use for collecting and reporting duration metrics.
    ///Note that this must be called before enabling metrics collection. Calling
    ///this method while metrics collection is enabled returns an error.
    ///---
    ///Parameter Type: [SetTimeDomainParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetTimeDomain;
    impl crate::util::Command for SetTimeDomain {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setTimeDomain"
        }
    }
    ///
    /// Return value for [GetMetrics].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMetricsReturns {
        ///Current values for run-time metrics.
        #[serde(rename = "metrics")]
        pub metrics: Vec<Metric>,
    }
    ///Retrieve current values of run-time metrics.
    ///---
    ///Return Type: [GetMetricsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetMetrics;
    impl crate::util::Command for GetMetrics {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getMetrics"
        }
    }
    ///Current values of the metrics.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MetricsEvent {
        ///Current values of the metrics.
        #[serde(rename = "metrics")]
        pub metrics: Vec<Metric>,
        ///Timestamp title.
        #[serde(rename = "title")]
        pub title: String,
    }
}
///Reporting of performance timeline events, as specified in
///https://w3c.github.io/performance-timeline/#dom-performanceobserver.
pub mod performance_timeline {
    ///See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LargestContentfulPaint {
        #[serde(rename = "renderTime")]
        pub render_time: crate::protocol_test::network::TimeSinceEpoch,
        #[serde(rename = "loadTime")]
        pub load_time: crate::protocol_test::network::TimeSinceEpoch,
        ///The number of pixels being painted.
        #[serde(rename = "size")]
        pub size: f64,
        ///The id attribute of the element, if available.
        #[serde(rename = "elementId")]
        pub element_id: Option<String>,
        ///The URL of the image (may be trimmed).
        #[serde(rename = "url")]
        pub url: Option<String>,
        #[serde(rename = "nodeId")]
        pub node_id: Option<crate::protocol_test::dom::BackendNodeId>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LayoutShiftAttribution {
        #[serde(rename = "previousRect")]
        pub previous_rect: crate::protocol_test::dom::Rect,
        #[serde(rename = "currentRect")]
        pub current_rect: crate::protocol_test::dom::Rect,
        #[serde(rename = "nodeId")]
        pub node_id: Option<crate::protocol_test::dom::BackendNodeId>,
    }
    ///See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LayoutShift {
        ///Score increment produced by this event.
        #[serde(rename = "value")]
        pub value: f64,
        #[serde(rename = "hadRecentInput")]
        pub had_recent_input: bool,
        #[serde(rename = "lastInputTime")]
        pub last_input_time: crate::protocol_test::network::TimeSinceEpoch,
        #[serde(rename = "sources")]
        pub sources: Vec<LayoutShiftAttribution>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TimelineEvent {
        ///Identifies the frame that this event is related to. Empty for non-frame targets.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        ///The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
        ///This determines which of the optional "details" fiedls is present.
        #[serde(rename = "type")]
        pub type_: String,
        ///Name may be empty depending on the type.
        #[serde(rename = "name")]
        pub name: String,
        ///Time in seconds since Epoch, monotonically increasing within document lifetime.
        #[serde(rename = "time")]
        pub time: crate::protocol_test::network::TimeSinceEpoch,
        ///Event duration, if applicable.
        #[serde(rename = "duration")]
        pub duration: Option<f64>,
        #[serde(rename = "lcpDetails")]
        pub lcp_details: Option<LargestContentfulPaint>,
        #[serde(rename = "layoutShiftDetails")]
        pub layout_shift_details: Option<LayoutShift>,
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        ///The types of event to report, as specified in
        ///https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
        ///The specified filter overrides any previous filters, passing empty
        ///filter disables recording.
        ///Note that not all types exposed to the web platform are currently supported.
        #[serde(rename = "eventTypes")]
        pub event_types: Vec<String>,
    }
    ///Previously buffered events would be reported before method returns.
    ///See also: timelineEventAdded
    ///---
    ///Parameter Type: [EnableParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///Sent when a performance timeline event is added. See reportPerformanceTimeline method.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TimelineEventAddedEvent {
        #[serde(rename = "event")]
        pub event: TimelineEvent,
    }
}
///Security
pub mod security {
    ///An internal certificate ID value.
    pub type CertificateId = i64;
    ///A description of mixed content (HTTP resources on HTTPS pages), as defined by
    ///https://www.w3.org/TR/mixed-content/#categories
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum MixedContentType {
        #[serde(rename = "blockable")]
        Blockable,
        #[serde(rename = "optionally-blockable")]
        OptionallyBlockable,
        #[serde(rename = "none")]
        None,
    }
    ///The security level of a page or resource.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SecurityState {
        #[serde(rename = "unknown")]
        Unknown,
        #[serde(rename = "neutral")]
        Neutral,
        #[serde(rename = "insecure")]
        Insecure,
        #[serde(rename = "secure")]
        Secure,
        #[serde(rename = "info")]
        Info,
        #[serde(rename = "insecure-broken")]
        InsecureBroken,
    }
    ///Details about the security state of the page certificate.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CertificateSecurityState {
        ///Protocol name (e.g. "TLS 1.2" or "QUIC").
        #[serde(rename = "protocol")]
        pub protocol: String,
        ///Key Exchange used by the connection, or the empty string if not applicable.
        #[serde(rename = "keyExchange")]
        pub key_exchange: String,
        ///(EC)DH group used by the connection, if applicable.
        #[serde(rename = "keyExchangeGroup")]
        pub key_exchange_group: Option<String>,
        ///Cipher name.
        #[serde(rename = "cipher")]
        pub cipher: String,
        ///TLS MAC. Note that AEAD ciphers do not have separate MACs.
        #[serde(rename = "mac")]
        pub mac: Option<String>,
        ///Page certificate.
        #[serde(rename = "certificate")]
        pub certificate: Vec<String>,
        ///Certificate subject name.
        #[serde(rename = "subjectName")]
        pub subject_name: String,
        ///Name of the issuing CA.
        #[serde(rename = "issuer")]
        pub issuer: String,
        ///Certificate valid from date.
        #[serde(rename = "validFrom")]
        pub valid_from: crate::protocol_test::network::TimeSinceEpoch,
        ///Certificate valid to (expiration) date
        #[serde(rename = "validTo")]
        pub valid_to: crate::protocol_test::network::TimeSinceEpoch,
        ///The highest priority network error code, if the certificate has an error.
        #[serde(rename = "certificateNetworkError")]
        pub certificate_network_error: Option<String>,
        ///True if the certificate uses a weak signature aglorithm.
        #[serde(rename = "certificateHasWeakSignature")]
        pub certificate_has_weak_signature: bool,
        ///True if the certificate has a SHA1 signature in the chain.
        #[serde(rename = "certificateHasSha1Signature")]
        pub certificate_has_sha_1_signature: bool,
        ///True if modern SSL
        #[serde(rename = "modernSSL")]
        pub modern_ssl: bool,
        ///True if the connection is using an obsolete SSL protocol.
        #[serde(rename = "obsoleteSslProtocol")]
        pub obsolete_ssl_protocol: bool,
        ///True if the connection is using an obsolete SSL key exchange.
        #[serde(rename = "obsoleteSslKeyExchange")]
        pub obsolete_ssl_key_exchange: bool,
        ///True if the connection is using an obsolete SSL cipher.
        #[serde(rename = "obsoleteSslCipher")]
        pub obsolete_ssl_cipher: bool,
        ///True if the connection is using an obsolete SSL signature.
        #[serde(rename = "obsoleteSslSignature")]
        pub obsolete_ssl_signature: bool,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SafetyTipStatus {
        #[serde(rename = "badReputation")]
        BadReputation,
        #[serde(rename = "lookalike")]
        Lookalike,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SafetyTipInfo {
        ///Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
        #[serde(rename = "safetyTipStatus")]
        pub safety_tip_status: SafetyTipStatus,
        ///The URL the safety tip suggested ("Did you mean?"). Only filled in for lookalike matches.
        #[serde(rename = "safeUrl")]
        pub safe_url: Option<String>,
    }
    ///Security state information about the page.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct VisibleSecurityState {
        ///The security level of the page.
        #[serde(rename = "securityState")]
        pub security_state: SecurityState,
        ///Security state details about the page certificate.
        #[serde(rename = "certificateSecurityState")]
        pub certificate_security_state: Option<CertificateSecurityState>,
        ///The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
        #[serde(rename = "safetyTipInfo")]
        pub safety_tip_info: Option<SafetyTipInfo>,
        ///Array of security state issues ids.
        #[serde(rename = "securityStateIssueIds")]
        pub security_state_issue_ids: Vec<String>,
    }
    ///An explanation of an factor contributing to the security state.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SecurityStateExplanation {
        ///Security state representing the severity of the factor being explained.
        #[serde(rename = "securityState")]
        pub security_state: SecurityState,
        ///Title describing the type of factor.
        #[serde(rename = "title")]
        pub title: String,
        ///Short phrase describing the type of factor.
        #[serde(rename = "summary")]
        pub summary: String,
        ///Full text explanation of the factor.
        #[serde(rename = "description")]
        pub description: String,
        ///The type of mixed content described by the explanation.
        #[serde(rename = "mixedContentType")]
        pub mixed_content_type: MixedContentType,
        ///Page certificate.
        #[serde(rename = "certificate")]
        pub certificate: Vec<String>,
        ///Recommendations to fix any issues.
        #[serde(rename = "recommendations")]
        pub recommendations: Option<Vec<String>>,
    }
    ///Information about insecure content on the page.
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InsecureContentStatus {
        ///Always false.
        #[serde(rename = "ranMixedContent")]
        pub ran_mixed_content: bool,
        ///Always false.
        #[serde(rename = "displayedMixedContent")]
        pub displayed_mixed_content: bool,
        ///Always false.
        #[serde(rename = "containedMixedForm")]
        pub contained_mixed_form: bool,
        ///Always false.
        #[serde(rename = "ranContentWithCertErrors")]
        pub ran_content_with_cert_errors: bool,
        ///Always false.
        #[serde(rename = "displayedContentWithCertErrors")]
        pub displayed_content_with_cert_errors: bool,
        ///Always set to unknown.
        #[serde(rename = "ranInsecureContentStyle")]
        pub ran_insecure_content_style: SecurityState,
        ///Always set to unknown.
        #[serde(rename = "displayedInsecureContentStyle")]
        pub displayed_insecure_content_style: SecurityState,
    }
    ///The action to take when a certificate error occurs. continue will continue processing the
    ///request and cancel will cancel the request.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum CertificateErrorAction {
        #[serde(rename = "continue")]
        Continue,
        #[serde(rename = "cancel")]
        Cancel,
    }
    ///Disables tracking security state changes.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables tracking security state changes.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [SetIgnoreCertificateErrors].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetIgnoreCertificateErrorsParams {
        ///If true, all certificate errors will be ignored.
        #[serde(rename = "ignore")]
        pub ignore: bool,
    }
    ///Enable/disable whether all certificate errors should be ignored.
    ///---
    ///Parameter Type: [SetIgnoreCertificateErrorsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetIgnoreCertificateErrors;
    impl crate::util::Command for SetIgnoreCertificateErrors {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setIgnoreCertificateErrors"
        }
    }
    ///
    /// Parameter value for [HandleCertificateError].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HandleCertificateErrorParams {
        ///The ID of the event.
        #[serde(rename = "eventId")]
        pub event_id: i64,
        ///The action to take on the certificate error.
        #[serde(rename = "action")]
        pub action: CertificateErrorAction,
    }
    ///Handles a certificate error that fired a certificateError event.
    ///---
    ///Parameter Type: [HandleCertificateErrorParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HandleCertificateError;
    impl crate::util::Command for HandleCertificateError {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "handleCertificateError"
        }
    }
    ///
    /// Parameter value for [SetOverrideCertificateErrors].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetOverrideCertificateErrorsParams {
        ///If true, certificate errors will be overridden.
        #[serde(rename = "override")]
        pub override_: bool,
    }
    ///Enable/disable overriding certificate errors. If enabled, all certificate error events need to
    ///be handled by the DevTools client and should be answered with `handleCertificateError` commands.
    ///---
    ///Parameter Type: [SetOverrideCertificateErrorsParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetOverrideCertificateErrors;
    impl crate::util::Command for SetOverrideCertificateErrors {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setOverrideCertificateErrors"
        }
    }
    ///There is a certificate error. If overriding certificate errors is enabled, then it should be
    ///handled with the `handleCertificateError` command. Note: this event does not fire if the
    ///certificate error has been allowed internally. Only one client per target should override
    ///certificate errors at the same time.
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CertificateErrorEvent {
        ///The ID of the event.
        #[serde(rename = "eventId")]
        pub event_id: i64,
        ///The type of the error.
        #[serde(rename = "errorType")]
        pub error_type: String,
        ///The url that was requested.
        #[serde(rename = "requestURL")]
        pub request_url: String,
    }
    ///The security state of the page changed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct VisibleSecurityStateChangedEvent {
        ///Security state information about the page.
        #[serde(rename = "visibleSecurityState")]
        pub visible_security_state: VisibleSecurityState,
    }
    ///The security state of the page changed. No longer being sent.
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SecurityStateChangedEvent {
        ///Security state.
        #[serde(rename = "securityState")]
        pub security_state: SecurityState,
        ///True if the page was loaded over cryptographic transport such as HTTPS.
        #[deprecated]
        #[serde(rename = "schemeIsCryptographic")]
        pub scheme_is_cryptographic: bool,
        ///Previously a list of explanations for the security state. Now always
        ///empty.
        #[deprecated]
        #[serde(rename = "explanations")]
        pub explanations: Vec<SecurityStateExplanation>,
        ///Information about insecure content on the page.
        #[deprecated]
        #[serde(rename = "insecureContentStatus")]
        pub insecure_content_status: InsecureContentStatus,
        ///Overrides user-visible description of the state. Always omitted.
        #[deprecated]
        #[serde(rename = "summary")]
        pub summary: Option<String>,
    }
}
pub mod service_worker {
    pub type RegistrationId = String;
    ///ServiceWorker registration.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ServiceWorkerRegistration {
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationId,
        #[serde(rename = "scopeURL")]
        pub scope_url: String,
        #[serde(rename = "isDeleted")]
        pub is_deleted: bool,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ServiceWorkerVersionRunningStatus {
        #[serde(rename = "stopped")]
        Stopped,
        #[serde(rename = "starting")]
        Starting,
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "stopping")]
        Stopping,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ServiceWorkerVersionStatus {
        #[serde(rename = "new")]
        New,
        #[serde(rename = "installing")]
        Installing,
        #[serde(rename = "installed")]
        Installed,
        #[serde(rename = "activating")]
        Activating,
        #[serde(rename = "activated")]
        Activated,
        #[serde(rename = "redundant")]
        Redundant,
    }
    ///ServiceWorker version.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ServiceWorkerVersion {
        #[serde(rename = "versionId")]
        pub version_id: String,
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationId,
        #[serde(rename = "scriptURL")]
        pub script_url: String,
        #[serde(rename = "runningStatus")]
        pub running_status: ServiceWorkerVersionRunningStatus,
        #[serde(rename = "status")]
        pub status: ServiceWorkerVersionStatus,
        ///The Last-Modified header value of the main script.
        #[serde(rename = "scriptLastModified")]
        pub script_last_modified: Option<f64>,
        ///The time at which the response headers of the main script were received from the server.
        ///For cached script it is the last time the cache entry was validated.
        #[serde(rename = "scriptResponseTime")]
        pub script_response_time: Option<f64>,
        #[serde(rename = "controlledClients")]
        pub controlled_clients: Option<Vec<crate::protocol_test::target::TargetId>>,
        #[serde(rename = "targetId")]
        pub target_id: Option<crate::protocol_test::target::TargetId>,
    }
    ///ServiceWorker error message.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ServiceWorkerErrorMessage {
        #[serde(rename = "errorMessage")]
        pub error_message: String,
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationId,
        #[serde(rename = "versionId")]
        pub version_id: String,
        #[serde(rename = "sourceURL")]
        pub source_url: String,
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }
    ///
    /// Parameter value for [DeliverPushMessage].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeliverPushMessageParams {
        #[serde(rename = "origin")]
        pub origin: String,
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationId,
        #[serde(rename = "data")]
        pub data: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeliverPushMessage;
    impl crate::util::Command for DeliverPushMessage {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deliverPushMessage"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [DispatchSyncEvent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchSyncEventParams {
        #[serde(rename = "origin")]
        pub origin: String,
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationId,
        #[serde(rename = "tag")]
        pub tag: String,
        #[serde(rename = "lastChance")]
        pub last_chance: bool,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchSyncEvent;
    impl crate::util::Command for DispatchSyncEvent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "dispatchSyncEvent"
        }
    }
    ///
    /// Parameter value for [DispatchPeriodicSyncEvent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchPeriodicSyncEventParams {
        #[serde(rename = "origin")]
        pub origin: String,
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationId,
        #[serde(rename = "tag")]
        pub tag: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DispatchPeriodicSyncEvent;
    impl crate::util::Command for DispatchPeriodicSyncEvent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "dispatchPeriodicSyncEvent"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [InspectWorker].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InspectWorkerParams {
        #[serde(rename = "versionId")]
        pub version_id: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InspectWorker;
    impl crate::util::Command for InspectWorker {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "inspectWorker"
        }
    }
    ///
    /// Parameter value for [SetForceUpdateOnPageLoad].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetForceUpdateOnPageLoadParams {
        #[serde(rename = "forceUpdateOnPageLoad")]
        pub force_update_on_page_load: bool,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetForceUpdateOnPageLoad;
    impl crate::util::Command for SetForceUpdateOnPageLoad {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setForceUpdateOnPageLoad"
        }
    }
    ///
    /// Parameter value for [SkipWaiting].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SkipWaitingParams {
        #[serde(rename = "scopeURL")]
        pub scope_url: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SkipWaiting;
    impl crate::util::Command for SkipWaiting {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "skipWaiting"
        }
    }
    ///
    /// Parameter value for [StartWorker].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartWorkerParams {
        #[serde(rename = "scopeURL")]
        pub scope_url: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartWorker;
    impl crate::util::Command for StartWorker {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startWorker"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopAllWorkers;
    impl crate::util::Command for StopAllWorkers {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopAllWorkers"
        }
    }
    ///
    /// Parameter value for [StopWorker].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopWorkerParams {
        #[serde(rename = "versionId")]
        pub version_id: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopWorker;
    impl crate::util::Command for StopWorker {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopWorker"
        }
    }
    ///
    /// Parameter value for [Unregister].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UnregisterParams {
        #[serde(rename = "scopeURL")]
        pub scope_url: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Unregister;
    impl crate::util::Command for Unregister {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "unregister"
        }
    }
    ///
    /// Parameter value for [UpdateRegistration].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UpdateRegistrationParams {
        #[serde(rename = "scopeURL")]
        pub scope_url: String,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UpdateRegistration;
    impl crate::util::Command for UpdateRegistration {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "updateRegistration"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WorkerErrorReportedEvent {
        #[serde(rename = "errorMessage")]
        pub error_message: ServiceWorkerErrorMessage,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WorkerRegistrationUpdatedEvent {
        #[serde(rename = "registrations")]
        pub registrations: Vec<ServiceWorkerRegistration>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WorkerVersionUpdatedEvent {
        #[serde(rename = "versions")]
        pub versions: Vec<ServiceWorkerVersion>,
    }
}
pub mod storage {
    pub type SerializedStorageKey = String;
    ///Enum of possible storage types.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum StorageType {
        #[serde(rename = "appcache")]
        Appcache,
        #[serde(rename = "cookies")]
        Cookies,
        #[serde(rename = "file_systems")]
        FileSystems,
        #[serde(rename = "indexeddb")]
        Indexeddb,
        #[serde(rename = "local_storage")]
        LocalStorage,
        #[serde(rename = "shader_cache")]
        ShaderCache,
        #[serde(rename = "websql")]
        Websql,
        #[serde(rename = "service_workers")]
        ServiceWorkers,
        #[serde(rename = "cache_storage")]
        CacheStorage,
        #[serde(rename = "interest_groups")]
        InterestGroups,
        #[serde(rename = "shared_storage")]
        SharedStorage,
        #[serde(rename = "storage_buckets")]
        StorageBuckets,
        #[serde(rename = "all")]
        All,
        #[serde(rename = "other")]
        Other,
    }
    ///Usage for a storage type.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UsageForType {
        ///Name of storage type.
        #[serde(rename = "storageType")]
        pub storage_type: StorageType,
        ///Storage usage (bytes).
        #[serde(rename = "usage")]
        pub usage: f64,
    }
    ///Pair of issuer origin and number of available (signed, but not used) Trust
    ///Tokens from that issuer.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrustTokens {
        #[serde(rename = "issuerOrigin")]
        pub issuer_origin: String,
        #[serde(rename = "count")]
        pub count: f64,
    }
    ///Enum of interest group access types.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum InterestGroupAccessType {
        #[serde(rename = "join")]
        Join,
        #[serde(rename = "leave")]
        Leave,
        #[serde(rename = "update")]
        Update,
        #[serde(rename = "loaded")]
        Loaded,
        #[serde(rename = "bid")]
        Bid,
        #[serde(rename = "win")]
        Win,
    }
    ///Ad advertising element inside an interest group.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InterestGroupAd {
        #[serde(rename = "renderUrl")]
        pub render_url: String,
        #[serde(rename = "metadata")]
        pub metadata: Option<String>,
    }
    ///The full details of an interest group.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InterestGroupDetails {
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "expirationTime")]
        pub expiration_time: crate::protocol_test::network::TimeSinceEpoch,
        #[serde(rename = "joiningOrigin")]
        pub joining_origin: String,
        #[serde(rename = "biddingUrl")]
        pub bidding_url: Option<String>,
        #[serde(rename = "biddingWasmHelperUrl")]
        pub bidding_wasm_helper_url: Option<String>,
        #[serde(rename = "updateUrl")]
        pub update_url: Option<String>,
        #[serde(rename = "trustedBiddingSignalsUrl")]
        pub trusted_bidding_signals_url: Option<String>,
        #[serde(rename = "trustedBiddingSignalsKeys")]
        pub trusted_bidding_signals_keys: Vec<String>,
        #[serde(rename = "userBiddingSignals")]
        pub user_bidding_signals: Option<String>,
        #[serde(rename = "ads")]
        pub ads: Vec<InterestGroupAd>,
        #[serde(rename = "adComponents")]
        pub ad_components: Vec<InterestGroupAd>,
    }
    ///Enum of shared storage access types.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SharedStorageAccessType {
        #[serde(rename = "documentAddModule")]
        DocumentAddModule,
        #[serde(rename = "documentSelectURL")]
        DocumentSelectUrl,
        #[serde(rename = "documentRun")]
        DocumentRun,
        #[serde(rename = "documentSet")]
        DocumentSet,
        #[serde(rename = "documentAppend")]
        DocumentAppend,
        #[serde(rename = "documentDelete")]
        DocumentDelete,
        #[serde(rename = "documentClear")]
        DocumentClear,
        #[serde(rename = "workletSet")]
        WorkletSet,
        #[serde(rename = "workletAppend")]
        WorkletAppend,
        #[serde(rename = "workletDelete")]
        WorkletDelete,
        #[serde(rename = "workletClear")]
        WorkletClear,
        #[serde(rename = "workletGet")]
        WorkletGet,
        #[serde(rename = "workletKeys")]
        WorkletKeys,
        #[serde(rename = "workletEntries")]
        WorkletEntries,
        #[serde(rename = "workletLength")]
        WorkletLength,
        #[serde(rename = "workletRemainingBudget")]
        WorkletRemainingBudget,
    }
    ///Struct for a single key-value pair in an origin's shared storage.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SharedStorageEntry {
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Details for an origin's shared storage.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SharedStorageMetadata {
        #[serde(rename = "creationTime")]
        pub creation_time: crate::protocol_test::network::TimeSinceEpoch,
        #[serde(rename = "length")]
        pub length: i64,
        #[serde(rename = "remainingBudget")]
        pub remaining_budget: f64,
    }
    ///Pair of reporting metadata details for a candidate URL for `selectURL()`.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SharedStorageReportingMetadata {
        #[serde(rename = "eventType")]
        pub event_type: String,
        #[serde(rename = "reportingUrl")]
        pub reporting_url: String,
    }
    ///Bundles a candidate URL with its reporting metadata.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SharedStorageUrlWithMetadata {
        ///Spec of candidate URL.
        #[serde(rename = "url")]
        pub url: String,
        ///Any associated reporting metadata.
        #[serde(rename = "reportingMetadata")]
        pub reporting_metadata: Vec<SharedStorageReportingMetadata>,
    }
    ///Bundles the parameters for shared storage access events whose
    ///presence/absence can vary according to SharedStorageAccessType.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SharedStorageAccessParams {
        ///Spec of the module script URL.
        ///Present only for SharedStorageAccessType.documentAddModule.
        #[serde(rename = "scriptSourceUrl")]
        pub script_source_url: Option<String>,
        ///Name of the registered operation to be run.
        ///Present only for SharedStorageAccessType.documentRun and
        ///SharedStorageAccessType.documentSelectURL.
        #[serde(rename = "operationName")]
        pub operation_name: Option<String>,
        ///The operation's serialized data in bytes (converted to a string).
        ///Present only for SharedStorageAccessType.documentRun and
        ///SharedStorageAccessType.documentSelectURL.
        #[serde(rename = "serializedData")]
        pub serialized_data: Option<String>,
        ///Array of candidate URLs' specs, along with any associated metadata.
        ///Present only for SharedStorageAccessType.documentSelectURL.
        #[serde(rename = "urlsWithMetadata")]
        pub urls_with_metadata: Option<Vec<SharedStorageUrlWithMetadata>>,
        ///Key for a specific entry in an origin's shared storage.
        ///Present only for SharedStorageAccessType.documentSet,
        ///SharedStorageAccessType.documentAppend,
        ///SharedStorageAccessType.documentDelete,
        ///SharedStorageAccessType.workletSet,
        ///SharedStorageAccessType.workletAppend,
        ///SharedStorageAccessType.workletDelete, and
        ///SharedStorageAccessType.workletGet.
        #[serde(rename = "key")]
        pub key: Option<String>,
        ///Value for a specific entry in an origin's shared storage.
        ///Present only for SharedStorageAccessType.documentSet,
        ///SharedStorageAccessType.documentAppend,
        ///SharedStorageAccessType.workletSet, and
        ///SharedStorageAccessType.workletAppend.
        #[serde(rename = "value")]
        pub value: Option<String>,
        ///Whether or not to set an entry for a key if that key is already present.
        ///Present only for SharedStorageAccessType.documentSet and
        ///SharedStorageAccessType.workletSet.
        #[serde(rename = "ignoreIfPresent")]
        pub ignore_if_present: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum StorageBucketsDurability {
        #[serde(rename = "relaxed")]
        Relaxed,
        #[serde(rename = "strict")]
        Strict,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StorageBucket {
        #[serde(rename = "storageKey")]
        pub storage_key: SerializedStorageKey,
        ///If not specified, it is the default bucket of the storageKey.
        #[serde(rename = "name")]
        pub name: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StorageBucketInfo {
        #[serde(rename = "bucket")]
        pub bucket: StorageBucket,
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "expiration")]
        pub expiration: crate::protocol_test::network::TimeSinceEpoch,
        ///Storage quota (bytes).
        #[serde(rename = "quota")]
        pub quota: f64,
        #[serde(rename = "persistent")]
        pub persistent: bool,
        #[serde(rename = "durability")]
        pub durability: StorageBucketsDurability,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AttributionReportingSourceType {
        #[serde(rename = "navigation")]
        Navigation,
        #[serde(rename = "event")]
        Event,
    }
    pub type UnsignedInt64AsBase10 = String;
    pub type UnsignedInt128AsBase16 = String;
    pub type SignedInt64AsBase10 = String;
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttributionReportingFilterDataEntry {
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "values")]
        pub values: Vec<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttributionReportingAggregationKeysEntry {
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "value")]
        pub value: UnsignedInt128AsBase16,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttributionReportingSourceRegistration {
        #[serde(rename = "time")]
        pub time: crate::protocol_test::network::TimeSinceEpoch,
        ///duration in seconds
        #[serde(rename = "expiry")]
        pub expiry: Option<i64>,
        ///duration in seconds
        #[serde(rename = "eventReportWindow")]
        pub event_report_window: Option<i64>,
        ///duration in seconds
        #[serde(rename = "aggregatableReportWindow")]
        pub aggregatable_report_window: Option<i64>,
        #[serde(rename = "type")]
        pub type_: AttributionReportingSourceType,
        #[serde(rename = "sourceOrigin")]
        pub source_origin: String,
        #[serde(rename = "reportingOrigin")]
        pub reporting_origin: String,
        #[serde(rename = "destinationSites")]
        pub destination_sites: Vec<String>,
        #[serde(rename = "eventId")]
        pub event_id: UnsignedInt64AsBase10,
        #[serde(rename = "priority")]
        pub priority: SignedInt64AsBase10,
        #[serde(rename = "filterData")]
        pub filter_data: Vec<AttributionReportingFilterDataEntry>,
        #[serde(rename = "aggregationKeys")]
        pub aggregation_keys: Vec<AttributionReportingAggregationKeysEntry>,
        #[serde(rename = "debugKey")]
        pub debug_key: Option<UnsignedInt64AsBase10>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AttributionReportingSourceRegistrationResult {
        #[serde(rename = "success")]
        Success,
        #[serde(rename = "internalError")]
        InternalError,
        #[serde(rename = "insufficientSourceCapacity")]
        InsufficientSourceCapacity,
        #[serde(rename = "insufficientUniqueDestinationCapacity")]
        InsufficientUniqueDestinationCapacity,
        #[serde(rename = "excessiveReportingOrigins")]
        ExcessiveReportingOrigins,
        #[serde(rename = "prohibitedByBrowserPolicy")]
        ProhibitedByBrowserPolicy,
        #[serde(rename = "successNoised")]
        SuccessNoised,
        #[serde(rename = "destinationReportingLimitReached")]
        DestinationReportingLimitReached,
        #[serde(rename = "destinationGlobalLimitReached")]
        DestinationGlobalLimitReached,
        #[serde(rename = "destinationBothLimitsReached")]
        DestinationBothLimitsReached,
        #[serde(rename = "reportingOriginsPerSiteLimitReached")]
        ReportingOriginsPerSiteLimitReached,
        #[serde(rename = "exceedsMaxChannelCapacity")]
        ExceedsMaxChannelCapacity,
    }
    ///
    /// Parameter value for [GetStorageKeyForFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStorageKeyForFrameParams {
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
    }
    ///
    /// Return value for [GetStorageKeyForFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStorageKeyForFrameReturns {
        #[serde(rename = "storageKey")]
        pub storage_key: SerializedStorageKey,
    }
    ///Returns a storage key given a frame id.
    ///---
    ///Parameter Type: [GetStorageKeyForFrameParams]
    ///Return Type: [GetStorageKeyForFrameReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStorageKeyForFrame;
    impl crate::util::Command for GetStorageKeyForFrame {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getStorageKeyForFrame"
        }
    }
    ///
    /// Parameter value for [ClearDataForOrigin].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearDataForOriginParams {
        ///Security origin.
        #[serde(rename = "origin")]
        pub origin: String,
        ///Comma separated list of StorageType to clear.
        #[serde(rename = "storageTypes")]
        pub storage_types: String,
    }
    ///Clears storage for origin.
    ///---
    ///Parameter Type: [ClearDataForOriginParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearDataForOrigin;
    impl crate::util::Command for ClearDataForOrigin {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearDataForOrigin"
        }
    }
    ///
    /// Parameter value for [ClearDataForStorageKey].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearDataForStorageKeyParams {
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        ///Comma separated list of StorageType to clear.
        #[serde(rename = "storageTypes")]
        pub storage_types: String,
    }
    ///Clears storage for storage key.
    ///---
    ///Parameter Type: [ClearDataForStorageKeyParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearDataForStorageKey;
    impl crate::util::Command for ClearDataForStorageKey {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearDataForStorageKey"
        }
    }
    ///
    /// Parameter value for [GetCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCookiesParams {
        ///Browser context to use when called on the browser endpoint.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<crate::protocol_test::browser::BrowserContextId>,
    }
    ///
    /// Return value for [GetCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCookiesReturns {
        ///Array of cookie objects.
        #[serde(rename = "cookies")]
        pub cookies: Vec<crate::protocol_test::network::Cookie>,
    }
    ///Returns all browser cookies.
    ///---
    ///Parameter Type: [GetCookiesParams]
    ///Return Type: [GetCookiesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCookies;
    impl crate::util::Command for GetCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getCookies"
        }
    }
    ///
    /// Parameter value for [SetCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCookiesParams {
        ///Cookies to be set.
        #[serde(rename = "cookies")]
        pub cookies: Vec<crate::protocol_test::network::CookieParam>,
        ///Browser context to use when called on the browser endpoint.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<crate::protocol_test::browser::BrowserContextId>,
    }
    ///Sets given cookies.
    ///---
    ///Parameter Type: [SetCookiesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCookies;
    impl crate::util::Command for SetCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setCookies"
        }
    }
    ///
    /// Parameter value for [ClearCookies].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearCookiesParams {
        ///Browser context to use when called on the browser endpoint.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<crate::protocol_test::browser::BrowserContextId>,
    }
    ///Clears cookies.
    ///---
    ///Parameter Type: [ClearCookiesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearCookies;
    impl crate::util::Command for ClearCookies {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearCookies"
        }
    }
    ///
    /// Parameter value for [GetUsageAndQuota].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetUsageAndQuotaParams {
        ///Security origin.
        #[serde(rename = "origin")]
        pub origin: String,
    }
    ///
    /// Return value for [GetUsageAndQuota].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetUsageAndQuotaReturns {
        ///Storage usage (bytes).
        #[serde(rename = "usage")]
        pub usage: f64,
        ///Storage quota (bytes).
        #[serde(rename = "quota")]
        pub quota: f64,
        ///Whether or not the origin has an active storage quota override
        #[serde(rename = "overrideActive")]
        pub override_active: bool,
        ///Storage usage per type (bytes).
        #[serde(rename = "usageBreakdown")]
        pub usage_breakdown: Vec<UsageForType>,
    }
    ///Returns usage and quota in bytes.
    ///---
    ///Parameter Type: [GetUsageAndQuotaParams]
    ///Return Type: [GetUsageAndQuotaReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetUsageAndQuota;
    impl crate::util::Command for GetUsageAndQuota {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getUsageAndQuota"
        }
    }
    ///
    /// Parameter value for [OverrideQuotaForOrigin].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct OverrideQuotaForOriginParams {
        ///Security origin.
        #[serde(rename = "origin")]
        pub origin: String,
        ///The quota size (in bytes) to override the original quota with.
        ///If this is called multiple times, the overridden quota will be equal to
        ///the quotaSize provided in the final call. If this is called without
        ///specifying a quotaSize, the quota will be reset to the default value for
        ///the specified origin. If this is called multiple times with different
        ///origins, the override will be maintained for each origin until it is
        ///disabled (called without a quotaSize).
        #[serde(rename = "quotaSize")]
        pub quota_size: Option<f64>,
    }
    ///Override quota for the specified origin
    ///---
    ///Parameter Type: [OverrideQuotaForOriginParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct OverrideQuotaForOrigin;
    impl crate::util::Command for OverrideQuotaForOrigin {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "overrideQuotaForOrigin"
        }
    }
    ///
    /// Parameter value for [TrackCacheStorageForOrigin].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackCacheStorageForOriginParams {
        ///Security origin.
        #[serde(rename = "origin")]
        pub origin: String,
    }
    ///Registers origin to be notified when an update occurs to its cache storage list.
    ///---
    ///Parameter Type: [TrackCacheStorageForOriginParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackCacheStorageForOrigin;
    impl crate::util::Command for TrackCacheStorageForOrigin {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "trackCacheStorageForOrigin"
        }
    }
    ///
    /// Parameter value for [TrackCacheStorageForStorageKey].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackCacheStorageForStorageKeyParams {
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
    }
    ///Registers storage key to be notified when an update occurs to its cache storage list.
    ///---
    ///Parameter Type: [TrackCacheStorageForStorageKeyParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackCacheStorageForStorageKey;
    impl crate::util::Command for TrackCacheStorageForStorageKey {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "trackCacheStorageForStorageKey"
        }
    }
    ///
    /// Parameter value for [TrackIndexedDbForOrigin].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackIndexedDbForOriginParams {
        ///Security origin.
        #[serde(rename = "origin")]
        pub origin: String,
    }
    ///Registers origin to be notified when an update occurs to its IndexedDB.
    ///---
    ///Parameter Type: [TrackIndexedDbForOriginParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackIndexedDbForOrigin;
    impl crate::util::Command for TrackIndexedDbForOrigin {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "trackIndexedDBForOrigin"
        }
    }
    ///
    /// Parameter value for [TrackIndexedDbForStorageKey].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackIndexedDbForStorageKeyParams {
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
    }
    ///Registers storage key to be notified when an update occurs to its IndexedDB.
    ///---
    ///Parameter Type: [TrackIndexedDbForStorageKeyParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TrackIndexedDbForStorageKey;
    impl crate::util::Command for TrackIndexedDbForStorageKey {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "trackIndexedDBForStorageKey"
        }
    }
    ///
    /// Parameter value for [UntrackCacheStorageForOrigin].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UntrackCacheStorageForOriginParams {
        ///Security origin.
        #[serde(rename = "origin")]
        pub origin: String,
    }
    ///Unregisters origin from receiving notifications for cache storage.
    ///---
    ///Parameter Type: [UntrackCacheStorageForOriginParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UntrackCacheStorageForOrigin;
    impl crate::util::Command for UntrackCacheStorageForOrigin {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "untrackCacheStorageForOrigin"
        }
    }
    ///
    /// Parameter value for [UntrackCacheStorageForStorageKey].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UntrackCacheStorageForStorageKeyParams {
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
    }
    ///Unregisters storage key from receiving notifications for cache storage.
    ///---
    ///Parameter Type: [UntrackCacheStorageForStorageKeyParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UntrackCacheStorageForStorageKey;
    impl crate::util::Command for UntrackCacheStorageForStorageKey {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "untrackCacheStorageForStorageKey"
        }
    }
    ///
    /// Parameter value for [UntrackIndexedDbForOrigin].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UntrackIndexedDbForOriginParams {
        ///Security origin.
        #[serde(rename = "origin")]
        pub origin: String,
    }
    ///Unregisters origin from receiving notifications for IndexedDB.
    ///---
    ///Parameter Type: [UntrackIndexedDbForOriginParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UntrackIndexedDbForOrigin;
    impl crate::util::Command for UntrackIndexedDbForOrigin {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "untrackIndexedDBForOrigin"
        }
    }
    ///
    /// Parameter value for [UntrackIndexedDbForStorageKey].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UntrackIndexedDbForStorageKeyParams {
        ///Storage key.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
    }
    ///Unregisters storage key from receiving notifications for IndexedDB.
    ///---
    ///Parameter Type: [UntrackIndexedDbForStorageKeyParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UntrackIndexedDbForStorageKey;
    impl crate::util::Command for UntrackIndexedDbForStorageKey {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "untrackIndexedDBForStorageKey"
        }
    }
    ///
    /// Return value for [GetTrustTokens].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTrustTokensReturns {
        #[serde(rename = "tokens")]
        pub tokens: Vec<TrustTokens>,
    }
    ///Returns the number of stored Trust Tokens per issuer for the
    ///current browsing context.
    ///---
    ///Return Type: [GetTrustTokensReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTrustTokens;
    impl crate::util::Command for GetTrustTokens {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getTrustTokens"
        }
    }
    ///
    /// Parameter value for [ClearTrustTokens].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearTrustTokensParams {
        #[serde(rename = "issuerOrigin")]
        pub issuer_origin: String,
    }
    ///
    /// Return value for [ClearTrustTokens].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearTrustTokensReturns {
        ///True if any tokens were deleted, false otherwise.
        #[serde(rename = "didDeleteTokens")]
        pub did_delete_tokens: bool,
    }
    ///Removes all Trust Tokens issued by the provided issuerOrigin.
    ///Leaves other stored data, including the issuer's Redemption Records, intact.
    ///---
    ///Parameter Type: [ClearTrustTokensParams]
    ///Return Type: [ClearTrustTokensReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearTrustTokens;
    impl crate::util::Command for ClearTrustTokens {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearTrustTokens"
        }
    }
    ///
    /// Parameter value for [GetInterestGroupDetails].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInterestGroupDetailsParams {
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
        #[serde(rename = "name")]
        pub name: String,
    }
    ///
    /// Return value for [GetInterestGroupDetails].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInterestGroupDetailsReturns {
        #[serde(rename = "details")]
        pub details: InterestGroupDetails,
    }
    ///Gets details for a named interest group.
    ///---
    ///Parameter Type: [GetInterestGroupDetailsParams]
    ///Return Type: [GetInterestGroupDetailsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInterestGroupDetails;
    impl crate::util::Command for GetInterestGroupDetails {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getInterestGroupDetails"
        }
    }
    ///
    /// Parameter value for [SetInterestGroupTracking].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInterestGroupTrackingParams {
        #[serde(rename = "enable")]
        pub enable: bool,
    }
    ///Enables/Disables issuing of interestGroupAccessed events.
    ///---
    ///Parameter Type: [SetInterestGroupTrackingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInterestGroupTracking;
    impl crate::util::Command for SetInterestGroupTracking {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setInterestGroupTracking"
        }
    }
    ///
    /// Parameter value for [GetSharedStorageMetadata].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSharedStorageMetadataParams {
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
    }
    ///
    /// Return value for [GetSharedStorageMetadata].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSharedStorageMetadataReturns {
        #[serde(rename = "metadata")]
        pub metadata: SharedStorageMetadata,
    }
    ///Gets metadata for an origin's shared storage.
    ///---
    ///Parameter Type: [GetSharedStorageMetadataParams]
    ///Return Type: [GetSharedStorageMetadataReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSharedStorageMetadata;
    impl crate::util::Command for GetSharedStorageMetadata {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getSharedStorageMetadata"
        }
    }
    ///
    /// Parameter value for [GetSharedStorageEntries].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSharedStorageEntriesParams {
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
    }
    ///
    /// Return value for [GetSharedStorageEntries].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSharedStorageEntriesReturns {
        #[serde(rename = "entries")]
        pub entries: Vec<SharedStorageEntry>,
    }
    ///Gets the entries in an given origin's shared storage.
    ///---
    ///Parameter Type: [GetSharedStorageEntriesParams]
    ///Return Type: [GetSharedStorageEntriesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSharedStorageEntries;
    impl crate::util::Command for GetSharedStorageEntries {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getSharedStorageEntries"
        }
    }
    ///
    /// Parameter value for [SetSharedStorageEntry].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSharedStorageEntryParams {
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "value")]
        pub value: String,
        ///If `ignoreIfPresent` is included and true, then only sets the entry if
        ///`key` doesn't already exist.
        #[serde(rename = "ignoreIfPresent")]
        pub ignore_if_present: Option<bool>,
    }
    ///Sets entry with `key` and `value` for a given origin's shared storage.
    ///---
    ///Parameter Type: [SetSharedStorageEntryParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSharedStorageEntry;
    impl crate::util::Command for SetSharedStorageEntry {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setSharedStorageEntry"
        }
    }
    ///
    /// Parameter value for [DeleteSharedStorageEntry].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteSharedStorageEntryParams {
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
        #[serde(rename = "key")]
        pub key: String,
    }
    ///Deletes entry for `key` (if it exists) for a given origin's shared storage.
    ///---
    ///Parameter Type: [DeleteSharedStorageEntryParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteSharedStorageEntry;
    impl crate::util::Command for DeleteSharedStorageEntry {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deleteSharedStorageEntry"
        }
    }
    ///
    /// Parameter value for [ClearSharedStorageEntries].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearSharedStorageEntriesParams {
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
    }
    ///Clears all entries for a given origin's shared storage.
    ///---
    ///Parameter Type: [ClearSharedStorageEntriesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearSharedStorageEntries;
    impl crate::util::Command for ClearSharedStorageEntries {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearSharedStorageEntries"
        }
    }
    ///
    /// Parameter value for [ResetSharedStorageBudget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResetSharedStorageBudgetParams {
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
    }
    ///Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
    ///---
    ///Parameter Type: [ResetSharedStorageBudgetParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResetSharedStorageBudget;
    impl crate::util::Command for ResetSharedStorageBudget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resetSharedStorageBudget"
        }
    }
    ///
    /// Parameter value for [SetSharedStorageTracking].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSharedStorageTrackingParams {
        #[serde(rename = "enable")]
        pub enable: bool,
    }
    ///Enables/disables issuing of sharedStorageAccessed events.
    ///---
    ///Parameter Type: [SetSharedStorageTrackingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSharedStorageTracking;
    impl crate::util::Command for SetSharedStorageTracking {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setSharedStorageTracking"
        }
    }
    ///
    /// Parameter value for [SetStorageBucketTracking].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetStorageBucketTrackingParams {
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        #[serde(rename = "enable")]
        pub enable: bool,
    }
    ///Set tracking for a storage key's buckets.
    ///---
    ///Parameter Type: [SetStorageBucketTrackingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetStorageBucketTracking;
    impl crate::util::Command for SetStorageBucketTracking {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setStorageBucketTracking"
        }
    }
    ///
    /// Parameter value for [DeleteStorageBucket].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteStorageBucketParams {
        #[serde(rename = "bucket")]
        pub bucket: StorageBucket,
    }
    ///Deletes the Storage Bucket with the given storage key and bucket name.
    ///---
    ///Parameter Type: [DeleteStorageBucketParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeleteStorageBucket;
    impl crate::util::Command for DeleteStorageBucket {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "deleteStorageBucket"
        }
    }
    ///
    /// Return value for [RunBounceTrackingMitigations].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RunBounceTrackingMitigationsReturns {
        #[serde(rename = "deletedSites")]
        pub deleted_sites: Vec<String>,
    }
    ///Deletes state for sites identified as potential bounce trackers, immediately.
    ///---
    ///Return Type: [RunBounceTrackingMitigationsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RunBounceTrackingMitigations;
    impl crate::util::Command for RunBounceTrackingMitigations {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "runBounceTrackingMitigations"
        }
    }
    ///
    /// Parameter value for [SetAttributionReportingLocalTestingMode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttributionReportingLocalTestingModeParams {
        ///If enabled, noise is suppressed and reports are sent immediately.
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///https://wicg.github.io/attribution-reporting-api/
    ///---
    ///Parameter Type: [SetAttributionReportingLocalTestingModeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttributionReportingLocalTestingMode;
    impl crate::util::Command for SetAttributionReportingLocalTestingMode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAttributionReportingLocalTestingMode"
        }
    }
    ///
    /// Parameter value for [SetAttributionReportingTracking].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttributionReportingTrackingParams {
        #[serde(rename = "enable")]
        pub enable: bool,
    }
    ///Enables/disables issuing of Attribution Reporting events.
    ///---
    ///Parameter Type: [SetAttributionReportingTrackingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAttributionReportingTracking;
    impl crate::util::Command for SetAttributionReportingTracking {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAttributionReportingTracking"
        }
    }
    ///A cache's contents have been modified.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CacheStorageContentUpdatedEvent {
        ///Origin to update.
        #[serde(rename = "origin")]
        pub origin: String,
        ///Storage key to update.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        ///Storage bucket to update.
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
        ///Name of cache in origin.
        #[serde(rename = "cacheName")]
        pub cache_name: String,
    }
    ///A cache has been added/deleted.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CacheStorageListUpdatedEvent {
        ///Origin to update.
        #[serde(rename = "origin")]
        pub origin: String,
        ///Storage key to update.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        ///Storage bucket to update.
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
    }
    ///The origin's IndexedDB object store has been modified.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct IndexedDbContentUpdatedEvent {
        ///Origin to update.
        #[serde(rename = "origin")]
        pub origin: String,
        ///Storage key to update.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        ///Storage bucket to update.
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
        ///Database to update.
        #[serde(rename = "databaseName")]
        pub database_name: String,
        ///ObjectStore to update.
        #[serde(rename = "objectStoreName")]
        pub object_store_name: String,
    }
    ///The origin's IndexedDB database list has been modified.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct IndexedDbListUpdatedEvent {
        ///Origin to update.
        #[serde(rename = "origin")]
        pub origin: String,
        ///Storage key to update.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        ///Storage bucket to update.
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
    }
    ///One of the interest groups was accessed by the associated page.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InterestGroupAccessedEvent {
        #[serde(rename = "accessTime")]
        pub access_time: crate::protocol_test::network::TimeSinceEpoch,
        #[serde(rename = "type")]
        pub type_: InterestGroupAccessType,
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
        #[serde(rename = "name")]
        pub name: String,
    }
    ///Shared storage was accessed by the associated page.
    ///The following parameters are included in all events.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SharedStorageAccessedEvent {
        ///Time of the access.
        #[serde(rename = "accessTime")]
        pub access_time: crate::protocol_test::network::TimeSinceEpoch,
        ///Enum value indicating the Shared Storage API method invoked.
        #[serde(rename = "type")]
        pub type_: SharedStorageAccessType,
        ///DevTools Frame Token for the primary frame tree's root.
        #[serde(rename = "mainFrameId")]
        pub main_frame_id: crate::protocol_test::page::FrameId,
        ///Serialized origin for the context that invoked the Shared Storage API.
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
        ///The sub-parameters warapped by `params` are all optional and their
        ///presence/absence depends on `type`.
        #[serde(rename = "params")]
        pub params: SharedStorageAccessParams,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StorageBucketCreatedOrUpdatedEvent {
        #[serde(rename = "bucketInfo")]
        pub bucket_info: StorageBucketInfo,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StorageBucketDeletedEvent {
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
    }
    ///TODO(crbug.com/1458532): Add other Attribution Reporting events, e.g.
    ///trigger registration.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttributionReportingSourceRegisteredEvent {
        #[serde(rename = "registration")]
        pub registration: AttributionReportingSourceRegistration,
        #[serde(rename = "result")]
        pub result: AttributionReportingSourceRegistrationResult,
    }
}
///The SystemInfo domain defines methods and events for querying low-level system information.
pub mod system_info {
    ///Describes a single graphics processor (GPU).
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GpuDevice {
        ///PCI ID of the GPU vendor, if available; 0 otherwise.
        #[serde(rename = "vendorId")]
        pub vendor_id: f64,
        ///PCI ID of the GPU device, if available; 0 otherwise.
        #[serde(rename = "deviceId")]
        pub device_id: f64,
        ///Sub sys ID of the GPU, only available on Windows.
        #[serde(rename = "subSysId")]
        pub sub_sys_id: Option<f64>,
        ///Revision of the GPU, only available on Windows.
        #[serde(rename = "revision")]
        pub revision: Option<f64>,
        ///String description of the GPU vendor, if the PCI ID is not available.
        #[serde(rename = "vendorString")]
        pub vendor_string: String,
        ///String description of the GPU device, if the PCI ID is not available.
        #[serde(rename = "deviceString")]
        pub device_string: String,
        ///String description of the GPU driver vendor.
        #[serde(rename = "driverVendor")]
        pub driver_vendor: String,
        ///String description of the GPU driver version.
        #[serde(rename = "driverVersion")]
        pub driver_version: String,
    }
    ///Describes the width and height dimensions of an entity.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Size {
        ///Width in pixels.
        #[serde(rename = "width")]
        pub width: i64,
        ///Height in pixels.
        #[serde(rename = "height")]
        pub height: i64,
    }
    ///Describes a supported video decoding profile with its associated minimum and
    ///maximum resolutions.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct VideoDecodeAcceleratorCapability {
        ///Video codec profile that is supported, e.g. VP9 Profile 2.
        #[serde(rename = "profile")]
        pub profile: String,
        ///Maximum video dimensions in pixels supported for this |profile|.
        #[serde(rename = "maxResolution")]
        pub max_resolution: Size,
        ///Minimum video dimensions in pixels supported for this |profile|.
        #[serde(rename = "minResolution")]
        pub min_resolution: Size,
    }
    ///Describes a supported video encoding profile with its associated maximum
    ///resolution and maximum framerate.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct VideoEncodeAcceleratorCapability {
        ///Video codec profile that is supported, e.g H264 Main.
        #[serde(rename = "profile")]
        pub profile: String,
        ///Maximum video dimensions in pixels supported for this |profile|.
        #[serde(rename = "maxResolution")]
        pub max_resolution: Size,
        ///Maximum encoding framerate in frames per second supported for this
        ///|profile|, as fraction's numerator and denominator, e.g. 24/1 fps,
        ///24000/1001 fps, etc.
        #[serde(rename = "maxFramerateNumerator")]
        pub max_framerate_numerator: i64,
        #[serde(rename = "maxFramerateDenominator")]
        pub max_framerate_denominator: i64,
    }
    ///YUV subsampling type of the pixels of a given image.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SubsamplingFormat {
        #[serde(rename = "yuv420")]
        Yuv420,
        #[serde(rename = "yuv422")]
        Yuv422,
        #[serde(rename = "yuv444")]
        Yuv444,
    }
    ///Image format of a given image.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ImageType {
        #[serde(rename = "jpeg")]
        Jpeg,
        #[serde(rename = "webp")]
        Webp,
        #[serde(rename = "unknown")]
        Unknown,
    }
    ///Describes a supported image decoding profile with its associated minimum and
    ///maximum resolutions and subsampling.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ImageDecodeAcceleratorCapability {
        ///Image coded, e.g. Jpeg.
        #[serde(rename = "imageType")]
        pub image_type: ImageType,
        ///Maximum supported dimensions of the image in pixels.
        #[serde(rename = "maxDimensions")]
        pub max_dimensions: Size,
        ///Minimum supported dimensions of the image in pixels.
        #[serde(rename = "minDimensions")]
        pub min_dimensions: Size,
        ///Optional array of supported subsampling formats, e.g. 4:2:0, if known.
        #[serde(rename = "subsamplings")]
        pub subsamplings: Vec<SubsamplingFormat>,
    }
    ///Provides information about the GPU(s) on the system.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GpuInfo {
        ///The graphics devices on the system. Element 0 is the primary GPU.
        #[serde(rename = "devices")]
        pub devices: Vec<GpuDevice>,
        ///An optional dictionary of additional GPU related attributes.
        #[serde(rename = "auxAttributes")]
        pub aux_attributes: Option<serde_json::Map<String, serde_json::Value>>,
        ///An optional dictionary of graphics features and their status.
        #[serde(rename = "featureStatus")]
        pub feature_status: Option<serde_json::Map<String, serde_json::Value>>,
        ///An optional array of GPU driver bug workarounds.
        #[serde(rename = "driverBugWorkarounds")]
        pub driver_bug_workarounds: Vec<String>,
        ///Supported accelerated video decoding capabilities.
        #[serde(rename = "videoDecoding")]
        pub video_decoding: Vec<VideoDecodeAcceleratorCapability>,
        ///Supported accelerated video encoding capabilities.
        #[serde(rename = "videoEncoding")]
        pub video_encoding: Vec<VideoEncodeAcceleratorCapability>,
        ///Supported accelerated image decoding capabilities.
        #[serde(rename = "imageDecoding")]
        pub image_decoding: Vec<ImageDecodeAcceleratorCapability>,
    }
    ///Represents process info.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ProcessInfo {
        ///Specifies process type.
        #[serde(rename = "type")]
        pub type_: String,
        ///Specifies process id.
        #[serde(rename = "id")]
        pub id: i64,
        ///Specifies cumulative CPU usage in seconds across all threads of the
        ///process since the process start.
        #[serde(rename = "cpuTime")]
        pub cpu_time: f64,
    }
    ///
    /// Return value for [GetInfo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInfoReturns {
        ///Information about the GPUs on the system.
        #[serde(rename = "gpu")]
        pub gpu: GpuInfo,
        ///A platform-dependent description of the model of the machine. On Mac OS, this is, for
        ///example, 'MacBookPro'. Will be the empty string if not supported.
        #[serde(rename = "modelName")]
        pub model_name: String,
        ///A platform-dependent description of the version of the machine. On Mac OS, this is, for
        ///example, '10.1'. Will be the empty string if not supported.
        #[serde(rename = "modelVersion")]
        pub model_version: String,
        ///The command line string used to launch the browser. Will be the empty string if not
        ///supported.
        #[serde(rename = "commandLine")]
        pub command_line: String,
    }
    ///Returns information about the system.
    ///---
    ///Return Type: [GetInfoReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetInfo;
    impl crate::util::Command for GetInfo {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getInfo"
        }
    }
    ///
    /// Parameter value for [GetFeatureState].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFeatureStateParams {
        #[serde(rename = "featureState")]
        pub feature_state: String,
    }
    ///
    /// Return value for [GetFeatureState].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFeatureStateReturns {
        #[serde(rename = "featureEnabled")]
        pub feature_enabled: bool,
    }
    ///Returns information about the feature state.
    ///---
    ///Parameter Type: [GetFeatureStateParams]
    ///Return Type: [GetFeatureStateReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetFeatureState;
    impl crate::util::Command for GetFeatureState {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getFeatureState"
        }
    }
    ///
    /// Return value for [GetProcessInfo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetProcessInfoReturns {
        ///An array of process info blocks.
        #[serde(rename = "processInfo")]
        pub process_info: Vec<ProcessInfo>,
    }
    ///Returns information about all running processes.
    ///---
    ///Return Type: [GetProcessInfoReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetProcessInfo;
    impl crate::util::Command for GetProcessInfo {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getProcessInfo"
        }
    }
}
///Supports additional targets discovery and allows to attach to them.
pub mod target {
    pub type TargetId = String;
    ///Unique identifier of attached debugging session.
    pub type SessionId = String;
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TargetInfo {
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "url")]
        pub url: String,
        ///Whether the target has an attached client.
        #[serde(rename = "attached")]
        pub attached: bool,
        ///Opener target Id
        #[serde(rename = "openerId")]
        pub opener_id: Option<TargetId>,
        ///Whether the target has access to the originating window.
        #[serde(rename = "canAccessOpener")]
        pub can_access_opener: bool,
        ///Frame id of originating window (is only set if target has an opener).
        #[serde(rename = "openerFrameId")]
        pub opener_frame_id: Option<crate::protocol_test::page::FrameId>,
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<crate::protocol_test::browser::BrowserContextId>,
        ///Provides additional details for specific target types. For example, for
        ///the type of "page", this may be set to "portal" or "prerender".
        #[serde(rename = "subtype")]
        pub subtype: Option<String>,
    }
    ///A filter used by target query/discovery/auto-attach operations.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FilterEntry {
        ///If set, causes exclusion of mathcing targets from the list.
        #[serde(rename = "exclude")]
        pub exclude: Option<bool>,
        ///If not present, matches any type.
        #[serde(rename = "type")]
        pub type_: Option<String>,
    }
    ///The entries in TargetFilter are matched sequentially against targets and
    ///the first entry that matches determines if the target is included or not,
    ///depending on the value of `exclude` field in the entry.
    ///If filter is not specified, the one assumed is
    ///[{type: "browser", exclude: true}, {type: "tab", exclude: true}, {}]
    ///(i.e. include everything but `browser` and `tab`).
    pub type TargetFilter = Vec<FilterEntry>;
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoteLocation {
        #[serde(rename = "host")]
        pub host: String,
        #[serde(rename = "port")]
        pub port: i64,
    }
    ///
    /// Parameter value for [ActivateTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ActivateTargetParams {
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
    }
    ///Activates (focuses) the target.
    ///---
    ///Parameter Type: [ActivateTargetParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ActivateTarget;
    impl crate::util::Command for ActivateTarget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "activateTarget"
        }
    }
    ///
    /// Parameter value for [AttachToTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttachToTargetParams {
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
        ///Enables "flat" access to the session via specifying sessionId attribute in the commands.
        ///We plan to make this the default, deprecate non-flattened mode,
        ///and eventually retire it. See crbug.com/991325.
        #[serde(rename = "flatten")]
        pub flatten: Option<bool>,
    }
    ///
    /// Return value for [AttachToTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttachToTargetReturns {
        ///Id assigned to the session.
        #[serde(rename = "sessionId")]
        pub session_id: SessionId,
    }
    ///Attaches to the target with given id.
    ///---
    ///Parameter Type: [AttachToTargetParams]
    ///Return Type: [AttachToTargetReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttachToTarget;
    impl crate::util::Command for AttachToTarget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "attachToTarget"
        }
    }
    ///
    /// Return value for [AttachToBrowserTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttachToBrowserTargetReturns {
        ///Id assigned to the session.
        #[serde(rename = "sessionId")]
        pub session_id: SessionId,
    }
    ///Attaches to the browser target, only uses flat sessionId mode.
    ///---
    ///Return Type: [AttachToBrowserTargetReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttachToBrowserTarget;
    impl crate::util::Command for AttachToBrowserTarget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "attachToBrowserTarget"
        }
    }
    ///
    /// Parameter value for [CloseTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CloseTargetParams {
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
    }
    ///
    /// Return value for [CloseTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CloseTargetReturns {
        ///Always set to true. If an error occurs, the response indicates protocol error.
        #[deprecated]
        #[serde(rename = "success")]
        pub success: bool,
    }
    ///Closes the target. If the target is a page that gets closed too.
    ///---
    ///Parameter Type: [CloseTargetParams]
    ///Return Type: [CloseTargetReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CloseTarget;
    impl crate::util::Command for CloseTarget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "closeTarget"
        }
    }
    ///
    /// Parameter value for [ExposeDevToolsProtocol].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExposeDevToolsProtocolParams {
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
        ///Binding name, 'cdp' if not specified.
        #[serde(rename = "bindingName")]
        pub binding_name: Option<String>,
    }
    ///Inject object to the target's main frame that provides a communication
    ///channel with browser target.
    ///
    ///Injected object will be available as `window[bindingName]`.
    ///
    ///The object has the follwing API:
    ///- `binding.send(json)` - a method to send messages over the remote debugging protocol
    ///- `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
    ///---
    ///Parameter Type: [ExposeDevToolsProtocolParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExposeDevToolsProtocol;
    impl crate::util::Command for ExposeDevToolsProtocol {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "exposeDevToolsProtocol"
        }
    }
    ///
    /// Parameter value for [CreateBrowserContext].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateBrowserContextParams {
        ///If specified, disposes this context when debugging session disconnects.
        #[serde(rename = "disposeOnDetach")]
        pub dispose_on_detach: Option<bool>,
        ///Proxy server, similar to the one passed to --proxy-server
        #[serde(rename = "proxyServer")]
        pub proxy_server: Option<String>,
        ///Proxy bypass list, similar to the one passed to --proxy-bypass-list
        #[serde(rename = "proxyBypassList")]
        pub proxy_bypass_list: Option<String>,
        ///An optional list of origins to grant unlimited cross-origin access to.
        ///Parts of the URL other than those constituting origin are ignored.
        #[serde(rename = "originsWithUniversalNetworkAccess")]
        pub origins_with_universal_network_access: Option<Vec<String>>,
    }
    ///
    /// Return value for [CreateBrowserContext].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateBrowserContextReturns {
        ///The id of the context created.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: crate::protocol_test::browser::BrowserContextId,
    }
    ///Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    ///one.
    ///---
    ///Parameter Type: [CreateBrowserContextParams]
    ///Return Type: [CreateBrowserContextReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateBrowserContext;
    impl crate::util::Command for CreateBrowserContext {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "createBrowserContext"
        }
    }
    ///
    /// Return value for [GetBrowserContexts].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBrowserContextsReturns {
        ///An array of browser context ids.
        #[serde(rename = "browserContextIds")]
        pub browser_context_ids: Vec<crate::protocol_test::browser::BrowserContextId>,
    }
    ///Returns all browser contexts created with `Target.createBrowserContext` method.
    ///---
    ///Return Type: [GetBrowserContextsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBrowserContexts;
    impl crate::util::Command for GetBrowserContexts {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getBrowserContexts"
        }
    }
    ///
    /// Parameter value for [CreateTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateTargetParams {
        ///The initial URL the page will be navigated to. An empty string indicates about:blank.
        #[serde(rename = "url")]
        pub url: String,
        ///Frame width in DIP (headless chrome only).
        #[serde(rename = "width")]
        pub width: Option<i64>,
        ///Frame height in DIP (headless chrome only).
        #[serde(rename = "height")]
        pub height: Option<i64>,
        ///The browser context to create the page in.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<crate::protocol_test::browser::BrowserContextId>,
        ///Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,
        ///not supported on MacOS yet, false by default).
        #[serde(rename = "enableBeginFrameControl")]
        pub enable_begin_frame_control: Option<bool>,
        ///Whether to create a new Window or Tab (chrome-only, false by default).
        #[serde(rename = "newWindow")]
        pub new_window: Option<bool>,
        ///Whether to create the target in background or foreground (chrome-only,
        ///false by default).
        #[serde(rename = "background")]
        pub background: Option<bool>,
        ///Whether to create the target of type "tab".
        #[serde(rename = "forTab")]
        pub for_tab: Option<bool>,
    }
    ///
    /// Return value for [CreateTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateTargetReturns {
        ///The id of the page opened.
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
    }
    ///Creates a new page.
    ///---
    ///Parameter Type: [CreateTargetParams]
    ///Return Type: [CreateTargetReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreateTarget;
    impl crate::util::Command for CreateTarget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "createTarget"
        }
    }
    ///
    /// Parameter value for [DetachFromTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DetachFromTargetParams {
        ///Session to detach.
        #[serde(rename = "sessionId")]
        pub session_id: Option<SessionId>,
        ///Deprecated.
        #[deprecated]
        #[serde(rename = "targetId")]
        pub target_id: Option<TargetId>,
    }
    ///Detaches session with given id.
    ///---
    ///Parameter Type: [DetachFromTargetParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DetachFromTarget;
    impl crate::util::Command for DetachFromTarget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "detachFromTarget"
        }
    }
    ///
    /// Parameter value for [DisposeBrowserContext].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DisposeBrowserContextParams {
        #[serde(rename = "browserContextId")]
        pub browser_context_id: crate::protocol_test::browser::BrowserContextId,
    }
    ///Deletes a BrowserContext. All the belonging pages will be closed without calling their
    ///beforeunload hooks.
    ///---
    ///Parameter Type: [DisposeBrowserContextParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DisposeBrowserContext;
    impl crate::util::Command for DisposeBrowserContext {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disposeBrowserContext"
        }
    }
    ///
    /// Parameter value for [GetTargetInfo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTargetInfoParams {
        #[serde(rename = "targetId")]
        pub target_id: Option<TargetId>,
    }
    ///
    /// Return value for [GetTargetInfo].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTargetInfoReturns {
        #[serde(rename = "targetInfo")]
        pub target_info: TargetInfo,
    }
    ///Returns information about a target.
    ///---
    ///Parameter Type: [GetTargetInfoParams]
    ///Return Type: [GetTargetInfoReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTargetInfo;
    impl crate::util::Command for GetTargetInfo {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getTargetInfo"
        }
    }
    ///
    /// Parameter value for [GetTargets].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTargetsParams {
        ///Only targets matching filter will be reported. If filter is not specified
        ///and target discovery is currently enabled, a filter used for target discovery
        ///is used for consistency.
        #[serde(rename = "filter")]
        pub filter: Option<TargetFilter>,
    }
    ///
    /// Return value for [GetTargets].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTargetsReturns {
        ///The list of targets.
        #[serde(rename = "targetInfos")]
        pub target_infos: Vec<TargetInfo>,
    }
    ///Retrieves a list of available targets.
    ///---
    ///Parameter Type: [GetTargetsParams]
    ///Return Type: [GetTargetsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetTargets;
    impl crate::util::Command for GetTargets {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getTargets"
        }
    }
    ///
    /// Parameter value for [SendMessageToTarget].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendMessageToTargetParams {
        #[serde(rename = "message")]
        pub message: String,
        ///Identifier of the session.
        #[serde(rename = "sessionId")]
        pub session_id: Option<SessionId>,
        ///Deprecated.
        #[deprecated]
        #[serde(rename = "targetId")]
        pub target_id: Option<TargetId>,
    }
    ///Sends protocol message over session with given id.
    ///Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    ///and crbug.com/991325.
    ///---
    ///Parameter Type: [SendMessageToTargetParams]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendMessageToTarget;
    impl crate::util::Command for SendMessageToTarget {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "sendMessageToTarget"
        }
    }
    ///
    /// Parameter value for [SetAutoAttach].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAutoAttachParams {
        ///Whether to auto-attach to related targets.
        #[serde(rename = "autoAttach")]
        pub auto_attach: bool,
        ///Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
        ///to run paused targets.
        #[serde(rename = "waitForDebuggerOnStart")]
        pub wait_for_debugger_on_start: bool,
        ///Enables "flat" access to the session via specifying sessionId attribute in the commands.
        ///We plan to make this the default, deprecate non-flattened mode,
        ///and eventually retire it. See crbug.com/991325.
        #[serde(rename = "flatten")]
        pub flatten: Option<bool>,
        ///Only targets matching filter will be attached.
        #[serde(rename = "filter")]
        pub filter: Option<TargetFilter>,
    }
    ///Controls whether to automatically attach to new targets which are considered to be related to
    ///this one. When turned on, attaches to all existing related targets as well. When turned off,
    ///automatically detaches from all currently attached targets.
    ///This also clears all targets added by `autoAttachRelated` from the list of targets to watch
    ///for creation of related targets.
    ///---
    ///Parameter Type: [SetAutoAttachParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAutoAttach;
    impl crate::util::Command for SetAutoAttach {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAutoAttach"
        }
    }
    ///
    /// Parameter value for [AutoAttachRelated].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AutoAttachRelatedParams {
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
        ///Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
        ///to run paused targets.
        #[serde(rename = "waitForDebuggerOnStart")]
        pub wait_for_debugger_on_start: bool,
        ///Only targets matching filter will be attached.
        #[serde(rename = "filter")]
        pub filter: Option<TargetFilter>,
    }
    ///Adds the specified target to the list of targets that will be monitored for any related target
    ///creation (such as child frames, child workers and new versions of service worker) and reported
    ///through `attachedToTarget`. The specified target is also auto-attached.
    ///This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
    ///`setAutoAttach`. Only available at the Browser target.
    ///---
    ///Parameter Type: [AutoAttachRelatedParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AutoAttachRelated;
    impl crate::util::Command for AutoAttachRelated {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "autoAttachRelated"
        }
    }
    ///
    /// Parameter value for [SetDiscoverTargets].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDiscoverTargetsParams {
        ///Whether to discover available targets.
        #[serde(rename = "discover")]
        pub discover: bool,
        ///Only targets matching filter will be attached. If `discover` is false,
        ///`filter` must be omitted or empty.
        #[serde(rename = "filter")]
        pub filter: Option<TargetFilter>,
    }
    ///Controls whether to discover available targets and notify via
    ///`targetCreated/targetInfoChanged/targetDestroyed` events.
    ///---
    ///Parameter Type: [SetDiscoverTargetsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetDiscoverTargets;
    impl crate::util::Command for SetDiscoverTargets {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setDiscoverTargets"
        }
    }
    ///
    /// Parameter value for [SetRemoteLocations].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRemoteLocationsParams {
        ///List of remote locations.
        #[serde(rename = "locations")]
        pub locations: Vec<RemoteLocation>,
    }
    ///Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
    ///`true`.
    ///---
    ///Parameter Type: [SetRemoteLocationsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetRemoteLocations;
    impl crate::util::Command for SetRemoteLocations {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setRemoteLocations"
        }
    }
    ///Issued when attached to target because of auto-attach or `attachToTarget` command.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AttachedToTargetEvent {
        ///Identifier assigned to the session used to send/receive messages.
        #[serde(rename = "sessionId")]
        pub session_id: SessionId,
        #[serde(rename = "targetInfo")]
        pub target_info: TargetInfo,
        #[serde(rename = "waitingForDebugger")]
        pub waiting_for_debugger: bool,
    }
    ///Issued when detached from target for any reason (including `detachFromTarget` command). Can be
    ///issued multiple times per target if multiple sessions have been attached to it.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DetachedFromTargetEvent {
        ///Detached session identifier.
        #[serde(rename = "sessionId")]
        pub session_id: SessionId,
        ///Deprecated.
        #[deprecated]
        #[serde(rename = "targetId")]
        pub target_id: Option<TargetId>,
    }
    ///Notifies about a new protocol message received from the session (as reported in
    ///`attachedToTarget` event).
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReceivedMessageFromTargetEvent {
        ///Identifier of a session which sends a message.
        #[serde(rename = "sessionId")]
        pub session_id: SessionId,
        #[serde(rename = "message")]
        pub message: String,
        ///Deprecated.
        #[deprecated]
        #[serde(rename = "targetId")]
        pub target_id: Option<TargetId>,
    }
    ///Issued when a possible inspection target is created.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TargetCreatedEvent {
        #[serde(rename = "targetInfo")]
        pub target_info: TargetInfo,
    }
    ///Issued when a target is destroyed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TargetDestroyedEvent {
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
    }
    ///Issued when a target has crashed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TargetCrashedEvent {
        #[serde(rename = "targetId")]
        pub target_id: TargetId,
        ///Termination status type.
        #[serde(rename = "status")]
        pub status: String,
        ///Termination error code.
        #[serde(rename = "errorCode")]
        pub error_code: i64,
    }
    ///Issued when some information about a target has changed. This only happens between
    ///`targetCreated` and `targetDestroyed`.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TargetInfoChangedEvent {
        #[serde(rename = "targetInfo")]
        pub target_info: TargetInfo,
    }
}
///The Tethering domain defines methods and events for browser port binding.
pub mod tethering {
    ///
    /// Parameter value for [Bind].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BindParams {
        ///Port number to bind.
        #[serde(rename = "port")]
        pub port: i64,
    }
    ///Request browser port binding.
    ///---
    ///Parameter Type: [BindParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Bind;
    impl crate::util::Command for Bind {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "bind"
        }
    }
    ///
    /// Parameter value for [Unbind].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UnbindParams {
        ///Port number to unbind.
        #[serde(rename = "port")]
        pub port: i64,
    }
    ///Request browser port unbinding.
    ///---
    ///Parameter Type: [UnbindParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Unbind;
    impl crate::util::Command for Unbind {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "unbind"
        }
    }
    ///Informs that port was successfully bound and got a specified connection id.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AcceptedEvent {
        ///Port number that was successfully bound.
        #[serde(rename = "port")]
        pub port: i64,
        ///Connection id to be used.
        #[serde(rename = "connectionId")]
        pub connection_id: String,
    }
}
pub mod tracing {
    ///Configuration for memory dump. Used only when "memory-infra" category is enabled.
    pub type MemoryDumpConfig = serde_json::Map<String, serde_json::Value>;
    ///
    /// Enum for [TraceConfig]'s `record_mode`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum TraceConfigRecordMode {
        #[serde(rename = "recordUntilFull")]
        RecordUntilFull,
        #[serde(rename = "recordContinuously")]
        RecordContinuously,
        #[serde(rename = "recordAsMuchAsPossible")]
        RecordAsMuchAsPossible,
        #[serde(rename = "echoToConsole")]
        EchoToConsole,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TraceConfig {
        ///Controls how the trace buffer stores data.
        #[serde(rename = "recordMode")]
        pub record_mode: Option<Option<TraceConfigRecordMode>>,
        ///Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value
        ///of 200 MB would be used.
        #[serde(rename = "traceBufferSizeInKb")]
        pub trace_buffer_size_in_kb: Option<f64>,
        ///Turns on JavaScript stack sampling.
        #[serde(rename = "enableSampling")]
        pub enable_sampling: Option<bool>,
        ///Turns on system tracing.
        #[serde(rename = "enableSystrace")]
        pub enable_systrace: Option<bool>,
        ///Turns on argument filter.
        #[serde(rename = "enableArgumentFilter")]
        pub enable_argument_filter: Option<bool>,
        ///Included category filters.
        #[serde(rename = "includedCategories")]
        pub included_categories: Option<Vec<String>>,
        ///Excluded category filters.
        #[serde(rename = "excludedCategories")]
        pub excluded_categories: Option<Vec<String>>,
        ///Configuration to synthesize the delays in tracing.
        #[serde(rename = "syntheticDelays")]
        pub synthetic_delays: Option<Vec<String>>,
        ///Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.
        #[serde(rename = "memoryDumpConfig")]
        pub memory_dump_config: Option<MemoryDumpConfig>,
    }
    ///Data format of a trace. Can be either the legacy JSON format or the
    ///protocol buffer format. Note that the JSON format will be deprecated soon.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum StreamFormat {
        #[serde(rename = "json")]
        Json,
        #[serde(rename = "proto")]
        Proto,
    }
    ///Compression type to use for traces returned via streams.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum StreamCompression {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "gzip")]
        Gzip,
    }
    ///Details exposed when memory request explicitly declared.
    ///Keep consistent with memory_dump_request_args.h and
    ///memory_instrumentation.mojom
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum MemoryDumpLevelOfDetail {
        #[serde(rename = "background")]
        Background,
        #[serde(rename = "light")]
        Light,
        #[serde(rename = "detailed")]
        Detailed,
    }
    ///Backend type to use for tracing. `chrome` uses the Chrome-integrated
    ///tracing service and is supported on all platforms. `system` is only
    ///supported on Chrome OS and uses the Perfetto system tracing service.
    ///`auto` chooses `system` when the perfettoConfig provided to Tracing.start
    ///specifies at least one non-Chrome data source; otherwise uses `chrome`.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum TracingBackend {
        #[serde(rename = "auto")]
        Auto,
        #[serde(rename = "chrome")]
        Chrome,
        #[serde(rename = "system")]
        System,
    }
    ///Stop trace events collection.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct End;
    impl crate::util::Command for End {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "end"
        }
    }
    ///
    /// Return value for [GetCategories].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCategoriesReturns {
        ///A list of supported tracing categories.
        #[serde(rename = "categories")]
        pub categories: Vec<String>,
    }
    ///Gets supported tracing categories.
    ///---
    ///Return Type: [GetCategoriesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCategories;
    impl crate::util::Command for GetCategories {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getCategories"
        }
    }
    ///
    /// Parameter value for [RecordClockSyncMarker].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RecordClockSyncMarkerParams {
        ///The ID of this clock sync marker
        #[serde(rename = "syncId")]
        pub sync_id: String,
    }
    ///Record a clock sync marker in the trace.
    ///---
    ///Parameter Type: [RecordClockSyncMarkerParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RecordClockSyncMarker;
    impl crate::util::Command for RecordClockSyncMarker {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "recordClockSyncMarker"
        }
    }
    ///
    /// Parameter value for [RequestMemoryDump].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestMemoryDumpParams {
        ///Enables more deterministic results by forcing garbage collection
        #[serde(rename = "deterministic")]
        pub deterministic: Option<bool>,
        ///Specifies level of details in memory dump. Defaults to "detailed".
        #[serde(rename = "levelOfDetail")]
        pub level_of_detail: Option<MemoryDumpLevelOfDetail>,
    }
    ///
    /// Return value for [RequestMemoryDump].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestMemoryDumpReturns {
        ///GUID of the resulting global memory dump.
        #[serde(rename = "dumpGuid")]
        pub dump_guid: String,
        ///True iff the global memory dump succeeded.
        #[serde(rename = "success")]
        pub success: bool,
    }
    ///Request a global memory dump.
    ///---
    ///Parameter Type: [RequestMemoryDumpParams]
    ///Return Type: [RequestMemoryDumpReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestMemoryDump;
    impl crate::util::Command for RequestMemoryDump {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "requestMemoryDump"
        }
    }
    ///
    /// Enum for [Start]'s `transfer_mode`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum StartTransferMode {
        #[serde(rename = "ReportEvents")]
        ReportEvents,
        #[serde(rename = "ReturnAsStream")]
        ReturnAsStream,
    }
    ///
    /// Parameter value for [Start].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartParams {
        ///Category/tag filter
        #[deprecated]
        #[serde(rename = "categories")]
        pub categories: Option<String>,
        ///Tracing options
        #[deprecated]
        #[serde(rename = "options")]
        pub options: Option<String>,
        ///If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
        #[serde(rename = "bufferUsageReportingInterval")]
        pub buffer_usage_reporting_interval: Option<f64>,
        ///Whether to report trace events as series of dataCollected events or to save trace to a
        ///stream (defaults to `ReportEvents`).
        #[serde(rename = "transferMode")]
        pub transfer_mode: Option<Option<StartTransferMode>>,
        ///Trace data format to use. This only applies when using `ReturnAsStream`
        ///transfer mode (defaults to `json`).
        #[serde(rename = "streamFormat")]
        pub stream_format: Option<StreamFormat>,
        ///Compression format to use. This only applies when using `ReturnAsStream`
        ///transfer mode (defaults to `none`)
        #[serde(rename = "streamCompression")]
        pub stream_compression: Option<StreamCompression>,
        #[serde(rename = "traceConfig")]
        pub trace_config: Option<TraceConfig>,
        ///Base64-encoded serialized perfetto.protos.TraceConfig protobuf message
        ///When specified, the parameters `categories`, `options`, `traceConfig`
        ///are ignored. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "perfettoConfig")]
        pub perfetto_config: Option<String>,
        ///Backend type (defaults to `auto`)
        #[serde(rename = "tracingBackend")]
        pub tracing_backend: Option<TracingBackend>,
    }
    ///Start trace events collection.
    ///---
    ///Parameter Type: [StartParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Start;
    impl crate::util::Command for Start {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "start"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BufferUsageEvent {
        ///A number in range [0..1] that indicates the used size of event buffer as a fraction of its
        ///total size.
        #[serde(rename = "percentFull")]
        pub percent_full: Option<f64>,
        ///An approximate number of events in the trace log.
        #[serde(rename = "eventCount")]
        pub event_count: Option<f64>,
        ///A number in range [0..1] that indicates the used size of event buffer as a fraction of its
        ///total size.
        #[serde(rename = "value")]
        pub value: Option<f64>,
    }
    ///Contains a bucket of collected trace events. When tracing is stopped collected events will be
    ///sent as a sequence of dataCollected events followed by tracingComplete event.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DataCollectedEvent {
        #[serde(rename = "value")]
        pub value: Vec<serde_json::Map<String, serde_json::Value>>,
    }
    ///Signals that tracing is stopped and there is no trace buffers pending flush, all data were
    ///delivered via dataCollected events.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TracingCompleteEvent {
        ///Indicates whether some trace data is known to have been lost, e.g. because the trace ring
        ///buffer wrapped around.
        #[serde(rename = "dataLossOccurred")]
        pub data_loss_occurred: bool,
        ///A handle of the stream that holds resulting trace data.
        #[serde(rename = "stream")]
        pub stream: Option<crate::protocol_test::io::StreamHandle>,
        ///Trace data format of returned stream.
        #[serde(rename = "traceFormat")]
        pub trace_format: Option<StreamFormat>,
        ///Compression format of returned stream.
        #[serde(rename = "streamCompression")]
        pub stream_compression: Option<StreamCompression>,
    }
}
///A domain for letting clients substitute browser's network layer with client code.
pub mod fetch {
    ///Unique request identifier.
    pub type RequestId = String;
    ///Stages of the request to handle. Request will intercept before the request is
    ///sent. Response will intercept after the response is received (but before response
    ///body is received).
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum RequestStage {
        #[serde(rename = "Request")]
        Request,
        #[serde(rename = "Response")]
        Response,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestPattern {
        ///Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
        ///backslash. Omitting is equivalent to `"*"`.
        #[serde(rename = "urlPattern")]
        pub url_pattern: Option<String>,
        ///If set, only requests for matching resource types will be intercepted.
        #[serde(rename = "resourceType")]
        pub resource_type: Option<crate::protocol_test::network::ResourceType>,
        ///Stage at which to begin intercepting requests. Default is Request.
        #[serde(rename = "requestStage")]
        pub request_stage: Option<RequestStage>,
    }
    ///Response HTTP header entry
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HeaderEntry {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "value")]
        pub value: String,
    }
    ///
    /// Enum for [AuthChallenge]'s `source`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AuthChallengeSource {
        #[serde(rename = "Server")]
        Server,
        #[serde(rename = "Proxy")]
        Proxy,
    }
    ///Authorization challenge for HTTP status code 401 or 407.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AuthChallenge {
        ///Source of the authentication challenge.
        #[serde(rename = "source")]
        pub source: Option<Option<AuthChallengeSource>>,
        ///Origin of the challenger.
        #[serde(rename = "origin")]
        pub origin: String,
        ///The authentication scheme used, such as basic or digest
        #[serde(rename = "scheme")]
        pub scheme: String,
        ///The realm of the challenge. May be empty.
        #[serde(rename = "realm")]
        pub realm: String,
    }
    ///
    /// Enum for [AuthChallengeResponse]'s `response`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AuthChallengeResponseResponse {
        #[serde(rename = "Default")]
        Default,
        #[serde(rename = "CancelAuth")]
        CancelAuth,
        #[serde(rename = "ProvideCredentials")]
        ProvideCredentials,
    }
    ///Response to an AuthChallenge.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AuthChallengeResponse {
        ///The decision on what to do in response to the authorization challenge.  Default means
        ///deferring to the default behavior of the net stack, which will likely either the Cancel
        ///authentication or display a popup dialog box.
        #[serde(rename = "response")]
        pub response: AuthChallengeResponseResponse,
        ///The username to provide, possibly empty. Should only be set if response is
        ///ProvideCredentials.
        #[serde(rename = "username")]
        pub username: Option<String>,
        ///The password to provide, possibly empty. Should only be set if response is
        ///ProvideCredentials.
        #[serde(rename = "password")]
        pub password: Option<String>,
    }
    ///Disables the fetch domain.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        ///If specified, only requests matching any of these patterns will produce
        ///fetchRequested event and will be paused until clients response. If not set,
        ///all requests will be affected.
        #[serde(rename = "patterns")]
        pub patterns: Option<Vec<RequestPattern>>,
        ///If true, authRequired events will be issued and requests will be paused
        ///expecting a call to continueWithAuth.
        #[serde(rename = "handleAuthRequests")]
        pub handle_auth_requests: Option<bool>,
    }
    ///Enables issuing of requestPaused events. A request will be paused until client
    ///calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
    ///---
    ///Parameter Type: [EnableParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [FailRequest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FailRequestParams {
        ///An id the client received in requestPaused event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Causes the request to fail with the given reason.
        #[serde(rename = "errorReason")]
        pub error_reason: crate::protocol_test::network::ErrorReason,
    }
    ///Causes the request to fail with specified reason.
    ///---
    ///Parameter Type: [FailRequestParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FailRequest;
    impl crate::util::Command for FailRequest {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "failRequest"
        }
    }
    ///
    /// Parameter value for [FulfillRequest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FulfillRequestParams {
        ///An id the client received in requestPaused event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///An HTTP response code.
        #[serde(rename = "responseCode")]
        pub response_code: i64,
        ///Response headers.
        #[serde(rename = "responseHeaders")]
        pub response_headers: Option<Vec<HeaderEntry>>,
        ///Alternative way of specifying response headers as a \0-separated
        ///series of name: value pairs. Prefer the above method unless you
        ///need to represent some non-UTF8 values that can't be transmitted
        ///over the protocol as text. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "binaryResponseHeaders")]
        pub binary_response_headers: Option<String>,
        ///A response body. If absent, original response body will be used if
        ///the request is intercepted at the response stage and empty body
        ///will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "body")]
        pub body: Option<String>,
        ///A textual representation of responseCode.
        ///If absent, a standard phrase matching responseCode is used.
        #[serde(rename = "responsePhrase")]
        pub response_phrase: Option<String>,
    }
    ///Provides response to the request.
    ///---
    ///Parameter Type: [FulfillRequestParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FulfillRequest;
    impl crate::util::Command for FulfillRequest {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "fulfillRequest"
        }
    }
    ///
    /// Parameter value for [ContinueRequest].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueRequestParams {
        ///An id the client received in requestPaused event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///If set, the request url will be modified in a way that's not observable by page.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///If set, the request method is overridden.
        #[serde(rename = "method")]
        pub method: Option<String>,
        ///If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "postData")]
        pub post_data: Option<String>,
        ///If set, overrides the request headers. Note that the overrides do not
        ///extend to subsequent redirect hops, if a redirect happens. Another override
        ///may be applied to a different request produced by a redirect.
        #[serde(rename = "headers")]
        pub headers: Option<Vec<HeaderEntry>>,
        ///If set, overrides response interception behavior for this request.
        #[serde(rename = "interceptResponse")]
        pub intercept_response: Option<bool>,
    }
    ///Continues the request, optionally modifying some of its parameters.
    ///---
    ///Parameter Type: [ContinueRequestParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueRequest;
    impl crate::util::Command for ContinueRequest {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "continueRequest"
        }
    }
    ///
    /// Parameter value for [ContinueWithAuth].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueWithAuthParams {
        ///An id the client received in authRequired event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///Response to  with an authChallenge.
        #[serde(rename = "authChallengeResponse")]
        pub auth_challenge_response: AuthChallengeResponse,
    }
    ///Continues a request supplying authChallengeResponse following authRequired event.
    ///---
    ///Parameter Type: [ContinueWithAuthParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueWithAuth;
    impl crate::util::Command for ContinueWithAuth {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "continueWithAuth"
        }
    }
    ///
    /// Parameter value for [ContinueResponse].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueResponseParams {
        ///An id the client received in requestPaused event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///An HTTP response code. If absent, original response code will be used.
        #[serde(rename = "responseCode")]
        pub response_code: Option<i64>,
        ///A textual representation of responseCode.
        ///If absent, a standard phrase matching responseCode is used.
        #[serde(rename = "responsePhrase")]
        pub response_phrase: Option<String>,
        ///Response headers. If absent, original response headers will be used.
        #[serde(rename = "responseHeaders")]
        pub response_headers: Option<Vec<HeaderEntry>>,
        ///Alternative way of specifying response headers as a \0-separated
        ///series of name: value pairs. Prefer the above method unless you
        ///need to represent some non-UTF8 values that can't be transmitted
        ///over the protocol as text. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "binaryResponseHeaders")]
        pub binary_response_headers: Option<String>,
    }
    ///Continues loading of the paused response, optionally modifying the
    ///response headers. If either responseCode or headers are modified, all of them
    ///must be present.
    ///---
    ///Parameter Type: [ContinueResponseParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueResponse;
    impl crate::util::Command for ContinueResponse {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "continueResponse"
        }
    }
    ///
    /// Parameter value for [GetResponseBody].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBodyParams {
        ///Identifier for the intercepted request to get body for.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
    }
    ///
    /// Return value for [GetResponseBody].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBodyReturns {
        ///Response body.
        #[serde(rename = "body")]
        pub body: String,
        ///True, if content was sent as base64.
        #[serde(rename = "base64Encoded")]
        pub base_64_encoded: bool,
    }
    ///Causes the body of the response to be received from the server and
    ///returned as a single string. May only be issued for a request that
    ///is paused in the Response stage and is mutually exclusive with
    ///takeResponseBodyForInterceptionAsStream. Calling other methods that
    ///affect the request or disabling fetch domain before body is received
    ///results in an undefined behavior.
    ///Note that the response body is not available for redirects. Requests
    ///paused in the _redirect received_ state may be differentiated by
    ///`responseCode` and presence of `location` response header, see
    ///comments to `requestPaused` for details.
    ///---
    ///Parameter Type: [GetResponseBodyParams]
    ///Return Type: [GetResponseBodyReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetResponseBody;
    impl crate::util::Command for GetResponseBody {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getResponseBody"
        }
    }
    ///
    /// Parameter value for [TakeResponseBodyAsStream].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeResponseBodyAsStreamParams {
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
    }
    ///
    /// Return value for [TakeResponseBodyAsStream].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeResponseBodyAsStreamReturns {
        #[serde(rename = "stream")]
        pub stream: crate::protocol_test::io::StreamHandle,
    }
    ///Returns a handle to the stream representing the response body.
    ///The request must be paused in the HeadersReceived stage.
    ///Note that after this command the request can't be continued
    ///as is -- client either needs to cancel it or to provide the
    ///response body.
    ///The stream only supports sequential read, IO.read will fail if the position
    ///is specified.
    ///This method is mutually exclusive with getResponseBody.
    ///Calling other methods that affect the request or disabling fetch
    ///domain before body is received results in an undefined behavior.
    ///---
    ///Parameter Type: [TakeResponseBodyAsStreamParams]
    ///Return Type: [TakeResponseBodyAsStreamReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeResponseBodyAsStream;
    impl crate::util::Command for TakeResponseBodyAsStream {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "takeResponseBodyAsStream"
        }
    }
    ///Issued when the domain is enabled and the request URL matches the
    ///specified filter. The request is paused until the client responds
    ///with one of continueRequest, failRequest or fulfillRequest.
    ///The stage of the request can be determined by presence of responseErrorReason
    ///and responseStatusCode -- the request is at the response stage if either
    ///of these fields is present and in the request stage otherwise.
    ///Redirect responses and subsequent requests are reported similarly to regular
    ///responses and requests. Redirect responses may be distinguished by the value
    ///of `responseStatusCode` (which is one of 301, 302, 303, 307, 308) along with
    ///presence of the `location` header. Requests resulting from a redirect will
    ///have `redirectedRequestId` field set.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RequestPausedEvent {
        ///Each request the page makes will have a unique id.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///The details of the request.
        #[serde(rename = "request")]
        pub request: crate::protocol_test::network::Request,
        ///The id of the frame that initiated the request.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        ///How the requested resource will be used.
        #[serde(rename = "resourceType")]
        pub resource_type: crate::protocol_test::network::ResourceType,
        ///Response error if intercepted at response stage.
        #[serde(rename = "responseErrorReason")]
        pub response_error_reason: Option<crate::protocol_test::network::ErrorReason>,
        ///Response code if intercepted at response stage.
        #[serde(rename = "responseStatusCode")]
        pub response_status_code: Option<i64>,
        ///Response status text if intercepted at response stage.
        #[serde(rename = "responseStatusText")]
        pub response_status_text: Option<String>,
        ///Response headers if intercepted at the response stage.
        #[serde(rename = "responseHeaders")]
        pub response_headers: Option<Vec<HeaderEntry>>,
        ///If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
        ///then this networkId will be the same as the requestId present in the requestWillBeSent event.
        #[serde(rename = "networkId")]
        pub network_id: Option<crate::protocol_test::network::RequestId>,
        ///If the request is due to a redirect response from the server, the id of the request that
        ///has caused the redirect.
        #[serde(rename = "redirectedRequestId")]
        pub redirected_request_id: Option<RequestId>,
    }
    ///Issued when the domain is enabled with handleAuthRequests set to true.
    ///The request is paused until client responds with continueWithAuth.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AuthRequiredEvent {
        ///Each request the page makes will have a unique id.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        ///The details of the request.
        #[serde(rename = "request")]
        pub request: crate::protocol_test::network::Request,
        ///The id of the frame that initiated the request.
        #[serde(rename = "frameId")]
        pub frame_id: crate::protocol_test::page::FrameId,
        ///How the requested resource will be used.
        #[serde(rename = "resourceType")]
        pub resource_type: crate::protocol_test::network::ResourceType,
        ///Details of the Authorization Challenge encountered.
        ///If this is set, client should respond with continueRequest that
        ///contains AuthChallengeResponse.
        #[serde(rename = "authChallenge")]
        pub auth_challenge: AuthChallenge,
    }
}
///This domain allows inspection of Web Audio API.
///https://webaudio.github.io/web-audio-api/
pub mod web_audio {
    ///An unique ID for a graph object (AudioContext, AudioNode, AudioParam) in Web Audio API
    pub type GraphObjectId = String;
    ///Enum of BaseAudioContext types
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ContextType {
        #[serde(rename = "realtime")]
        Realtime,
        #[serde(rename = "offline")]
        Offline,
    }
    ///Enum of AudioContextState from the spec
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ContextState {
        #[serde(rename = "suspended")]
        Suspended,
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "closed")]
        Closed,
    }
    ///Enum of AudioNode types
    pub type NodeType = String;
    ///Enum of AudioNode::ChannelCountMode from the spec
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ChannelCountMode {
        #[serde(rename = "clamped-max")]
        ClampedMax,
        #[serde(rename = "explicit")]
        Explicit,
        #[serde(rename = "max")]
        Max,
    }
    ///Enum of AudioNode::ChannelInterpretation from the spec
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ChannelInterpretation {
        #[serde(rename = "discrete")]
        Discrete,
        #[serde(rename = "speakers")]
        Speakers,
    }
    ///Enum of AudioParam types
    pub type ParamType = String;
    ///Enum of AudioParam::AutomationRate from the spec
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AutomationRate {
        #[serde(rename = "a-rate")]
        ARate,
        #[serde(rename = "k-rate")]
        KRate,
    }
    ///Fields in AudioContext that change in real-time.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContextRealtimeData {
        ///The current context time in second in BaseAudioContext.
        #[serde(rename = "currentTime")]
        pub current_time: f64,
        ///The time spent on rendering graph divided by render quantum duration,
        ///and multiplied by 100. 100 means the audio renderer reached the full
        ///capacity and glitch may occur.
        #[serde(rename = "renderCapacity")]
        pub render_capacity: f64,
        ///A running mean of callback interval.
        #[serde(rename = "callbackIntervalMean")]
        pub callback_interval_mean: f64,
        ///A running variance of callback interval.
        #[serde(rename = "callbackIntervalVariance")]
        pub callback_interval_variance: f64,
    }
    ///Protocol object for BaseAudioContext
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BaseAudioContext {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "contextType")]
        pub context_type: ContextType,
        #[serde(rename = "contextState")]
        pub context_state: ContextState,
        #[serde(rename = "realtimeData")]
        pub realtime_data: Option<ContextRealtimeData>,
        ///Platform-dependent callback buffer size.
        #[serde(rename = "callbackBufferSize")]
        pub callback_buffer_size: f64,
        ///Number of output channels supported by audio hardware in use.
        #[serde(rename = "maxOutputChannelCount")]
        pub max_output_channel_count: f64,
        ///Context sample rate.
        #[serde(rename = "sampleRate")]
        pub sample_rate: f64,
    }
    ///Protocol object for AudioListener
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioListener {
        #[serde(rename = "listenerId")]
        pub listener_id: GraphObjectId,
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
    }
    ///Protocol object for AudioNode
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioNode {
        #[serde(rename = "nodeId")]
        pub node_id: GraphObjectId,
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "nodeType")]
        pub node_type: NodeType,
        #[serde(rename = "numberOfInputs")]
        pub number_of_inputs: f64,
        #[serde(rename = "numberOfOutputs")]
        pub number_of_outputs: f64,
        #[serde(rename = "channelCount")]
        pub channel_count: f64,
        #[serde(rename = "channelCountMode")]
        pub channel_count_mode: ChannelCountMode,
        #[serde(rename = "channelInterpretation")]
        pub channel_interpretation: ChannelInterpretation,
    }
    ///Protocol object for AudioParam
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioParam {
        #[serde(rename = "paramId")]
        pub param_id: GraphObjectId,
        #[serde(rename = "nodeId")]
        pub node_id: GraphObjectId,
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "paramType")]
        pub param_type: ParamType,
        #[serde(rename = "rate")]
        pub rate: AutomationRate,
        #[serde(rename = "defaultValue")]
        pub default_value: f64,
        #[serde(rename = "minValue")]
        pub min_value: f64,
        #[serde(rename = "maxValue")]
        pub max_value: f64,
    }
    ///Enables the WebAudio domain and starts sending context lifetime events.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///Disables the WebAudio domain.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [GetRealtimeData].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRealtimeDataParams {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
    }
    ///
    /// Return value for [GetRealtimeData].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRealtimeDataReturns {
        #[serde(rename = "realtimeData")]
        pub realtime_data: ContextRealtimeData,
    }
    ///Fetch the realtime data from the registered contexts.
    ///---
    ///Parameter Type: [GetRealtimeDataParams]
    ///Return Type: [GetRealtimeDataReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetRealtimeData;
    impl crate::util::Command for GetRealtimeData {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getRealtimeData"
        }
    }
    ///Notifies that a new BaseAudioContext has been created.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContextCreatedEvent {
        #[serde(rename = "context")]
        pub context: BaseAudioContext,
    }
    ///Notifies that an existing BaseAudioContext will be destroyed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContextWillBeDestroyedEvent {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
    }
    ///Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContextChangedEvent {
        #[serde(rename = "context")]
        pub context: BaseAudioContext,
    }
    ///Notifies that the construction of an AudioListener has finished.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioListenerCreatedEvent {
        #[serde(rename = "listener")]
        pub listener: AudioListener,
    }
    ///Notifies that a new AudioListener has been created.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioListenerWillBeDestroyedEvent {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "listenerId")]
        pub listener_id: GraphObjectId,
    }
    ///Notifies that a new AudioNode has been created.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioNodeCreatedEvent {
        #[serde(rename = "node")]
        pub node: AudioNode,
    }
    ///Notifies that an existing AudioNode has been destroyed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioNodeWillBeDestroyedEvent {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "nodeId")]
        pub node_id: GraphObjectId,
    }
    ///Notifies that a new AudioParam has been created.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioParamCreatedEvent {
        #[serde(rename = "param")]
        pub param: AudioParam,
    }
    ///Notifies that an existing AudioParam has been destroyed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AudioParamWillBeDestroyedEvent {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "nodeId")]
        pub node_id: GraphObjectId,
        #[serde(rename = "paramId")]
        pub param_id: GraphObjectId,
    }
    ///Notifies that two AudioNodes are connected.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NodesConnectedEvent {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "sourceId")]
        pub source_id: GraphObjectId,
        #[serde(rename = "destinationId")]
        pub destination_id: GraphObjectId,
        #[serde(rename = "sourceOutputIndex")]
        pub source_output_index: Option<f64>,
        #[serde(rename = "destinationInputIndex")]
        pub destination_input_index: Option<f64>,
    }
    ///Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NodesDisconnectedEvent {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "sourceId")]
        pub source_id: GraphObjectId,
        #[serde(rename = "destinationId")]
        pub destination_id: GraphObjectId,
        #[serde(rename = "sourceOutputIndex")]
        pub source_output_index: Option<f64>,
        #[serde(rename = "destinationInputIndex")]
        pub destination_input_index: Option<f64>,
    }
    ///Notifies that an AudioNode is connected to an AudioParam.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NodeParamConnectedEvent {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "sourceId")]
        pub source_id: GraphObjectId,
        #[serde(rename = "destinationId")]
        pub destination_id: GraphObjectId,
        #[serde(rename = "sourceOutputIndex")]
        pub source_output_index: Option<f64>,
    }
    ///Notifies that an AudioNode is disconnected to an AudioParam.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NodeParamDisconnectedEvent {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "sourceId")]
        pub source_id: GraphObjectId,
        #[serde(rename = "destinationId")]
        pub destination_id: GraphObjectId,
        #[serde(rename = "sourceOutputIndex")]
        pub source_output_index: Option<f64>,
    }
}
///This domain allows configuring virtual authenticators to test the WebAuthn
///API.
pub mod web_authn {
    pub type AuthenticatorId = String;
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AuthenticatorProtocol {
        #[serde(rename = "u2f")]
        U2F,
        #[serde(rename = "ctap2")]
        Ctap2,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum Ctap2Version {
        #[serde(rename = "ctap2_0")]
        Ctap20,
        #[serde(rename = "ctap2_1")]
        Ctap21,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum AuthenticatorTransport {
        #[serde(rename = "usb")]
        Usb,
        #[serde(rename = "nfc")]
        Nfc,
        #[serde(rename = "ble")]
        Ble,
        #[serde(rename = "cable")]
        Cable,
        #[serde(rename = "internal")]
        Internal,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct VirtualAuthenticatorOptions {
        #[serde(rename = "protocol")]
        pub protocol: AuthenticatorProtocol,
        ///Defaults to ctap2_0. Ignored if |protocol| == u2f.
        #[serde(rename = "ctap2Version")]
        pub ctap_2_version: Option<Ctap2Version>,
        #[serde(rename = "transport")]
        pub transport: AuthenticatorTransport,
        ///Defaults to false.
        #[serde(rename = "hasResidentKey")]
        pub has_resident_key: Option<bool>,
        ///Defaults to false.
        #[serde(rename = "hasUserVerification")]
        pub has_user_verification: Option<bool>,
        ///If set to true, the authenticator will support the largeBlob extension.
        ///https://w3c.github.io/webauthn#largeBlob
        ///Defaults to false.
        #[serde(rename = "hasLargeBlob")]
        pub has_large_blob: Option<bool>,
        ///If set to true, the authenticator will support the credBlob extension.
        ///https://fidoalliance.org/specs/fido-v2.1-rd-20201208/fido-client-to-authenticator-protocol-v2.1-rd-20201208.html#sctn-credBlob-extension
        ///Defaults to false.
        #[serde(rename = "hasCredBlob")]
        pub has_cred_blob: Option<bool>,
        ///If set to true, the authenticator will support the minPinLength extension.
        ///https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension
        ///Defaults to false.
        #[serde(rename = "hasMinPinLength")]
        pub has_min_pin_length: Option<bool>,
        ///If set to true, the authenticator will support the prf extension.
        ///https://w3c.github.io/webauthn/#prf-extension
        ///Defaults to false.
        #[serde(rename = "hasPrf")]
        pub has_prf: Option<bool>,
        ///If set to true, tests of user presence will succeed immediately.
        ///Otherwise, they will not be resolved. Defaults to true.
        #[serde(rename = "automaticPresenceSimulation")]
        pub automatic_presence_simulation: Option<bool>,
        ///Sets whether User Verification succeeds or fails for an authenticator.
        ///Defaults to false.
        #[serde(rename = "isUserVerified")]
        pub is_user_verified: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Credential {
        #[serde(rename = "credentialId")]
        pub credential_id: String,
        #[serde(rename = "isResidentCredential")]
        pub is_resident_credential: bool,
        ///Relying Party ID the credential is scoped to. Must be set when adding a
        ///credential.
        #[serde(rename = "rpId")]
        pub rp_id: Option<String>,
        ///The ECDSA P-256 private key in PKCS#8 format. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "privateKey")]
        pub private_key: String,
        ///An opaque byte sequence with a maximum size of 64 bytes mapping the
        ///credential to a specific user. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "userHandle")]
        pub user_handle: Option<String>,
        ///Signature counter. This is incremented by one for each successful
        ///assertion.
        ///See https://w3c.github.io/webauthn/#signature-counter
        #[serde(rename = "signCount")]
        pub sign_count: i64,
        ///The large blob associated with the credential.
        ///See https://w3c.github.io/webauthn/#sctn-large-blob-extension (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "largeBlob")]
        pub large_blob: Option<String>,
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        ///Whether to enable the WebAuthn user interface. Enabling the UI is
        ///recommended for debugging and demo purposes, as it is closer to the real
        ///experience. Disabling the UI is recommended for automated testing.
        ///Supported at the embedder's discretion if UI is available.
        ///Defaults to false.
        #[serde(rename = "enableUI")]
        pub enable_ui: Option<bool>,
    }
    ///Enable the WebAuthn domain and start intercepting credential storage and
    ///retrieval with a virtual authenticator.
    ///---
    ///Parameter Type: [EnableParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///Disable the WebAuthn domain.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [AddVirtualAuthenticator].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddVirtualAuthenticatorParams {
        #[serde(rename = "options")]
        pub options: VirtualAuthenticatorOptions,
    }
    ///
    /// Return value for [AddVirtualAuthenticator].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddVirtualAuthenticatorReturns {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
    }
    ///Creates and adds a virtual authenticator.
    ///---
    ///Parameter Type: [AddVirtualAuthenticatorParams]
    ///Return Type: [AddVirtualAuthenticatorReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddVirtualAuthenticator;
    impl crate::util::Command for AddVirtualAuthenticator {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addVirtualAuthenticator"
        }
    }
    ///
    /// Parameter value for [SetResponseOverrideBits].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetResponseOverrideBitsParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        ///If isBogusSignature is set, overrides the signature in the authenticator response to be zero.
        ///Defaults to false.
        #[serde(rename = "isBogusSignature")]
        pub is_bogus_signature: Option<bool>,
        ///If isBadUV is set, overrides the UV bit in the flags in the authenticator response to
        ///be zero. Defaults to false.
        #[serde(rename = "isBadUV")]
        pub is_bad_uv: Option<bool>,
        ///If isBadUP is set, overrides the UP bit in the flags in the authenticator response to
        ///be zero. Defaults to false.
        #[serde(rename = "isBadUP")]
        pub is_bad_up: Option<bool>,
    }
    ///Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
    ///---
    ///Parameter Type: [SetResponseOverrideBitsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetResponseOverrideBits;
    impl crate::util::Command for SetResponseOverrideBits {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setResponseOverrideBits"
        }
    }
    ///
    /// Parameter value for [RemoveVirtualAuthenticator].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveVirtualAuthenticatorParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
    }
    ///Removes the given authenticator.
    ///---
    ///Parameter Type: [RemoveVirtualAuthenticatorParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveVirtualAuthenticator;
    impl crate::util::Command for RemoveVirtualAuthenticator {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeVirtualAuthenticator"
        }
    }
    ///
    /// Parameter value for [AddCredential].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddCredentialParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        #[serde(rename = "credential")]
        pub credential: Credential,
    }
    ///Adds the credential to the specified authenticator.
    ///---
    ///Parameter Type: [AddCredentialParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddCredential;
    impl crate::util::Command for AddCredential {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addCredential"
        }
    }
    ///
    /// Parameter value for [GetCredential].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCredentialParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        #[serde(rename = "credentialId")]
        pub credential_id: String,
    }
    ///
    /// Return value for [GetCredential].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCredentialReturns {
        #[serde(rename = "credential")]
        pub credential: Credential,
    }
    ///Returns a single credential stored in the given virtual authenticator that
    ///matches the credential ID.
    ///---
    ///Parameter Type: [GetCredentialParams]
    ///Return Type: [GetCredentialReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCredential;
    impl crate::util::Command for GetCredential {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getCredential"
        }
    }
    ///
    /// Parameter value for [GetCredentials].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCredentialsParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
    }
    ///
    /// Return value for [GetCredentials].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCredentialsReturns {
        #[serde(rename = "credentials")]
        pub credentials: Vec<Credential>,
    }
    ///Returns all the credentials stored in the given virtual authenticator.
    ///---
    ///Parameter Type: [GetCredentialsParams]
    ///Return Type: [GetCredentialsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetCredentials;
    impl crate::util::Command for GetCredentials {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getCredentials"
        }
    }
    ///
    /// Parameter value for [RemoveCredential].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveCredentialParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        #[serde(rename = "credentialId")]
        pub credential_id: String,
    }
    ///Removes a credential from the authenticator.
    ///---
    ///Parameter Type: [RemoveCredentialParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveCredential;
    impl crate::util::Command for RemoveCredential {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeCredential"
        }
    }
    ///
    /// Parameter value for [ClearCredentials].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearCredentialsParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
    }
    ///Clears all the credentials from the specified device.
    ///---
    ///Parameter Type: [ClearCredentialsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearCredentials;
    impl crate::util::Command for ClearCredentials {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearCredentials"
        }
    }
    ///
    /// Parameter value for [SetUserVerified].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetUserVerifiedParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        #[serde(rename = "isUserVerified")]
        pub is_user_verified: bool,
    }
    ///Sets whether User Verification succeeds or fails for an authenticator.
    ///The default is true.
    ///---
    ///Parameter Type: [SetUserVerifiedParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetUserVerified;
    impl crate::util::Command for SetUserVerified {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setUserVerified"
        }
    }
    ///
    /// Parameter value for [SetAutomaticPresenceSimulation].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAutomaticPresenceSimulationParams {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    ///Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
    ///The default is true.
    ///---
    ///Parameter Type: [SetAutomaticPresenceSimulationParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAutomaticPresenceSimulation;
    impl crate::util::Command for SetAutomaticPresenceSimulation {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAutomaticPresenceSimulation"
        }
    }
    ///Triggered when a credential is added to an authenticator.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CredentialAddedEvent {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        #[serde(rename = "credential")]
        pub credential: Credential,
    }
    ///Triggered when a credential is used in a webauthn assertion.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CredentialAssertedEvent {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        #[serde(rename = "credential")]
        pub credential: Credential,
    }
}
///This domain allows detailed inspection of media elements
pub mod media {
    ///Players will get an ID that is unique within the agent context.
    pub type PlayerId = String;
    pub type Timestamp = f64;
    ///
    /// Enum for [PlayerMessage]'s `level`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PlayerMessageLevel {
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "warning")]
        Warning,
        #[serde(rename = "info")]
        Info,
        #[serde(rename = "debug")]
        Debug,
    }
    ///Have one type per entry in MediaLogRecord::Type
    ///Corresponds to kMessage
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerMessage {
        ///Keep in sync with MediaLogMessageLevel
        ///We are currently keeping the message level 'error' separate from the
        ///PlayerError type because right now they represent different things,
        ///this one being a DVLOG(ERROR) style log message that gets printed
        ///based on what log level is selected in the UI, and the other is a
        ///representation of a media::PipelineStatus object. Soon however we're
        ///going to be moving away from using PipelineStatus for errors and
        ///introducing a new error type which should hopefully let us integrate
        ///the error log level into the PlayerError type.
        #[serde(rename = "level")]
        pub level: PlayerMessageLevel,
        #[serde(rename = "message")]
        pub message: String,
    }
    ///Corresponds to kMediaPropertyChange
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerProperty {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Corresponds to kMediaEventTriggered
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerEvent {
        #[serde(rename = "timestamp")]
        pub timestamp: Timestamp,
        #[serde(rename = "value")]
        pub value: String,
    }
    ///Represents logged source line numbers reported in an error.
    ///NOTE: file and line are from chromium c++ implementation code, not js.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerErrorSourceLocation {
        #[serde(rename = "file")]
        pub file: String,
        #[serde(rename = "line")]
        pub line: i64,
    }
    ///Corresponds to kMediaError
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerError {
        #[serde(rename = "errorType")]
        pub error_type: String,
        ///Code is the numeric enum entry for a specific set of error codes, such
        ///as PipelineStatusCodes in media/base/pipeline_status.h
        #[serde(rename = "code")]
        pub code: i64,
        ///A trace of where this error was caused / where it passed through.
        #[serde(rename = "stack")]
        pub stack: Vec<PlayerErrorSourceLocation>,
        ///Errors potentially have a root cause error, ie, a DecoderError might be
        ///caused by an WindowsError
        #[serde(rename = "cause")]
        pub cause: Vec<PlayerError>,
        ///Extra data attached to an error, such as an HRESULT, Video Codec, etc.
        #[serde(rename = "data")]
        pub data: serde_json::Map<String, serde_json::Value>,
    }
    ///Enables the Media domain
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///Disables the Media domain.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///This can be called multiple times, and can be used to set / override /
    ///remove player properties. A null propValue indicates removal.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerPropertiesChangedEvent {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        #[serde(rename = "properties")]
        pub properties: Vec<PlayerProperty>,
    }
    ///Send events as a list, allowing them to be batched on the browser for less
    ///congestion. If batched, events must ALWAYS be in chronological order.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerEventsAddedEvent {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        #[serde(rename = "events")]
        pub events: Vec<PlayerEvent>,
    }
    ///Send a list of any messages that need to be delivered.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerMessagesLoggedEvent {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        #[serde(rename = "messages")]
        pub messages: Vec<PlayerMessage>,
    }
    ///Send a list of any errors that need to be delivered.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayerErrorsRaisedEvent {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        #[serde(rename = "errors")]
        pub errors: Vec<PlayerError>,
    }
    ///Called whenever a player is created, or when a new agent joins and receives
    ///a list of active players. If an agent is restored, it will receive the full
    ///list of player ids and all events again.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PlayersCreatedEvent {
        #[serde(rename = "players")]
        pub players: Vec<PlayerId>,
    }
}
pub mod device_access {
    ///Device request id.
    pub type RequestId = String;
    ///A device id.
    pub type DeviceId = String;
    ///Device information displayed in a user prompt to select a device.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PromptDevice {
        #[serde(rename = "id")]
        pub id: DeviceId,
        ///Display name as it appears in a device request user prompt.
        #[serde(rename = "name")]
        pub name: String,
    }
    ///Enable events in this domain.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///Disable events in this domain.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [SelectPrompt].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SelectPromptParams {
        #[serde(rename = "id")]
        pub id: RequestId,
        #[serde(rename = "deviceId")]
        pub device_id: DeviceId,
    }
    ///Select a device in response to a DeviceAccess.deviceRequestPrompted event.
    ///---
    ///Parameter Type: [SelectPromptParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SelectPrompt;
    impl crate::util::Command for SelectPrompt {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "selectPrompt"
        }
    }
    ///
    /// Parameter value for [CancelPrompt].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CancelPromptParams {
        #[serde(rename = "id")]
        pub id: RequestId,
    }
    ///Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
    ///---
    ///Parameter Type: [CancelPromptParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CancelPrompt;
    impl crate::util::Command for CancelPrompt {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "cancelPrompt"
        }
    }
    ///A device request opened a user prompt to select a device. Respond with the
    ///selectPrompt or cancelPrompt command.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeviceRequestPromptedEvent {
        #[serde(rename = "id")]
        pub id: RequestId,
        #[serde(rename = "devices")]
        pub devices: Vec<PromptDevice>,
    }
}
pub mod preload {
    ///Unique id
    pub type RuleSetId = String;
    ///Corresponds to SpeculationRuleSet
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RuleSet {
        #[serde(rename = "id")]
        pub id: RuleSetId,
        ///Identifies a document which the rule set is associated with.
        #[serde(rename = "loaderId")]
        pub loader_id: crate::protocol_test::network::LoaderId,
        ///Source text of JSON representing the rule set. If it comes from
        ///`<script>` tag, it is the textContent of the node. Note that it is
        ///a JSON for valid case.
        ///
        ///See also:
        ///- https://wicg.github.io/nav-speculation/speculation-rules.html
        ///- https://github.com/WICG/nav-speculation/blob/main/triggers.md
        #[serde(rename = "sourceText")]
        pub source_text: String,
        ///A speculation rule set is either added through an inline
        ///`<script>` tag or through an external resource via the
        ///'Speculation-Rules' HTTP header. For the first case, we include
        ///the BackendNodeId of the relevant `<script>` tag. For the second
        ///case, we include the external URL where the rule set was loaded
        ///from, and also RequestId if Network domain is enabled.
        ///
        ///See also:
        ///- https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-script
        ///- https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-header
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<crate::protocol_test::dom::BackendNodeId>,
        #[serde(rename = "url")]
        pub url: Option<String>,
        #[serde(rename = "requestId")]
        pub request_id: Option<crate::protocol_test::network::RequestId>,
        ///Error information
        ///`errorMessage` is null iff `errorType` is null.
        #[serde(rename = "errorType")]
        pub error_type: Option<RuleSetErrorType>,
        ///TODO(https://crbug.com/1425354): Replace this property with structured error.
        #[deprecated]
        #[serde(rename = "errorMessage")]
        pub error_message: Option<String>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum RuleSetErrorType {
        #[serde(rename = "SourceIsNotJsonObject")]
        SourceIsNotJsonObject,
        #[serde(rename = "InvalidRulesSkipped")]
        InvalidRulesSkipped,
    }
    ///The type of preloading attempted. It corresponds to
    ///mojom::SpeculationAction (although PrefetchWithSubresources is omitted as it
    ///isn't being used by clients).
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SpeculationAction {
        #[serde(rename = "Prefetch")]
        Prefetch,
        #[serde(rename = "Prerender")]
        Prerender,
    }
    ///Corresponds to mojom::SpeculationTargetHint.
    ///See https://github.com/WICG/nav-speculation/blob/main/triggers.md#window-name-targeting-hints
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SpeculationTargetHint {
        #[serde(rename = "Blank")]
        Blank,
        #[serde(rename = "Self")]
        Self_,
    }
    ///A key that identifies a preloading attempt.
    ///
    ///The url used is the url specified by the trigger (i.e. the initial URL), and
    ///not the final url that is navigated to. For example, prerendering allows
    ///same-origin main frame navigations during the attempt, but the attempt is
    ///still keyed with the initial URL.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PreloadingAttemptKey {
        #[serde(rename = "loaderId")]
        pub loader_id: crate::protocol_test::network::LoaderId,
        #[serde(rename = "action")]
        pub action: SpeculationAction,
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "targetHint")]
        pub target_hint: Option<SpeculationTargetHint>,
    }
    ///Lists sources for a preloading attempt, specifically the ids of rule sets
    ///that had a speculation rule that triggered the attempt, and the
    ///BackendNodeIds of <a href> or <area href> elements that triggered the
    ///attempt (in the case of attempts triggered by a document rule). It is
    ///possible for mulitple rule sets and links to trigger a single attempt.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PreloadingAttemptSource {
        #[serde(rename = "key")]
        pub key: PreloadingAttemptKey,
        #[serde(rename = "ruleSetIds")]
        pub rule_set_ids: Vec<RuleSetId>,
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<crate::protocol_test::dom::BackendNodeId>,
    }
    ///List of FinalStatus reasons for Prerender2.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PrerenderFinalStatus {
        #[serde(rename = "Activated")]
        Activated,
        #[serde(rename = "Destroyed")]
        Destroyed,
        #[serde(rename = "LowEndDevice")]
        LowEndDevice,
        #[serde(rename = "InvalidSchemeRedirect")]
        InvalidSchemeRedirect,
        #[serde(rename = "InvalidSchemeNavigation")]
        InvalidSchemeNavigation,
        #[serde(rename = "InProgressNavigation")]
        InProgressNavigation,
        #[serde(rename = "NavigationRequestBlockedByCsp")]
        NavigationRequestBlockedByCsp,
        #[serde(rename = "MainFrameNavigation")]
        MainFrameNavigation,
        #[serde(rename = "MojoBinderPolicy")]
        MojoBinderPolicy,
        #[serde(rename = "RendererProcessCrashed")]
        RendererProcessCrashed,
        #[serde(rename = "RendererProcessKilled")]
        RendererProcessKilled,
        #[serde(rename = "Download")]
        Download,
        #[serde(rename = "TriggerDestroyed")]
        TriggerDestroyed,
        #[serde(rename = "NavigationNotCommitted")]
        NavigationNotCommitted,
        #[serde(rename = "NavigationBadHttpStatus")]
        NavigationBadHttpStatus,
        #[serde(rename = "ClientCertRequested")]
        ClientCertRequested,
        #[serde(rename = "NavigationRequestNetworkError")]
        NavigationRequestNetworkError,
        #[serde(rename = "MaxNumOfRunningPrerendersExceeded")]
        MaxNumOfRunningPrerendersExceeded,
        #[serde(rename = "CancelAllHostsForTesting")]
        CancelAllHostsForTesting,
        #[serde(rename = "DidFailLoad")]
        DidFailLoad,
        #[serde(rename = "Stop")]
        Stop,
        #[serde(rename = "SslCertificateError")]
        SslCertificateError,
        #[serde(rename = "LoginAuthRequested")]
        LoginAuthRequested,
        #[serde(rename = "UaChangeRequiresReload")]
        UaChangeRequiresReload,
        #[serde(rename = "BlockedByClient")]
        BlockedByClient,
        #[serde(rename = "AudioOutputDeviceRequested")]
        AudioOutputDeviceRequested,
        #[serde(rename = "MixedContent")]
        MixedContent,
        #[serde(rename = "TriggerBackgrounded")]
        TriggerBackgrounded,
        #[serde(rename = "MemoryLimitExceeded")]
        MemoryLimitExceeded,
        #[serde(rename = "FailToGetMemoryUsage")]
        FailToGetMemoryUsage,
        #[serde(rename = "DataSaverEnabled")]
        DataSaverEnabled,
        #[serde(rename = "HasEffectiveUrl")]
        HasEffectiveUrl,
        #[serde(rename = "ActivatedBeforeStarted")]
        ActivatedBeforeStarted,
        #[serde(rename = "InactivePageRestriction")]
        InactivePageRestriction,
        #[serde(rename = "StartFailed")]
        StartFailed,
        #[serde(rename = "TimeoutBackgrounded")]
        TimeoutBackgrounded,
        #[serde(rename = "CrossSiteRedirectInInitialNavigation")]
        CrossSiteRedirectInInitialNavigation,
        #[serde(rename = "CrossSiteNavigationInInitialNavigation")]
        CrossSiteNavigationInInitialNavigation,
        #[serde(rename = "SameSiteCrossOriginRedirectNotOptInInInitialNavigation")]
        SameSiteCrossOriginRedirectNotOptInInInitialNavigation,
        #[serde(rename = "SameSiteCrossOriginNavigationNotOptInInInitialNavigation")]
        SameSiteCrossOriginNavigationNotOptInInInitialNavigation,
        #[serde(rename = "ActivationNavigationParameterMismatch")]
        ActivationNavigationParameterMismatch,
        #[serde(rename = "ActivatedInBackground")]
        ActivatedInBackground,
        #[serde(rename = "EmbedderHostDisallowed")]
        EmbedderHostDisallowed,
        #[serde(rename = "ActivationNavigationDestroyedBeforeSuccess")]
        ActivationNavigationDestroyedBeforeSuccess,
        #[serde(rename = "TabClosedByUserGesture")]
        TabClosedByUserGesture,
        #[serde(rename = "TabClosedWithoutUserGesture")]
        TabClosedWithoutUserGesture,
        #[serde(rename = "PrimaryMainFrameRendererProcessCrashed")]
        PrimaryMainFrameRendererProcessCrashed,
        #[serde(rename = "PrimaryMainFrameRendererProcessKilled")]
        PrimaryMainFrameRendererProcessKilled,
        #[serde(rename = "ActivationFramePolicyNotCompatible")]
        ActivationFramePolicyNotCompatible,
        #[serde(rename = "PreloadingDisabled")]
        PreloadingDisabled,
        #[serde(rename = "BatterySaverEnabled")]
        BatterySaverEnabled,
        #[serde(rename = "ActivatedDuringMainFrameNavigation")]
        ActivatedDuringMainFrameNavigation,
        #[serde(rename = "PreloadingUnsupportedByWebContents")]
        PreloadingUnsupportedByWebContents,
        #[serde(rename = "CrossSiteRedirectInMainFrameNavigation")]
        CrossSiteRedirectInMainFrameNavigation,
        #[serde(rename = "CrossSiteNavigationInMainFrameNavigation")]
        CrossSiteNavigationInMainFrameNavigation,
        #[serde(rename = "SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation")]
        SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation,
        #[serde(rename = "SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation")]
        SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation,
        #[serde(rename = "MemoryPressureOnTrigger")]
        MemoryPressureOnTrigger,
        #[serde(rename = "MemoryPressureAfterTriggered")]
        MemoryPressureAfterTriggered,
        #[serde(rename = "PrerenderingDisabledByDevTools")]
        PrerenderingDisabledByDevTools,
        #[serde(rename = "ResourceLoadBlockedByClient")]
        ResourceLoadBlockedByClient,
        #[serde(rename = "SpeculationRuleRemoved")]
        SpeculationRuleRemoved,
        #[serde(rename = "ActivatedWithAuxiliaryBrowsingContexts")]
        ActivatedWithAuxiliaryBrowsingContexts,
    }
    ///Preloading status values, see also PreloadingTriggeringOutcome. This
    ///status is shared by prefetchStatusUpdated and prerenderStatusUpdated.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PreloadingStatus {
        #[serde(rename = "Pending")]
        Pending,
        #[serde(rename = "Running")]
        Running,
        #[serde(rename = "Ready")]
        Ready,
        #[serde(rename = "Success")]
        Success,
        #[serde(rename = "Failure")]
        Failure,
        #[serde(rename = "NotSupported")]
        NotSupported,
    }
    ///TODO(https://crbug.com/1384419): revisit the list of PrefetchStatus and
    ///filter out the ones that aren't necessary to the developers.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PrefetchStatus {
        #[serde(rename = "PrefetchAllowed")]
        PrefetchAllowed,
        #[serde(rename = "PrefetchFailedIneligibleRedirect")]
        PrefetchFailedIneligibleRedirect,
        #[serde(rename = "PrefetchFailedInvalidRedirect")]
        PrefetchFailedInvalidRedirect,
        #[serde(rename = "PrefetchFailedMIMENotSupported")]
        PrefetchFailedMimeNotSupported,
        #[serde(rename = "PrefetchFailedNetError")]
        PrefetchFailedNetError,
        #[serde(rename = "PrefetchFailedNon2XX")]
        PrefetchFailedNon2Xx,
        #[serde(rename = "PrefetchFailedPerPageLimitExceeded")]
        PrefetchFailedPerPageLimitExceeded,
        #[serde(rename = "PrefetchEvicted")]
        PrefetchEvicted,
        #[serde(rename = "PrefetchHeldback")]
        PrefetchHeldback,
        #[serde(rename = "PrefetchIneligibleRetryAfter")]
        PrefetchIneligibleRetryAfter,
        #[serde(rename = "PrefetchIsPrivacyDecoy")]
        PrefetchIsPrivacyDecoy,
        #[serde(rename = "PrefetchIsStale")]
        PrefetchIsStale,
        #[serde(rename = "PrefetchNotEligibleBrowserContextOffTheRecord")]
        PrefetchNotEligibleBrowserContextOffTheRecord,
        #[serde(rename = "PrefetchNotEligibleDataSaverEnabled")]
        PrefetchNotEligibleDataSaverEnabled,
        #[serde(rename = "PrefetchNotEligibleExistingProxy")]
        PrefetchNotEligibleExistingProxy,
        #[serde(rename = "PrefetchNotEligibleHostIsNonUnique")]
        PrefetchNotEligibleHostIsNonUnique,
        #[serde(rename = "PrefetchNotEligibleNonDefaultStoragePartition")]
        PrefetchNotEligibleNonDefaultStoragePartition,
        #[serde(rename = "PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy")]
        PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy,
        #[serde(rename = "PrefetchNotEligibleSchemeIsNotHttps")]
        PrefetchNotEligibleSchemeIsNotHttps,
        #[serde(rename = "PrefetchNotEligibleUserHasCookies")]
        PrefetchNotEligibleUserHasCookies,
        #[serde(rename = "PrefetchNotEligibleUserHasServiceWorker")]
        PrefetchNotEligibleUserHasServiceWorker,
        #[serde(rename = "PrefetchNotEligibleBatterySaverEnabled")]
        PrefetchNotEligibleBatterySaverEnabled,
        #[serde(rename = "PrefetchNotEligiblePreloadingDisabled")]
        PrefetchNotEligiblePreloadingDisabled,
        #[serde(rename = "PrefetchNotFinishedInTime")]
        PrefetchNotFinishedInTime,
        #[serde(rename = "PrefetchNotStarted")]
        PrefetchNotStarted,
        #[serde(rename = "PrefetchNotUsedCookiesChanged")]
        PrefetchNotUsedCookiesChanged,
        #[serde(rename = "PrefetchProxyNotAvailable")]
        PrefetchProxyNotAvailable,
        #[serde(rename = "PrefetchResponseUsed")]
        PrefetchResponseUsed,
        #[serde(rename = "PrefetchSuccessfulButNotUsed")]
        PrefetchSuccessfulButNotUsed,
        #[serde(rename = "PrefetchNotUsedProbeFailed")]
        PrefetchNotUsedProbeFailed,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Upsert. Currently, it is only emitted when a rule set added.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RuleSetUpdatedEvent {
        #[serde(rename = "ruleSet")]
        pub rule_set: RuleSet,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RuleSetRemovedEvent {
        #[serde(rename = "id")]
        pub id: RuleSetId,
    }
    ///Fired when a prerender attempt is completed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PrerenderAttemptCompletedEvent {
        #[serde(rename = "key")]
        pub key: PreloadingAttemptKey,
        ///The frame id of the frame initiating prerendering.
        #[serde(rename = "initiatingFrameId")]
        pub initiating_frame_id: crate::protocol_test::page::FrameId,
        #[serde(rename = "prerenderingUrl")]
        pub prerendering_url: String,
        #[serde(rename = "finalStatus")]
        pub final_status: PrerenderFinalStatus,
        ///This is used to give users more information about the name of the API call
        ///that is incompatible with prerender and has caused the cancellation of the attempt
        #[serde(rename = "disallowedApiMethod")]
        pub disallowed_api_method: Option<String>,
    }
    ///Fired when a preload enabled state is updated.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PreloadEnabledStateUpdatedEvent {
        #[serde(rename = "disabledByPreference")]
        pub disabled_by_preference: bool,
        #[serde(rename = "disabledByDataSaver")]
        pub disabled_by_data_saver: bool,
        #[serde(rename = "disabledByBatterySaver")]
        pub disabled_by_battery_saver: bool,
        #[serde(rename = "disabledByHoldbackPrefetchSpeculationRules")]
        pub disabled_by_holdback_prefetch_speculation_rules: bool,
        #[serde(rename = "disabledByHoldbackPrerenderSpeculationRules")]
        pub disabled_by_holdback_prerender_speculation_rules: bool,
    }
    ///Fired when a prefetch attempt is updated.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PrefetchStatusUpdatedEvent {
        #[serde(rename = "key")]
        pub key: PreloadingAttemptKey,
        ///The frame id of the frame initiating prefetch.
        #[serde(rename = "initiatingFrameId")]
        pub initiating_frame_id: crate::protocol_test::page::FrameId,
        #[serde(rename = "prefetchUrl")]
        pub prefetch_url: String,
        #[serde(rename = "status")]
        pub status: PreloadingStatus,
        #[serde(rename = "prefetchStatus")]
        pub prefetch_status: PrefetchStatus,
        #[serde(rename = "requestId")]
        pub request_id: crate::protocol_test::network::RequestId,
    }
    ///Fired when a prerender attempt is updated.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PrerenderStatusUpdatedEvent {
        #[serde(rename = "key")]
        pub key: PreloadingAttemptKey,
        #[serde(rename = "status")]
        pub status: PreloadingStatus,
        #[serde(rename = "prerenderStatus")]
        pub prerender_status: Option<PrerenderFinalStatus>,
        ///This is used to give users more information about the name of Mojo interface
        ///that is incompatible with prerender and has caused the cancellation of the attempt.
        #[serde(rename = "disallowedMojoInterface")]
        pub disallowed_mojo_interface: Option<String>,
    }
    ///Send a list of sources for all preloading attempts in a document.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PreloadingAttemptSourcesUpdatedEvent {
        #[serde(rename = "loaderId")]
        pub loader_id: crate::protocol_test::network::LoaderId,
        #[serde(rename = "preloadingAttemptSources")]
        pub preloading_attempt_sources: Vec<PreloadingAttemptSource>,
    }
}
///This domain allows interacting with the FedCM dialog.
pub mod fed_cm {
    ///Whether this is a sign-up or sign-in action for this account, i.e.
    ///whether this account has ever been used to sign in to this RP before.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum LoginState {
        #[serde(rename = "SignIn")]
        SignIn,
        #[serde(rename = "SignUp")]
        SignUp,
    }
    ///Whether the dialog shown is an account chooser or an auto re-authentication dialog.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DialogType {
        #[serde(rename = "AccountChooser")]
        AccountChooser,
        #[serde(rename = "AutoReauthn")]
        AutoReauthn,
    }
    ///Corresponds to IdentityRequestAccount
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Account {
        #[serde(rename = "accountId")]
        pub account_id: String,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "givenName")]
        pub given_name: String,
        #[serde(rename = "pictureUrl")]
        pub picture_url: String,
        #[serde(rename = "idpConfigUrl")]
        pub idp_config_url: String,
        #[serde(rename = "idpSigninUrl")]
        pub idp_signin_url: String,
        #[serde(rename = "loginState")]
        pub login_state: LoginState,
        ///These two are only set if the loginState is signUp
        #[serde(rename = "termsOfServiceUrl")]
        pub terms_of_service_url: Option<String>,
        #[serde(rename = "privacyPolicyUrl")]
        pub privacy_policy_url: Option<String>,
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        ///Allows callers to disable the promise rejection delay that would
        ///normally happen, if this is unimportant to what's being tested.
        ///(step 4 of https://fedidcg.github.io/FedCM/#browser-api-rp-sign-in)
        #[serde(rename = "disableRejectionDelay")]
        pub disable_rejection_delay: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [SelectAccount].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SelectAccountParams {
        #[serde(rename = "dialogId")]
        pub dialog_id: String,
        #[serde(rename = "accountIndex")]
        pub account_index: i64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SelectAccount;
    impl crate::util::Command for SelectAccount {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "selectAccount"
        }
    }
    ///
    /// Parameter value for [DismissDialog].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DismissDialogParams {
        #[serde(rename = "dialogId")]
        pub dialog_id: String,
        #[serde(rename = "triggerCooldown")]
        pub trigger_cooldown: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DismissDialog;
    impl crate::util::Command for DismissDialog {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "dismissDialog"
        }
    }
    ///Resets the cooldown time, if any, to allow the next FedCM call to show
    ///a dialog even if one was recently dismissed by the user.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResetCooldown;
    impl crate::util::Command for ResetCooldown {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resetCooldown"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DialogShownEvent {
        #[serde(rename = "dialogId")]
        pub dialog_id: String,
        #[serde(rename = "dialogType")]
        pub dialog_type: DialogType,
        #[serde(rename = "accounts")]
        pub accounts: Vec<Account>,
        ///These exist primarily so that the caller can verify the
        ///RP context was used appropriately.
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "subtitle")]
        pub subtitle: Option<String>,
    }
}
///This domain is deprecated - use Runtime or Log instead.
#[deprecated]
pub mod console {
    ///
    /// Enum for [ConsoleMessage]'s `source`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ConsoleMessageSource {
        #[serde(rename = "xml")]
        Xml,
        #[serde(rename = "javascript")]
        Javascript,
        #[serde(rename = "network")]
        Network,
        #[serde(rename = "console-api")]
        ConsoleApi,
        #[serde(rename = "storage")]
        Storage,
        #[serde(rename = "appcache")]
        Appcache,
        #[serde(rename = "rendering")]
        Rendering,
        #[serde(rename = "security")]
        Security,
        #[serde(rename = "other")]
        Other,
        #[serde(rename = "deprecation")]
        Deprecation,
        #[serde(rename = "worker")]
        Worker,
    }
    ///
    /// Enum for [ConsoleMessage]'s `level`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ConsoleMessageLevel {
        #[serde(rename = "log")]
        Log,
        #[serde(rename = "warning")]
        Warning,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "debug")]
        Debug,
        #[serde(rename = "info")]
        Info,
    }
    ///Console message.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ConsoleMessage {
        ///Message source.
        #[serde(rename = "source")]
        pub source: ConsoleMessageSource,
        ///Message severity.
        #[serde(rename = "level")]
        pub level: ConsoleMessageLevel,
        ///Message text.
        #[serde(rename = "text")]
        pub text: String,
        ///URL of the message origin.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///Line number in the resource that generated this message (1-based).
        #[serde(rename = "line")]
        pub line: Option<i64>,
        ///Column number in the resource that generated this message (1-based).
        #[serde(rename = "column")]
        pub column: Option<i64>,
    }
    ///Does nothing.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ClearMessages;
    impl crate::util::Command for ClearMessages {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "clearMessages"
        }
    }
    ///Disables console domain, prevents further console messages from being reported to the client.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Enables console domain, sends the messages collected so far to the client by means of the
    ///`messageAdded` notification.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///Issued when new console message is added.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MessageAddedEvent {
        ///Console message that has been added.
        #[serde(rename = "message")]
        pub message: ConsoleMessage,
    }
}
///Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
///breakpoints, stepping through execution, exploring stack traces, etc.
pub mod debugger {
    ///Breakpoint identifier.
    pub type BreakpointId = String;
    ///Call frame identifier.
    pub type CallFrameId = String;
    ///Location in the source code.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Location {
        ///Script identifier as reported in the `Debugger.scriptParsed`.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///Line number in the script (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        ///Column number in the script (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: Option<i64>,
    }
    ///Location in the source code.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScriptPosition {
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }
    ///Location range within one script.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LocationRange {
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        #[serde(rename = "start")]
        pub start: ScriptPosition,
        #[serde(rename = "end")]
        pub end: ScriptPosition,
    }
    ///JavaScript call frame. Array of call frames form the call stack.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CallFrame {
        ///Call frame identifier. This identifier is only valid while the virtual machine is paused.
        #[serde(rename = "callFrameId")]
        pub call_frame_id: CallFrameId,
        ///Name of the JavaScript function called on this call frame.
        #[serde(rename = "functionName")]
        pub function_name: String,
        ///Location in the source code.
        #[serde(rename = "functionLocation")]
        pub function_location: Option<Location>,
        ///Location in the source code.
        #[serde(rename = "location")]
        pub location: Location,
        ///JavaScript script name or url.
        ///Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
        ///sent `Debugger.scriptParsed` event.
        #[deprecated]
        #[serde(rename = "url")]
        pub url: String,
        ///Scope chain for this call frame.
        #[serde(rename = "scopeChain")]
        pub scope_chain: Vec<Scope>,
        ///`this` object for this call frame.
        #[serde(rename = "this")]
        pub this: crate::protocol_test::runtime::RemoteObject,
        ///The value being returned, if the function is at return point.
        #[serde(rename = "returnValue")]
        pub return_value: Option<crate::protocol_test::runtime::RemoteObject>,
        ///Valid only while the VM is paused and indicates whether this frame
        ///can be restarted or not. Note that a `true` value here does not
        ///guarantee that Debugger#restartFrame with this CallFrameId will be
        ///successful, but it is very likely.
        #[serde(rename = "canBeRestarted")]
        pub can_be_restarted: Option<bool>,
    }
    ///
    /// Enum for [Scope]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ScopeType {
        #[serde(rename = "global")]
        Global,
        #[serde(rename = "local")]
        Local,
        #[serde(rename = "with")]
        With,
        #[serde(rename = "closure")]
        Closure,
        #[serde(rename = "catch")]
        Catch,
        #[serde(rename = "block")]
        Block,
        #[serde(rename = "script")]
        Script,
        #[serde(rename = "eval")]
        Eval,
        #[serde(rename = "module")]
        Module,
        #[serde(rename = "wasm-expression-stack")]
        WasmExpressionStack,
    }
    ///Scope description.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Scope {
        ///Scope type.
        #[serde(rename = "type")]
        pub type_: ScopeType,
        ///Object representing the scope. For `global` and `with` scopes it represents the actual
        ///object; for the rest of the scopes, it is artificial transient object enumerating scope
        ///variables as its properties.
        #[serde(rename = "object")]
        pub object: crate::protocol_test::runtime::RemoteObject,
        #[serde(rename = "name")]
        pub name: Option<String>,
        ///Location in the source code where scope starts
        #[serde(rename = "startLocation")]
        pub start_location: Option<Location>,
        ///Location in the source code where scope ends
        #[serde(rename = "endLocation")]
        pub end_location: Option<Location>,
    }
    ///Search match for resource.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchMatch {
        ///Line number in resource content.
        #[serde(rename = "lineNumber")]
        pub line_number: f64,
        ///Line with match content.
        #[serde(rename = "lineContent")]
        pub line_content: String,
    }
    ///
    /// Enum for [BreakLocation]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum BreakLocationType {
        #[serde(rename = "debuggerStatement")]
        DebuggerStatement,
        #[serde(rename = "call")]
        Call,
        #[serde(rename = "return")]
        Return,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BreakLocation {
        ///Script identifier as reported in the `Debugger.scriptParsed`.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///Line number in the script (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        ///Column number in the script (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: Option<i64>,
        #[serde(rename = "type")]
        pub type_: Option<Option<BreakLocationType>>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WasmDisassemblyChunk {
        ///The next chunk of disassembled lines.
        #[serde(rename = "lines")]
        pub lines: Vec<String>,
        ///The bytecode offsets describing the start of each line.
        #[serde(rename = "bytecodeOffsets")]
        pub bytecode_offsets: Vec<i64>,
    }
    ///Enum of possible script languages.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ScriptLanguage {
        #[serde(rename = "JavaScript")]
        JavaScript,
        #[serde(rename = "WebAssembly")]
        WebAssembly,
    }
    ///
    /// Enum for [DebugSymbols]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DebugSymbolsType {
        #[serde(rename = "None")]
        None,
        #[serde(rename = "SourceMap")]
        SourceMap,
        #[serde(rename = "EmbeddedDWARF")]
        EmbeddedDwarf,
        #[serde(rename = "ExternalDWARF")]
        ExternalDwarf,
    }
    ///Debug symbols available for a wasm script.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DebugSymbols {
        ///Type of the debug symbols.
        #[serde(rename = "type")]
        pub type_: DebugSymbolsType,
        ///URL of the external symbol source.
        #[serde(rename = "externalURL")]
        pub external_url: Option<String>,
    }
    ///
    /// Enum for [ContinueToLocation]'s `target_call_frames`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ContinueToLocationTargetCallFrames {
        #[serde(rename = "any")]
        Any,
        #[serde(rename = "current")]
        Current,
    }
    ///
    /// Parameter value for [ContinueToLocation].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueToLocationParams {
        ///Location to continue to.
        #[serde(rename = "location")]
        pub location: Location,
        #[serde(rename = "targetCallFrames")]
        pub target_call_frames: Option<Option<ContinueToLocationTargetCallFrames>>,
    }
    ///Continues execution until specific location is reached.
    ///---
    ///Parameter Type: [ContinueToLocationParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ContinueToLocation;
    impl crate::util::Command for ContinueToLocation {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "continueToLocation"
        }
    }
    ///Disables debugger for given page.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///
    /// Parameter value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableParams {
        ///The maximum size in bytes of collected scripts (not referenced by other heap objects)
        ///the debugger can hold. Puts no limit if parameter is omitted.
        #[serde(rename = "maxScriptsCacheSize")]
        pub max_scripts_cache_size: Option<f64>,
    }
    ///
    /// Return value for [Enable].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnableReturns {
        ///Unique identifier of the debugger.
        #[serde(rename = "debuggerId")]
        pub debugger_id: crate::protocol_test::runtime::UniqueDebuggerId,
    }
    ///Enables debugger for the given page. Clients should not assume that the debugging has been
    ///enabled until the result for this command is received.
    ///---
    ///Parameter Type: [EnableParams]
    ///Return Type: [EnableReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [EvaluateOnCallFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EvaluateOnCallFrameParams {
        ///Call frame identifier to evaluate on.
        #[serde(rename = "callFrameId")]
        pub call_frame_id: CallFrameId,
        ///Expression to evaluate.
        #[serde(rename = "expression")]
        pub expression: String,
        ///String object group name to put result into (allows rapid releasing resulting object handles
        ///using `releaseObjectGroup`).
        #[serde(rename = "objectGroup")]
        pub object_group: Option<String>,
        ///Specifies whether command line API should be available to the evaluated expression, defaults
        ///to false.
        #[serde(rename = "includeCommandLineAPI")]
        pub include_command_line_api: Option<bool>,
        ///In silent mode exceptions thrown during evaluation are not reported and do not pause
        ///execution. Overrides `setPauseOnException` state.
        #[serde(rename = "silent")]
        pub silent: Option<bool>,
        ///Whether the result is expected to be a JSON object that should be sent by value.
        #[serde(rename = "returnByValue")]
        pub return_by_value: Option<bool>,
        ///Whether preview should be generated for the result.
        #[serde(rename = "generatePreview")]
        pub generate_preview: Option<bool>,
        ///Whether to throw an exception if side effect cannot be ruled out during evaluation.
        #[serde(rename = "throwOnSideEffect")]
        pub throw_on_side_effect: Option<bool>,
        ///Terminate execution after timing out (number of milliseconds).
        #[serde(rename = "timeout")]
        pub timeout: Option<crate::protocol_test::runtime::TimeDelta>,
    }
    ///
    /// Return value for [EvaluateOnCallFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EvaluateOnCallFrameReturns {
        ///Object wrapper for the evaluation result.
        #[serde(rename = "result")]
        pub result: crate::protocol_test::runtime::RemoteObject,
        ///Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<crate::protocol_test::runtime::ExceptionDetails>,
    }
    ///Evaluates expression on a given call frame.
    ///---
    ///Parameter Type: [EvaluateOnCallFrameParams]
    ///Return Type: [EvaluateOnCallFrameReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EvaluateOnCallFrame;
    impl crate::util::Command for EvaluateOnCallFrame {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "evaluateOnCallFrame"
        }
    }
    ///
    /// Parameter value for [GetPossibleBreakpoints].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPossibleBreakpointsParams {
        ///Start of range to search possible breakpoint locations in.
        #[serde(rename = "start")]
        pub start: Location,
        ///End of range to search possible breakpoint locations in (excluding). When not specified, end
        ///of scripts is used as end of range.
        #[serde(rename = "end")]
        pub end: Option<Location>,
        ///Only consider locations which are in the same (non-nested) function as start.
        #[serde(rename = "restrictToFunction")]
        pub restrict_to_function: Option<bool>,
    }
    ///
    /// Return value for [GetPossibleBreakpoints].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPossibleBreakpointsReturns {
        ///List of the possible breakpoint locations.
        #[serde(rename = "locations")]
        pub locations: Vec<BreakLocation>,
    }
    ///Returns possible locations for breakpoint. scriptId in start and end range locations should be
    ///the same.
    ///---
    ///Parameter Type: [GetPossibleBreakpointsParams]
    ///Return Type: [GetPossibleBreakpointsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPossibleBreakpoints;
    impl crate::util::Command for GetPossibleBreakpoints {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getPossibleBreakpoints"
        }
    }
    ///
    /// Parameter value for [GetScriptSource].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetScriptSourceParams {
        ///Id of the script to get source for.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
    }
    ///
    /// Return value for [GetScriptSource].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetScriptSourceReturns {
        ///Script source (empty in case of Wasm bytecode).
        #[serde(rename = "scriptSource")]
        pub script_source: String,
        ///Wasm bytecode. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "bytecode")]
        pub bytecode: Option<String>,
    }
    ///Returns source for the script with given id.
    ///---
    ///Parameter Type: [GetScriptSourceParams]
    ///Return Type: [GetScriptSourceReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetScriptSource;
    impl crate::util::Command for GetScriptSource {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getScriptSource"
        }
    }
    ///
    /// Parameter value for [DisassembleWasmModule].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DisassembleWasmModuleParams {
        ///Id of the script to disassemble
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
    }
    ///
    /// Return value for [DisassembleWasmModule].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DisassembleWasmModuleReturns {
        ///For large modules, return a stream from which additional chunks of
        ///disassembly can be read successively.
        #[serde(rename = "streamId")]
        pub stream_id: Option<String>,
        ///The total number of lines in the disassembly text.
        #[serde(rename = "totalNumberOfLines")]
        pub total_number_of_lines: i64,
        ///The offsets of all function bodies, in the format [start1, end1,
        ///start2, end2, ...] where all ends are exclusive.
        #[serde(rename = "functionBodyOffsets")]
        pub function_body_offsets: Vec<i64>,
        ///The first chunk of disassembly.
        #[serde(rename = "chunk")]
        pub chunk: WasmDisassemblyChunk,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DisassembleWasmModule;
    impl crate::util::Command for DisassembleWasmModule {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disassembleWasmModule"
        }
    }
    ///
    /// Parameter value for [NextWasmDisassemblyChunk].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NextWasmDisassemblyChunkParams {
        #[serde(rename = "streamId")]
        pub stream_id: String,
    }
    ///
    /// Return value for [NextWasmDisassemblyChunk].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NextWasmDisassemblyChunkReturns {
        ///The next chunk of disassembly.
        #[serde(rename = "chunk")]
        pub chunk: WasmDisassemblyChunk,
    }
    ///Disassemble the next chunk of lines for the module corresponding to the
    ///stream. If disassembly is complete, this API will invalidate the streamId
    ///and return an empty chunk. Any subsequent calls for the now invalid stream
    ///will return errors.
    ///---
    ///Parameter Type: [NextWasmDisassemblyChunkParams]
    ///Return Type: [NextWasmDisassemblyChunkReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct NextWasmDisassemblyChunk;
    impl crate::util::Command for NextWasmDisassemblyChunk {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "nextWasmDisassemblyChunk"
        }
    }
    ///
    /// Parameter value for [GetWasmBytecode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWasmBytecodeParams {
        ///Id of the Wasm script to get source for.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
    }
    ///
    /// Return value for [GetWasmBytecode].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWasmBytecodeReturns {
        ///Script source. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "bytecode")]
        pub bytecode: String,
    }
    ///This command is deprecated. Use getScriptSource instead.
    ///---
    ///Parameter Type: [GetWasmBytecodeParams]
    ///Return Type: [GetWasmBytecodeReturns]
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetWasmBytecode;
    impl crate::util::Command for GetWasmBytecode {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getWasmBytecode"
        }
    }
    ///
    /// Parameter value for [GetStackTrace].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStackTraceParams {
        #[serde(rename = "stackTraceId")]
        pub stack_trace_id: crate::protocol_test::runtime::StackTraceId,
    }
    ///
    /// Return value for [GetStackTrace].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStackTraceReturns {
        #[serde(rename = "stackTrace")]
        pub stack_trace: crate::protocol_test::runtime::StackTrace,
    }
    ///Returns stack trace with given `stackTraceId`.
    ///---
    ///Parameter Type: [GetStackTraceParams]
    ///Return Type: [GetStackTraceReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetStackTrace;
    impl crate::util::Command for GetStackTrace {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getStackTrace"
        }
    }
    ///Stops on the next JavaScript statement.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Pause;
    impl crate::util::Command for Pause {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "pause"
        }
    }
    ///
    /// Parameter value for [PauseOnAsyncCall].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PauseOnAsyncCallParams {
        ///Debugger will pause when async call with given stack trace is started.
        #[serde(rename = "parentStackTraceId")]
        pub parent_stack_trace_id: crate::protocol_test::runtime::StackTraceId,
    }
    #[deprecated]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PauseOnAsyncCall;
    impl crate::util::Command for PauseOnAsyncCall {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "pauseOnAsyncCall"
        }
    }
    ///
    /// Parameter value for [RemoveBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveBreakpointParams {
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
    }
    ///Removes JavaScript breakpoint.
    ///---
    ///Parameter Type: [RemoveBreakpointParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveBreakpoint;
    impl crate::util::Command for RemoveBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeBreakpoint"
        }
    }
    ///
    /// Enum for [RestartFrame]'s `mode`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum RestartFrameMode {
        #[serde(rename = "StepInto")]
        StepInto,
    }
    ///
    /// Parameter value for [RestartFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RestartFrameParams {
        ///Call frame identifier to evaluate on.
        #[serde(rename = "callFrameId")]
        pub call_frame_id: CallFrameId,
        ///The `mode` parameter must be present and set to 'StepInto', otherwise
        ///`restartFrame` will error out.
        #[serde(rename = "mode")]
        pub mode: Option<Option<RestartFrameMode>>,
    }
    ///
    /// Return value for [RestartFrame].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RestartFrameReturns {
        ///New stack trace.
        #[deprecated]
        #[serde(rename = "callFrames")]
        pub call_frames: Vec<CallFrame>,
        ///Async stack trace, if any.
        #[deprecated]
        #[serde(rename = "asyncStackTrace")]
        pub async_stack_trace: Option<crate::protocol_test::runtime::StackTrace>,
        ///Async stack trace, if any.
        #[deprecated]
        #[serde(rename = "asyncStackTraceId")]
        pub async_stack_trace_id: Option<crate::protocol_test::runtime::StackTraceId>,
    }
    ///Restarts particular call frame from the beginning. The old, deprecated
    ///behavior of `restartFrame` is to stay paused and allow further CDP commands
    ///after a restart was scheduled. This can cause problems with restarting, so
    ///we now continue execution immediatly after it has been scheduled until we
    ///reach the beginning of the restarted frame.
    ///
    ///To stay back-wards compatible, `restartFrame` now expects a `mode`
    ///parameter to be present. If the `mode` parameter is missing, `restartFrame`
    ///errors out.
    ///
    ///The various return values are deprecated and `callFrames` is always empty.
    ///Use the call frames from the `Debugger#paused` events instead, that fires
    ///once V8 pauses at the beginning of the restarted function.
    ///---
    ///Parameter Type: [RestartFrameParams]
    ///Return Type: [RestartFrameReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RestartFrame;
    impl crate::util::Command for RestartFrame {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "restartFrame"
        }
    }
    ///
    /// Parameter value for [Resume].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResumeParams {
        ///Set to true to terminate execution upon resuming execution. In contrast
        ///to Runtime.terminateExecution, this will allows to execute further
        ///JavaScript (i.e. via evaluation) until execution of the paused code
        ///is actually resumed, at which point termination is triggered.
        ///If execution is currently not paused, this parameter has no effect.
        #[serde(rename = "terminateOnResume")]
        pub terminate_on_resume: Option<bool>,
    }
    ///Resumes JavaScript execution.
    ///---
    ///Parameter Type: [ResumeParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Resume;
    impl crate::util::Command for Resume {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "resume"
        }
    }
    ///
    /// Parameter value for [SearchInContent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInContentParams {
        ///Id of the script to search in.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///String to search for.
        #[serde(rename = "query")]
        pub query: String,
        ///If true, search is case sensitive.
        #[serde(rename = "caseSensitive")]
        pub case_sensitive: Option<bool>,
        ///If true, treats string parameter as regex.
        #[serde(rename = "isRegex")]
        pub is_regex: Option<bool>,
    }
    ///
    /// Return value for [SearchInContent].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInContentReturns {
        ///List of search matches.
        #[serde(rename = "result")]
        pub result: Vec<SearchMatch>,
    }
    ///Searches for given string in script content.
    ///---
    ///Parameter Type: [SearchInContentParams]
    ///Return Type: [SearchInContentReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SearchInContent;
    impl crate::util::Command for SearchInContent {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "searchInContent"
        }
    }
    ///
    /// Parameter value for [SetAsyncCallStackDepth].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAsyncCallStackDepthParams {
        ///Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
        ///call stacks (default).
        #[serde(rename = "maxDepth")]
        pub max_depth: i64,
    }
    ///Enables or disables async call stacks tracking.
    ///---
    ///Parameter Type: [SetAsyncCallStackDepthParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAsyncCallStackDepth;
    impl crate::util::Command for SetAsyncCallStackDepth {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAsyncCallStackDepth"
        }
    }
    ///
    /// Parameter value for [SetBlackboxPatterns].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBlackboxPatternsParams {
        ///Array of regexps that will be used to check script url for blackbox state.
        #[serde(rename = "patterns")]
        pub patterns: Vec<String>,
    }
    ///Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    ///scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    ///performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    ///---
    ///Parameter Type: [SetBlackboxPatternsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBlackboxPatterns;
    impl crate::util::Command for SetBlackboxPatterns {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBlackboxPatterns"
        }
    }
    ///
    /// Parameter value for [SetBlackboxedRanges].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBlackboxedRangesParams {
        ///Id of the script.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        #[serde(rename = "positions")]
        pub positions: Vec<ScriptPosition>,
    }
    ///Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    ///scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    ///Positions array contains positions where blackbox state is changed. First interval isn't
    ///blackboxed. Array should be sorted.
    ///---
    ///Parameter Type: [SetBlackboxedRangesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBlackboxedRanges;
    impl crate::util::Command for SetBlackboxedRanges {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBlackboxedRanges"
        }
    }
    ///
    /// Parameter value for [SetBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointParams {
        ///Location to set breakpoint in.
        #[serde(rename = "location")]
        pub location: Location,
        ///Expression to use as a breakpoint condition. When specified, debugger will only stop on the
        ///breakpoint if this expression evaluates to true.
        #[serde(rename = "condition")]
        pub condition: Option<String>,
    }
    ///
    /// Return value for [SetBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointReturns {
        ///Id of the created breakpoint for further reference.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
        ///Location this breakpoint resolved into.
        #[serde(rename = "actualLocation")]
        pub actual_location: Location,
    }
    ///Sets JavaScript breakpoint at a given location.
    ///---
    ///Parameter Type: [SetBreakpointParams]
    ///Return Type: [SetBreakpointReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpoint;
    impl crate::util::Command for SetBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBreakpoint"
        }
    }
    ///
    /// Enum for [SetInstrumentationBreakpoint]'s `instrumentation`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetInstrumentationBreakpointInstrumentation {
        #[serde(rename = "beforeScriptExecution")]
        BeforeScriptExecution,
        #[serde(rename = "beforeScriptWithSourceMapExecution")]
        BeforeScriptWithSourceMapExecution,
    }
    ///
    /// Parameter value for [SetInstrumentationBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInstrumentationBreakpointParams {
        ///Instrumentation name.
        #[serde(rename = "instrumentation")]
        pub instrumentation: SetInstrumentationBreakpointInstrumentation,
    }
    ///
    /// Return value for [SetInstrumentationBreakpoint].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInstrumentationBreakpointReturns {
        ///Id of the created breakpoint for further reference.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
    }
    ///Sets instrumentation breakpoint.
    ///---
    ///Parameter Type: [SetInstrumentationBreakpointParams]
    ///Return Type: [SetInstrumentationBreakpointReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetInstrumentationBreakpoint;
    impl crate::util::Command for SetInstrumentationBreakpoint {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setInstrumentationBreakpoint"
        }
    }
    ///
    /// Parameter value for [SetBreakpointByUrl].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointByUrlParams {
        ///Line number to set breakpoint at.
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        ///URL of the resources to set breakpoint on.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
        ///`urlRegex` must be specified.
        #[serde(rename = "urlRegex")]
        pub url_regex: Option<String>,
        ///Script hash of the resources to set breakpoint on.
        #[serde(rename = "scriptHash")]
        pub script_hash: Option<String>,
        ///Offset in the line to set breakpoint at.
        #[serde(rename = "columnNumber")]
        pub column_number: Option<i64>,
        ///Expression to use as a breakpoint condition. When specified, debugger will only stop on the
        ///breakpoint if this expression evaluates to true.
        #[serde(rename = "condition")]
        pub condition: Option<String>,
    }
    ///
    /// Return value for [SetBreakpointByUrl].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointByUrlReturns {
        ///Id of the created breakpoint for further reference.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
        ///List of the locations this breakpoint resolved into upon addition.
        #[serde(rename = "locations")]
        pub locations: Vec<Location>,
    }
    ///Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    ///command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ///`locations` property. Further matching script parsing will result in subsequent
    ///`breakpointResolved` events issued. This logical breakpoint will survive page reloads.
    ///---
    ///Parameter Type: [SetBreakpointByUrlParams]
    ///Return Type: [SetBreakpointByUrlReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointByUrl;
    impl crate::util::Command for SetBreakpointByUrl {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBreakpointByUrl"
        }
    }
    ///
    /// Parameter value for [SetBreakpointOnFunctionCall].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointOnFunctionCallParams {
        ///Function object id.
        #[serde(rename = "objectId")]
        pub object_id: crate::protocol_test::runtime::RemoteObjectId,
        ///Expression to use as a breakpoint condition. When specified, debugger will
        ///stop on the breakpoint if this expression evaluates to true.
        #[serde(rename = "condition")]
        pub condition: Option<String>,
    }
    ///
    /// Return value for [SetBreakpointOnFunctionCall].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointOnFunctionCallReturns {
        ///Id of the created breakpoint for further reference.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
    }
    ///Sets JavaScript breakpoint before each call to the given function.
    ///If another function was created from the same source as a given one,
    ///calling it will also trigger the breakpoint.
    ///---
    ///Parameter Type: [SetBreakpointOnFunctionCallParams]
    ///Return Type: [SetBreakpointOnFunctionCallReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointOnFunctionCall;
    impl crate::util::Command for SetBreakpointOnFunctionCall {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBreakpointOnFunctionCall"
        }
    }
    ///
    /// Parameter value for [SetBreakpointsActive].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointsActiveParams {
        ///New value for breakpoints active state.
        #[serde(rename = "active")]
        pub active: bool,
    }
    ///Activates / deactivates all breakpoints on the page.
    ///---
    ///Parameter Type: [SetBreakpointsActiveParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetBreakpointsActive;
    impl crate::util::Command for SetBreakpointsActive {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setBreakpointsActive"
        }
    }
    ///
    /// Enum for [SetPauseOnExceptions]'s `state`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetPauseOnExceptionsState {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "caught")]
        Caught,
        #[serde(rename = "uncaught")]
        Uncaught,
        #[serde(rename = "all")]
        All,
    }
    ///
    /// Parameter value for [SetPauseOnExceptions].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPauseOnExceptionsParams {
        ///Pause on exceptions mode.
        #[serde(rename = "state")]
        pub state: SetPauseOnExceptionsState,
    }
    ///Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    ///or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
    ///---
    ///Parameter Type: [SetPauseOnExceptionsParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetPauseOnExceptions;
    impl crate::util::Command for SetPauseOnExceptions {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setPauseOnExceptions"
        }
    }
    ///
    /// Parameter value for [SetReturnValue].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetReturnValueParams {
        ///New return value.
        #[serde(rename = "newValue")]
        pub new_value: crate::protocol_test::runtime::CallArgument,
    }
    ///Changes return value in top frame. Available only at return break position.
    ///---
    ///Parameter Type: [SetReturnValueParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetReturnValue;
    impl crate::util::Command for SetReturnValue {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setReturnValue"
        }
    }
    ///
    /// Parameter value for [SetScriptSource].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScriptSourceParams {
        ///Id of the script to edit.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///New content of the script.
        #[serde(rename = "scriptSource")]
        pub script_source: String,
        ///If true the change will not actually be applied. Dry run may be used to get result
        ///description without actually modifying the code.
        #[serde(rename = "dryRun")]
        pub dry_run: Option<bool>,
        ///If true, then `scriptSource` is allowed to change the function on top of the stack
        ///as long as the top-most stack frame is the only activation of that function.
        #[serde(rename = "allowTopFrameEditing")]
        pub allow_top_frame_editing: Option<bool>,
    }
    ///
    /// Enum for [SetScriptSource]'s `status`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SetScriptSourceStatus {
        #[serde(rename = "Ok")]
        Ok,
        #[serde(rename = "CompileError")]
        CompileError,
        #[serde(rename = "BlockedByActiveGenerator")]
        BlockedByActiveGenerator,
        #[serde(rename = "BlockedByActiveFunction")]
        BlockedByActiveFunction,
        #[serde(rename = "BlockedByTopLevelEsModuleChange")]
        BlockedByTopLevelEsModuleChange,
    }
    ///
    /// Return value for [SetScriptSource].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScriptSourceReturns {
        ///New stack trace in case editing has happened while VM was stopped.
        #[deprecated]
        #[serde(rename = "callFrames")]
        pub call_frames: Option<Vec<CallFrame>>,
        ///Whether current call stack  was modified after applying the changes.
        #[deprecated]
        #[serde(rename = "stackChanged")]
        pub stack_changed: Option<bool>,
        ///Async stack trace, if any.
        #[deprecated]
        #[serde(rename = "asyncStackTrace")]
        pub async_stack_trace: Option<crate::protocol_test::runtime::StackTrace>,
        ///Async stack trace, if any.
        #[deprecated]
        #[serde(rename = "asyncStackTraceId")]
        pub async_stack_trace_id: Option<crate::protocol_test::runtime::StackTraceId>,
        ///Whether the operation was successful or not. Only `Ok` denotes a
        ///successful live edit while the other enum variants denote why
        ///the live edit failed.
        #[serde(rename = "status")]
        pub status: SetScriptSourceStatus,
        ///Exception details if any. Only present when `status` is `CompileError`.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<crate::protocol_test::runtime::ExceptionDetails>,
    }
    ///Edits JavaScript source live.
    ///
    ///In general, functions that are currently on the stack can not be edited with
    ///a single exception: If the edited function is the top-most stack frame and
    ///that is the only activation of that function on the stack. In this case
    ///the live edit will be successful and a `Debugger.restartFrame` for the
    ///top-most function is automatically triggered.
    ///---
    ///Parameter Type: [SetScriptSourceParams]
    ///Return Type: [SetScriptSourceReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetScriptSource;
    impl crate::util::Command for SetScriptSource {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setScriptSource"
        }
    }
    ///
    /// Parameter value for [SetSkipAllPauses].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSkipAllPausesParams {
        ///New value for skip pauses state.
        #[serde(rename = "skip")]
        pub skip: bool,
    }
    ///Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
    ///---
    ///Parameter Type: [SetSkipAllPausesParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSkipAllPauses;
    impl crate::util::Command for SetSkipAllPauses {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setSkipAllPauses"
        }
    }
    ///
    /// Parameter value for [SetVariableValue].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetVariableValueParams {
        ///0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
        ///scope types are allowed. Other scopes could be manipulated manually.
        #[serde(rename = "scopeNumber")]
        pub scope_number: i64,
        ///Variable name.
        #[serde(rename = "variableName")]
        pub variable_name: String,
        ///New variable value.
        #[serde(rename = "newValue")]
        pub new_value: crate::protocol_test::runtime::CallArgument,
        ///Id of callframe that holds variable.
        #[serde(rename = "callFrameId")]
        pub call_frame_id: CallFrameId,
    }
    ///Changes value of variable in a callframe. Object-based scopes are not supported and must be
    ///mutated manually.
    ///---
    ///Parameter Type: [SetVariableValueParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetVariableValue;
    impl crate::util::Command for SetVariableValue {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setVariableValue"
        }
    }
    ///
    /// Parameter value for [StepInto].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StepIntoParams {
        ///Debugger will pause on the execution of the first async task which was scheduled
        ///before next pause.
        #[serde(rename = "breakOnAsyncCall")]
        pub break_on_async_call: Option<bool>,
        ///The skipList specifies location ranges that should be skipped on step into.
        #[serde(rename = "skipList")]
        pub skip_list: Option<Vec<LocationRange>>,
    }
    ///Steps into the function call.
    ///---
    ///Parameter Type: [StepIntoParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StepInto;
    impl crate::util::Command for StepInto {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stepInto"
        }
    }
    ///Steps out of the function call.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StepOut;
    impl crate::util::Command for StepOut {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stepOut"
        }
    }
    ///
    /// Parameter value for [StepOver].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StepOverParams {
        ///The skipList specifies location ranges that should be skipped on step over.
        #[serde(rename = "skipList")]
        pub skip_list: Option<Vec<LocationRange>>,
    }
    ///Steps over the statement.
    ///---
    ///Parameter Type: [StepOverParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StepOver;
    impl crate::util::Command for StepOver {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stepOver"
        }
    }
    ///Fired when breakpoint is resolved to an actual script and location.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BreakpointResolvedEvent {
        ///Breakpoint unique identifier.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
        ///Actual breakpoint location.
        #[serde(rename = "location")]
        pub location: Location,
    }
    ///
    /// Enum for [PausedEvent]'s `reason`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PausedEventReason {
        #[serde(rename = "ambiguous")]
        Ambiguous,
        #[serde(rename = "assert")]
        Assert,
        #[serde(rename = "CSPViolation")]
        CspViolation,
        #[serde(rename = "debugCommand")]
        DebugCommand,
        #[serde(rename = "DOM")]
        Dom,
        #[serde(rename = "EventListener")]
        EventListener,
        #[serde(rename = "exception")]
        Exception,
        #[serde(rename = "instrumentation")]
        Instrumentation,
        #[serde(rename = "OOM")]
        Oom,
        #[serde(rename = "other")]
        Other,
        #[serde(rename = "promiseRejection")]
        PromiseRejection,
        #[serde(rename = "XHR")]
        Xhr,
        #[serde(rename = "step")]
        Step,
    }
    ///Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PausedEvent {
        ///Call stack the virtual machine stopped on.
        #[serde(rename = "callFrames")]
        pub call_frames: Vec<CallFrame>,
        ///Pause reason.
        #[serde(rename = "reason")]
        pub reason: PausedEventReason,
        ///Object containing break-specific auxiliary properties.
        #[serde(rename = "data")]
        pub data: Option<serde_json::Map<String, serde_json::Value>>,
        ///Hit breakpoints IDs
        #[serde(rename = "hitBreakpoints")]
        pub hit_breakpoints: Option<Vec<String>>,
        ///Async stack trace, if any.
        #[serde(rename = "asyncStackTrace")]
        pub async_stack_trace: Option<crate::protocol_test::runtime::StackTrace>,
        ///Async stack trace, if any.
        #[serde(rename = "asyncStackTraceId")]
        pub async_stack_trace_id: Option<crate::protocol_test::runtime::StackTraceId>,
        ///Never present, will be removed.
        #[deprecated]
        #[serde(rename = "asyncCallStackTraceId")]
        pub async_call_stack_trace_id: Option<
            crate::protocol_test::runtime::StackTraceId,
        >,
    }
    ///Fired when the virtual machine resumed execution.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResumedEvent {}
    ///Fired when virtual machine fails to parse the script.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScriptFailedToParseEvent {
        ///Identifier of the script parsed.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///URL or name of the script parsed (if any).
        #[serde(rename = "url")]
        pub url: String,
        ///Line offset of the script within the resource with given URL (for script tags).
        #[serde(rename = "startLine")]
        pub start_line: i64,
        ///Column offset of the script within the resource with given URL.
        #[serde(rename = "startColumn")]
        pub start_column: i64,
        ///Last line of the script.
        #[serde(rename = "endLine")]
        pub end_line: i64,
        ///Length of the last line of the script.
        #[serde(rename = "endColumn")]
        pub end_column: i64,
        ///Specifies script creation context.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: crate::protocol_test::runtime::ExecutionContextId,
        ///Content hash of the script, SHA-256.
        #[serde(rename = "hash")]
        pub hash: String,
        ///Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
        #[serde(rename = "executionContextAuxData")]
        pub execution_context_aux_data: Option<
            serde_json::Map<String, serde_json::Value>,
        >,
        ///URL of source map associated with script (if any).
        #[serde(rename = "sourceMapURL")]
        pub source_map_url: Option<String>,
        ///True, if this script has sourceURL.
        #[serde(rename = "hasSourceURL")]
        pub has_source_url: Option<bool>,
        ///True, if this script is ES6 module.
        #[serde(rename = "isModule")]
        pub is_module: Option<bool>,
        ///This script length.
        #[serde(rename = "length")]
        pub length: Option<i64>,
        ///JavaScript top stack frame of where the script parsed event was triggered if available.
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<crate::protocol_test::runtime::StackTrace>,
        ///If the scriptLanguage is WebAssembly, the code section offset in the module.
        #[serde(rename = "codeOffset")]
        pub code_offset: Option<i64>,
        ///The language of the script.
        #[serde(rename = "scriptLanguage")]
        pub script_language: Option<crate::protocol_test::debugger::ScriptLanguage>,
        ///The name the embedder supplied for this script.
        #[serde(rename = "embedderName")]
        pub embedder_name: Option<String>,
    }
    ///Fired when virtual machine parses script. This event is also fired for all known and uncollected
    ///scripts upon enabling debugger.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScriptParsedEvent {
        ///Identifier of the script parsed.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///URL or name of the script parsed (if any).
        #[serde(rename = "url")]
        pub url: String,
        ///Line offset of the script within the resource with given URL (for script tags).
        #[serde(rename = "startLine")]
        pub start_line: i64,
        ///Column offset of the script within the resource with given URL.
        #[serde(rename = "startColumn")]
        pub start_column: i64,
        ///Last line of the script.
        #[serde(rename = "endLine")]
        pub end_line: i64,
        ///Length of the last line of the script.
        #[serde(rename = "endColumn")]
        pub end_column: i64,
        ///Specifies script creation context.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: crate::protocol_test::runtime::ExecutionContextId,
        ///Content hash of the script, SHA-256.
        #[serde(rename = "hash")]
        pub hash: String,
        ///Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
        #[serde(rename = "executionContextAuxData")]
        pub execution_context_aux_data: Option<
            serde_json::Map<String, serde_json::Value>,
        >,
        ///True, if this script is generated as a result of the live edit operation.
        #[serde(rename = "isLiveEdit")]
        pub is_live_edit: Option<bool>,
        ///URL of source map associated with script (if any).
        #[serde(rename = "sourceMapURL")]
        pub source_map_url: Option<String>,
        ///True, if this script has sourceURL.
        #[serde(rename = "hasSourceURL")]
        pub has_source_url: Option<bool>,
        ///True, if this script is ES6 module.
        #[serde(rename = "isModule")]
        pub is_module: Option<bool>,
        ///This script length.
        #[serde(rename = "length")]
        pub length: Option<i64>,
        ///JavaScript top stack frame of where the script parsed event was triggered if available.
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<crate::protocol_test::runtime::StackTrace>,
        ///If the scriptLanguage is WebAssembly, the code section offset in the module.
        #[serde(rename = "codeOffset")]
        pub code_offset: Option<i64>,
        ///The language of the script.
        #[serde(rename = "scriptLanguage")]
        pub script_language: Option<crate::protocol_test::debugger::ScriptLanguage>,
        ///If the scriptLanguage is WebASsembly, the source of debug symbols for the module.
        #[serde(rename = "debugSymbols")]
        pub debug_symbols: Option<crate::protocol_test::debugger::DebugSymbols>,
        ///The name the embedder supplied for this script.
        #[serde(rename = "embedderName")]
        pub embedder_name: Option<String>,
    }
}
pub mod heap_profiler {
    ///Heap snapshot object id.
    pub type HeapSnapshotObjectId = String;
    ///Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SamplingHeapProfileNode {
        ///Function location.
        #[serde(rename = "callFrame")]
        pub call_frame: crate::protocol_test::runtime::CallFrame,
        ///Allocations size in bytes for the node excluding children.
        #[serde(rename = "selfSize")]
        pub self_size: f64,
        ///Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
        #[serde(rename = "id")]
        pub id: i64,
        ///Child nodes.
        #[serde(rename = "children")]
        pub children: Vec<SamplingHeapProfileNode>,
    }
    ///A single sample from a sampling profile.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SamplingHeapProfileSample {
        ///Allocation size in bytes attributed to the sample.
        #[serde(rename = "size")]
        pub size: f64,
        ///Id of the corresponding profile tree node.
        #[serde(rename = "nodeId")]
        pub node_id: i64,
        ///Time-ordered sample ordinal number. It is unique across all profiles retrieved
        ///between startSampling and stopSampling.
        #[serde(rename = "ordinal")]
        pub ordinal: f64,
    }
    ///Sampling profile.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SamplingHeapProfile {
        #[serde(rename = "head")]
        pub head: SamplingHeapProfileNode,
        #[serde(rename = "samples")]
        pub samples: Vec<SamplingHeapProfileSample>,
    }
    ///
    /// Parameter value for [AddInspectedHeapObject].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddInspectedHeapObjectParams {
        ///Heap snapshot object id to be accessible by means of $x command line API.
        #[serde(rename = "heapObjectId")]
        pub heap_object_id: HeapSnapshotObjectId,
    }
    ///Enables console to refer to the node with given id via $x (see Command Line API for more details
    ///$x functions).
    ///---
    ///Parameter Type: [AddInspectedHeapObjectParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddInspectedHeapObject;
    impl crate::util::Command for AddInspectedHeapObject {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addInspectedHeapObject"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CollectGarbage;
    impl crate::util::Command for CollectGarbage {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "collectGarbage"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [GetHeapObjectId].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHeapObjectIdParams {
        ///Identifier of the object to get heap object id for.
        #[serde(rename = "objectId")]
        pub object_id: crate::protocol_test::runtime::RemoteObjectId,
    }
    ///
    /// Return value for [GetHeapObjectId].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHeapObjectIdReturns {
        ///Id of the heap snapshot object corresponding to the passed remote object id.
        #[serde(rename = "heapSnapshotObjectId")]
        pub heap_snapshot_object_id: HeapSnapshotObjectId,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHeapObjectId;
    impl crate::util::Command for GetHeapObjectId {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getHeapObjectId"
        }
    }
    ///
    /// Parameter value for [GetObjectByHeapObjectId].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetObjectByHeapObjectIdParams {
        #[serde(rename = "objectId")]
        pub object_id: HeapSnapshotObjectId,
        ///Symbolic group name that can be used to release multiple objects.
        #[serde(rename = "objectGroup")]
        pub object_group: Option<String>,
    }
    ///
    /// Return value for [GetObjectByHeapObjectId].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetObjectByHeapObjectIdReturns {
        ///Evaluation result.
        #[serde(rename = "result")]
        pub result: crate::protocol_test::runtime::RemoteObject,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetObjectByHeapObjectId;
    impl crate::util::Command for GetObjectByHeapObjectId {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getObjectByHeapObjectId"
        }
    }
    ///
    /// Return value for [GetSamplingProfile].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSamplingProfileReturns {
        ///Return the sampling profile being collected.
        #[serde(rename = "profile")]
        pub profile: SamplingHeapProfile,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetSamplingProfile;
    impl crate::util::Command for GetSamplingProfile {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getSamplingProfile"
        }
    }
    ///
    /// Parameter value for [StartSampling].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartSamplingParams {
        ///Average sample interval in bytes. Poisson distribution is used for the intervals. The
        ///default value is 32768 bytes.
        #[serde(rename = "samplingInterval")]
        pub sampling_interval: Option<f64>,
        ///By default, the sampling heap profiler reports only objects which are
        ///still alive when the profile is returned via getSamplingProfile or
        ///stopSampling, which is useful for determining what functions contribute
        ///the most to steady-state memory usage. This flag instructs the sampling
        ///heap profiler to also include information about objects discarded by
        ///major GC, which will show which functions cause large temporary memory
        ///usage or long GC pauses.
        #[serde(rename = "includeObjectsCollectedByMajorGC")]
        pub include_objects_collected_by_major_gc: Option<bool>,
        ///By default, the sampling heap profiler reports only objects which are
        ///still alive when the profile is returned via getSamplingProfile or
        ///stopSampling, which is useful for determining what functions contribute
        ///the most to steady-state memory usage. This flag instructs the sampling
        ///heap profiler to also include information about objects discarded by
        ///minor GC, which is useful when tuning a latency-sensitive application
        ///for minimal GC activity.
        #[serde(rename = "includeObjectsCollectedByMinorGC")]
        pub include_objects_collected_by_minor_gc: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartSampling;
    impl crate::util::Command for StartSampling {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startSampling"
        }
    }
    ///
    /// Parameter value for [StartTrackingHeapObjects].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartTrackingHeapObjectsParams {
        #[serde(rename = "trackAllocations")]
        pub track_allocations: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartTrackingHeapObjects;
    impl crate::util::Command for StartTrackingHeapObjects {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startTrackingHeapObjects"
        }
    }
    ///
    /// Return value for [StopSampling].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopSamplingReturns {
        ///Recorded sampling heap profile.
        #[serde(rename = "profile")]
        pub profile: SamplingHeapProfile,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopSampling;
    impl crate::util::Command for StopSampling {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopSampling"
        }
    }
    ///
    /// Parameter value for [StopTrackingHeapObjects].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopTrackingHeapObjectsParams {
        ///If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken
        ///when the tracking is stopped.
        #[serde(rename = "reportProgress")]
        pub report_progress: Option<bool>,
        ///Deprecated in favor of `exposeInternals`.
        #[deprecated]
        #[serde(rename = "treatGlobalObjectsAsRoots")]
        pub treat_global_objects_as_roots: Option<bool>,
        ///If true, numerical values are included in the snapshot
        #[serde(rename = "captureNumericValue")]
        pub capture_numeric_value: Option<bool>,
        ///If true, exposes internals of the snapshot.
        #[serde(rename = "exposeInternals")]
        pub expose_internals: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopTrackingHeapObjects;
    impl crate::util::Command for StopTrackingHeapObjects {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopTrackingHeapObjects"
        }
    }
    ///
    /// Parameter value for [TakeHeapSnapshot].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeHeapSnapshotParams {
        ///If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
        #[serde(rename = "reportProgress")]
        pub report_progress: Option<bool>,
        ///If true, a raw snapshot without artificial roots will be generated.
        ///Deprecated in favor of `exposeInternals`.
        #[deprecated]
        #[serde(rename = "treatGlobalObjectsAsRoots")]
        pub treat_global_objects_as_roots: Option<bool>,
        ///If true, numerical values are included in the snapshot
        #[serde(rename = "captureNumericValue")]
        pub capture_numeric_value: Option<bool>,
        ///If true, exposes internals of the snapshot.
        #[serde(rename = "exposeInternals")]
        pub expose_internals: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakeHeapSnapshot;
    impl crate::util::Command for TakeHeapSnapshot {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "takeHeapSnapshot"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddHeapSnapshotChunkEvent {
        #[serde(rename = "chunk")]
        pub chunk: String,
    }
    ///If heap objects tracking has been started then backend may send update for one or more fragments
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct HeapStatsUpdateEvent {
        ///An array of triplets. Each triplet describes a fragment. The first integer is the fragment
        ///index, the second integer is a total count of objects for the fragment, the third integer is
        ///a total size of the objects for the fragment.
        #[serde(rename = "statsUpdate")]
        pub stats_update: Vec<i64>,
    }
    ///If heap objects tracking has been started then backend regularly sends a current value for last
    ///seen object id and corresponding timestamp. If the were changes in the heap since last event
    ///then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LastSeenObjectIdEvent {
        #[serde(rename = "lastSeenObjectId")]
        pub last_seen_object_id: i64,
        #[serde(rename = "timestamp")]
        pub timestamp: f64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReportHeapSnapshotProgressEvent {
        #[serde(rename = "done")]
        pub done: i64,
        #[serde(rename = "total")]
        pub total: i64,
        #[serde(rename = "finished")]
        pub finished: Option<bool>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ResetProfilesEvent {}
}
pub mod profiler {
    ///Profile node. Holds callsite information, execution statistics and child nodes.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ProfileNode {
        ///Unique id of the node.
        #[serde(rename = "id")]
        pub id: i64,
        ///Function location.
        #[serde(rename = "callFrame")]
        pub call_frame: crate::protocol_test::runtime::CallFrame,
        ///Number of samples where this node was on top of the call stack.
        #[serde(rename = "hitCount")]
        pub hit_count: Option<i64>,
        ///Child node ids.
        #[serde(rename = "children")]
        pub children: Option<Vec<i64>>,
        ///The reason of being not optimized. The function may be deoptimized or marked as don't
        ///optimize.
        #[serde(rename = "deoptReason")]
        pub deopt_reason: Option<String>,
        ///An array of source position ticks.
        #[serde(rename = "positionTicks")]
        pub position_ticks: Option<Vec<PositionTickInfo>>,
    }
    ///Profile.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Profile {
        ///The list of profile nodes. First item is the root node.
        #[serde(rename = "nodes")]
        pub nodes: Vec<ProfileNode>,
        ///Profiling start timestamp in microseconds.
        #[serde(rename = "startTime")]
        pub start_time: f64,
        ///Profiling end timestamp in microseconds.
        #[serde(rename = "endTime")]
        pub end_time: f64,
        ///Ids of samples top nodes.
        #[serde(rename = "samples")]
        pub samples: Option<Vec<i64>>,
        ///Time intervals between adjacent samples in microseconds. The first delta is relative to the
        ///profile startTime.
        #[serde(rename = "timeDeltas")]
        pub time_deltas: Option<Vec<i64>>,
    }
    ///Specifies a number of samples attributed to a certain source position.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PositionTickInfo {
        ///Source line number (1-based).
        #[serde(rename = "line")]
        pub line: i64,
        ///Number of samples attributed to the source line.
        #[serde(rename = "ticks")]
        pub ticks: i64,
    }
    ///Coverage data for a source range.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CoverageRange {
        ///JavaScript script source offset for the range start.
        #[serde(rename = "startOffset")]
        pub start_offset: i64,
        ///JavaScript script source offset for the range end.
        #[serde(rename = "endOffset")]
        pub end_offset: i64,
        ///Collected execution count of the source range.
        #[serde(rename = "count")]
        pub count: i64,
    }
    ///Coverage data for a JavaScript function.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FunctionCoverage {
        ///JavaScript function name.
        #[serde(rename = "functionName")]
        pub function_name: String,
        ///Source ranges inside the function with coverage data.
        #[serde(rename = "ranges")]
        pub ranges: Vec<CoverageRange>,
        ///Whether coverage data for this function has block granularity.
        #[serde(rename = "isBlockCoverage")]
        pub is_block_coverage: bool,
    }
    ///Coverage data for a JavaScript script.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScriptCoverage {
        ///JavaScript script id.
        #[serde(rename = "scriptId")]
        pub script_id: crate::protocol_test::runtime::ScriptId,
        ///JavaScript script name or url.
        #[serde(rename = "url")]
        pub url: String,
        ///Functions contained in the script that has coverage data.
        #[serde(rename = "functions")]
        pub functions: Vec<FunctionCoverage>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Return value for [GetBestEffortCoverage].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBestEffortCoverageReturns {
        ///Coverage data for the current isolate.
        #[serde(rename = "result")]
        pub result: Vec<ScriptCoverage>,
    }
    ///Collect coverage data for the current isolate. The coverage data may be incomplete due to
    ///garbage collection.
    ///---
    ///Return Type: [GetBestEffortCoverageReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetBestEffortCoverage;
    impl crate::util::Command for GetBestEffortCoverage {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getBestEffortCoverage"
        }
    }
    ///
    /// Parameter value for [SetSamplingInterval].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSamplingIntervalParams {
        ///New sampling interval in microseconds.
        #[serde(rename = "interval")]
        pub interval: i64,
    }
    ///Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
    ///---
    ///Parameter Type: [SetSamplingIntervalParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetSamplingInterval;
    impl crate::util::Command for SetSamplingInterval {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setSamplingInterval"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Start;
    impl crate::util::Command for Start {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "start"
        }
    }
    ///
    /// Parameter value for [StartPreciseCoverage].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartPreciseCoverageParams {
        ///Collect accurate call counts beyond simple 'covered' or 'not covered'.
        #[serde(rename = "callCount")]
        pub call_count: Option<bool>,
        ///Collect block-based coverage.
        #[serde(rename = "detailed")]
        pub detailed: Option<bool>,
        ///Allow the backend to send updates on its own initiative
        #[serde(rename = "allowTriggeredUpdates")]
        pub allow_triggered_updates: Option<bool>,
    }
    ///
    /// Return value for [StartPreciseCoverage].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartPreciseCoverageReturns {
        ///Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
        #[serde(rename = "timestamp")]
        pub timestamp: f64,
    }
    ///Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
    ///coverage may be incomplete. Enabling prevents running optimized code and resets execution
    ///counters.
    ///---
    ///Parameter Type: [StartPreciseCoverageParams]
    ///Return Type: [StartPreciseCoverageReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StartPreciseCoverage;
    impl crate::util::Command for StartPreciseCoverage {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "startPreciseCoverage"
        }
    }
    ///
    /// Return value for [Stop].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopReturns {
        ///Recorded profile.
        #[serde(rename = "profile")]
        pub profile: Profile,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Stop;
    impl crate::util::Command for Stop {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stop"
        }
    }
    ///Disable precise code coverage. Disabling releases unnecessary execution count records and allows
    ///executing optimized code.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StopPreciseCoverage;
    impl crate::util::Command for StopPreciseCoverage {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "stopPreciseCoverage"
        }
    }
    ///
    /// Return value for [TakePreciseCoverage].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakePreciseCoverageReturns {
        ///Coverage data for the current isolate.
        #[serde(rename = "result")]
        pub result: Vec<ScriptCoverage>,
        ///Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
        #[serde(rename = "timestamp")]
        pub timestamp: f64,
    }
    ///Collect coverage data for the current isolate, and resets execution counters. Precise code
    ///coverage needs to have started.
    ///---
    ///Return Type: [TakePreciseCoverageReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TakePreciseCoverage;
    impl crate::util::Command for TakePreciseCoverage {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "takePreciseCoverage"
        }
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ConsoleProfileFinishedEvent {
        #[serde(rename = "id")]
        pub id: String,
        ///Location of console.profileEnd().
        #[serde(rename = "location")]
        pub location: crate::protocol_test::debugger::Location,
        #[serde(rename = "profile")]
        pub profile: Profile,
        ///Profile title passed as an argument to console.profile().
        #[serde(rename = "title")]
        pub title: Option<String>,
    }
    ///Sent when new profile recording is started using console.profile() call.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ConsoleProfileStartedEvent {
        #[serde(rename = "id")]
        pub id: String,
        ///Location of console.profile().
        #[serde(rename = "location")]
        pub location: crate::protocol_test::debugger::Location,
        ///Profile title passed as an argument to console.profile().
        #[serde(rename = "title")]
        pub title: Option<String>,
    }
    ///Reports coverage delta since the last poll (either from an event like this, or from
    ///`takePreciseCoverage` for the current isolate. May only be sent if precise code
    ///coverage has been started. This event can be trigged by the embedder to, for example,
    ///trigger collection of coverage data immediately at a certain point in time.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PreciseCoverageDeltaUpdateEvent {
        ///Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
        #[serde(rename = "timestamp")]
        pub timestamp: f64,
        ///Identifier for distinguishing coverage events.
        #[serde(rename = "occasion")]
        pub occasion: String,
        ///Coverage data for the current isolate.
        #[serde(rename = "result")]
        pub result: Vec<ScriptCoverage>,
    }
}
///Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
///Evaluation results are returned as mirror object that expose object type, string representation
///and unique identifier that can be used for further object reference. Original objects are
///maintained in memory unless they are either explicitly released or are released along with the
///other objects in their object group.
pub mod runtime {
    ///Unique script identifier.
    pub type ScriptId = String;
    ///
    /// Enum for [SerializationOptions]'s `serialization`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum SerializationOptionsSerialization {
        #[serde(rename = "deep")]
        Deep,
        #[serde(rename = "json")]
        Json,
        #[serde(rename = "idOnly")]
        IdOnly,
    }
    ///Represents options for serialization. Overrides `generatePreview`, `returnByValue` and
    ///`generateWebDriverValue`.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SerializationOptions {
        #[serde(rename = "serialization")]
        pub serialization: SerializationOptionsSerialization,
        ///Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.
        #[serde(rename = "maxDepth")]
        pub max_depth: Option<i64>,
        ///Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
        ///serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
        ///Values can be only of type string or integer.
        #[serde(rename = "additionalParameters")]
        pub additional_parameters: Option<serde_json::Map<String, serde_json::Value>>,
    }
    ///
    /// Enum for [DeepSerializedValue]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum DeepSerializedValueType {
        #[serde(rename = "undefined")]
        Undefined,
        #[serde(rename = "null")]
        Null,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "boolean")]
        Boolean,
        #[serde(rename = "bigint")]
        Bigint,
        #[serde(rename = "regexp")]
        Regexp,
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "symbol")]
        Symbol,
        #[serde(rename = "array")]
        Array,
        #[serde(rename = "object")]
        Object,
        #[serde(rename = "function")]
        Function,
        #[serde(rename = "map")]
        Map,
        #[serde(rename = "set")]
        Set,
        #[serde(rename = "weakmap")]
        Weakmap,
        #[serde(rename = "weakset")]
        Weakset,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "proxy")]
        Proxy,
        #[serde(rename = "promise")]
        Promise,
        #[serde(rename = "typedarray")]
        Typedarray,
        #[serde(rename = "arraybuffer")]
        Arraybuffer,
        #[serde(rename = "node")]
        Node,
        #[serde(rename = "window")]
        Window,
    }
    ///Represents deep serialized value.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DeepSerializedValue {
        #[serde(rename = "type")]
        pub type_: DeepSerializedValueType,
        #[serde(rename = "value")]
        pub value: Option<serde_json::Value>,
        #[serde(rename = "objectId")]
        pub object_id: Option<String>,
        ///Set if value reference met more then once during serialization. In such
        ///case, value is provided only to one of the serialized values. Unique
        ///per value in the scope of one CDP call.
        #[serde(rename = "weakLocalObjectReference")]
        pub weak_local_object_reference: Option<i64>,
    }
    ///Unique object identifier.
    pub type RemoteObjectId = String;
    ///Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
    ///`-Infinity`, and bigint literals.
    pub type UnserializableValue = String;
    ///
    /// Enum for [RemoteObject]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum RemoteObjectType {
        #[serde(rename = "object")]
        Object,
        #[serde(rename = "function")]
        Function,
        #[serde(rename = "undefined")]
        Undefined,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "boolean")]
        Boolean,
        #[serde(rename = "symbol")]
        Symbol,
        #[serde(rename = "bigint")]
        Bigint,
    }
    ///
    /// Enum for [RemoteObject]'s `subtype`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum RemoteObjectSubtype {
        #[serde(rename = "array")]
        Array,
        #[serde(rename = "null")]
        Null,
        #[serde(rename = "node")]
        Node,
        #[serde(rename = "regexp")]
        Regexp,
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "map")]
        Map,
        #[serde(rename = "set")]
        Set,
        #[serde(rename = "weakmap")]
        Weakmap,
        #[serde(rename = "weakset")]
        Weakset,
        #[serde(rename = "iterator")]
        Iterator,
        #[serde(rename = "generator")]
        Generator,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "proxy")]
        Proxy,
        #[serde(rename = "promise")]
        Promise,
        #[serde(rename = "typedarray")]
        Typedarray,
        #[serde(rename = "arraybuffer")]
        Arraybuffer,
        #[serde(rename = "dataview")]
        Dataview,
        #[serde(rename = "webassemblymemory")]
        Webassemblymemory,
        #[serde(rename = "wasmvalue")]
        Wasmvalue,
    }
    ///Mirror object referencing original JavaScript object.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoteObject {
        ///Object type.
        #[serde(rename = "type")]
        pub type_: RemoteObjectType,
        ///Object subtype hint. Specified for `object` type values only.
        ///NOTE: If you change anything here, make sure to also update
        ///`subtype` in `ObjectPreview` and `PropertyPreview` below.
        #[serde(rename = "subtype")]
        pub subtype: Option<Option<RemoteObjectSubtype>>,
        ///Object class (constructor) name. Specified for `object` type values only.
        #[serde(rename = "className")]
        pub class_name: Option<String>,
        ///Remote object value in case of primitive values or JSON values (if it was requested).
        #[serde(rename = "value")]
        pub value: Option<serde_json::Value>,
        ///Primitive value which can not be JSON-stringified does not have `value`, but gets this
        ///property.
        #[serde(rename = "unserializableValue")]
        pub unserializable_value: Option<UnserializableValue>,
        ///String representation of the object.
        #[serde(rename = "description")]
        pub description: Option<String>,
        ///Deprecated. Use `deepSerializedValue` instead. WebDriver BiDi representation of the value.
        #[deprecated]
        #[serde(rename = "webDriverValue")]
        pub web_driver_value: Option<DeepSerializedValue>,
        ///Deep serialized value.
        #[serde(rename = "deepSerializedValue")]
        pub deep_serialized_value: Option<DeepSerializedValue>,
        ///Unique object identifier (for non-primitive values).
        #[serde(rename = "objectId")]
        pub object_id: Option<RemoteObjectId>,
        ///Preview containing abbreviated property values. Specified for `object` type values only.
        #[serde(rename = "preview")]
        pub preview: Option<ObjectPreview>,
        #[serde(rename = "customPreview")]
        pub custom_preview: Option<CustomPreview>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CustomPreview {
        ///The JSON-stringified result of formatter.header(object, config) call.
        ///It contains json ML array that represents RemoteObject.
        #[serde(rename = "header")]
        pub header: String,
        ///If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
        ///contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
        ///The result value is json ML array.
        #[serde(rename = "bodyGetterId")]
        pub body_getter_id: Option<RemoteObjectId>,
    }
    ///
    /// Enum for [ObjectPreview]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ObjectPreviewType {
        #[serde(rename = "object")]
        Object,
        #[serde(rename = "function")]
        Function,
        #[serde(rename = "undefined")]
        Undefined,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "boolean")]
        Boolean,
        #[serde(rename = "symbol")]
        Symbol,
        #[serde(rename = "bigint")]
        Bigint,
    }
    ///
    /// Enum for [ObjectPreview]'s `subtype`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ObjectPreviewSubtype {
        #[serde(rename = "array")]
        Array,
        #[serde(rename = "null")]
        Null,
        #[serde(rename = "node")]
        Node,
        #[serde(rename = "regexp")]
        Regexp,
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "map")]
        Map,
        #[serde(rename = "set")]
        Set,
        #[serde(rename = "weakmap")]
        Weakmap,
        #[serde(rename = "weakset")]
        Weakset,
        #[serde(rename = "iterator")]
        Iterator,
        #[serde(rename = "generator")]
        Generator,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "proxy")]
        Proxy,
        #[serde(rename = "promise")]
        Promise,
        #[serde(rename = "typedarray")]
        Typedarray,
        #[serde(rename = "arraybuffer")]
        Arraybuffer,
        #[serde(rename = "dataview")]
        Dataview,
        #[serde(rename = "webassemblymemory")]
        Webassemblymemory,
        #[serde(rename = "wasmvalue")]
        Wasmvalue,
    }
    ///Object containing abbreviated remote object value.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ObjectPreview {
        ///Object type.
        #[serde(rename = "type")]
        pub type_: ObjectPreviewType,
        ///Object subtype hint. Specified for `object` type values only.
        #[serde(rename = "subtype")]
        pub subtype: Option<Option<ObjectPreviewSubtype>>,
        ///String representation of the object.
        #[serde(rename = "description")]
        pub description: Option<String>,
        ///True iff some of the properties or entries of the original object did not fit.
        #[serde(rename = "overflow")]
        pub overflow: bool,
        ///List of the properties.
        #[serde(rename = "properties")]
        pub properties: Vec<PropertyPreview>,
        ///List of the entries. Specified for `map` and `set` subtype values only.
        #[serde(rename = "entries")]
        pub entries: Option<Vec<EntryPreview>>,
    }
    ///
    /// Enum for [PropertyPreview]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PropertyPreviewType {
        #[serde(rename = "object")]
        Object,
        #[serde(rename = "function")]
        Function,
        #[serde(rename = "undefined")]
        Undefined,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "boolean")]
        Boolean,
        #[serde(rename = "symbol")]
        Symbol,
        #[serde(rename = "accessor")]
        Accessor,
        #[serde(rename = "bigint")]
        Bigint,
    }
    ///
    /// Enum for [PropertyPreview]'s `subtype`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum PropertyPreviewSubtype {
        #[serde(rename = "array")]
        Array,
        #[serde(rename = "null")]
        Null,
        #[serde(rename = "node")]
        Node,
        #[serde(rename = "regexp")]
        Regexp,
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "map")]
        Map,
        #[serde(rename = "set")]
        Set,
        #[serde(rename = "weakmap")]
        Weakmap,
        #[serde(rename = "weakset")]
        Weakset,
        #[serde(rename = "iterator")]
        Iterator,
        #[serde(rename = "generator")]
        Generator,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "proxy")]
        Proxy,
        #[serde(rename = "promise")]
        Promise,
        #[serde(rename = "typedarray")]
        Typedarray,
        #[serde(rename = "arraybuffer")]
        Arraybuffer,
        #[serde(rename = "dataview")]
        Dataview,
        #[serde(rename = "webassemblymemory")]
        Webassemblymemory,
        #[serde(rename = "wasmvalue")]
        Wasmvalue,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PropertyPreview {
        ///Property name.
        #[serde(rename = "name")]
        pub name: String,
        ///Object type. Accessor means that the property itself is an accessor property.
        #[serde(rename = "type")]
        pub type_: PropertyPreviewType,
        ///User-friendly property value string.
        #[serde(rename = "value")]
        pub value: Option<String>,
        ///Nested value preview.
        #[serde(rename = "valuePreview")]
        pub value_preview: Option<ObjectPreview>,
        ///Object subtype hint. Specified for `object` type values only.
        #[serde(rename = "subtype")]
        pub subtype: Option<Option<PropertyPreviewSubtype>>,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EntryPreview {
        ///Preview of the key. Specified for map-like collection entries.
        #[serde(rename = "key")]
        pub key: Option<ObjectPreview>,
        ///Preview of the value.
        #[serde(rename = "value")]
        pub value: ObjectPreview,
    }
    ///Object property descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PropertyDescriptor {
        ///Property name or symbol description.
        #[serde(rename = "name")]
        pub name: String,
        ///The value associated with the property.
        #[serde(rename = "value")]
        pub value: Option<RemoteObject>,
        ///True if the value associated with the property may be changed (data descriptors only).
        #[serde(rename = "writable")]
        pub writable: Option<bool>,
        ///A function which serves as a getter for the property, or `undefined` if there is no getter
        ///(accessor descriptors only).
        #[serde(rename = "get")]
        pub get: Option<RemoteObject>,
        ///A function which serves as a setter for the property, or `undefined` if there is no setter
        ///(accessor descriptors only).
        #[serde(rename = "set")]
        pub set: Option<RemoteObject>,
        ///True if the type of this property descriptor may be changed and if the property may be
        ///deleted from the corresponding object.
        #[serde(rename = "configurable")]
        pub configurable: bool,
        ///True if this property shows up during enumeration of the properties on the corresponding
        ///object.
        #[serde(rename = "enumerable")]
        pub enumerable: bool,
        ///True if the result was thrown during the evaluation.
        #[serde(rename = "wasThrown")]
        pub was_thrown: Option<bool>,
        ///True if the property is owned for the object.
        #[serde(rename = "isOwn")]
        pub is_own: Option<bool>,
        ///Property symbol object, if the property is of the `symbol` type.
        #[serde(rename = "symbol")]
        pub symbol: Option<RemoteObject>,
    }
    ///Object internal property descriptor. This property isn't normally visible in JavaScript code.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InternalPropertyDescriptor {
        ///Conventional property name.
        #[serde(rename = "name")]
        pub name: String,
        ///The value associated with the property.
        #[serde(rename = "value")]
        pub value: Option<RemoteObject>,
    }
    ///Object private field descriptor.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PrivatePropertyDescriptor {
        ///Private property name.
        #[serde(rename = "name")]
        pub name: String,
        ///The value associated with the private property.
        #[serde(rename = "value")]
        pub value: Option<RemoteObject>,
        ///A function which serves as a getter for the private property,
        ///or `undefined` if there is no getter (accessor descriptors only).
        #[serde(rename = "get")]
        pub get: Option<RemoteObject>,
        ///A function which serves as a setter for the private property,
        ///or `undefined` if there is no setter (accessor descriptors only).
        #[serde(rename = "set")]
        pub set: Option<RemoteObject>,
    }
    ///Represents function call argument. Either remote object id `objectId`, primitive `value`,
    ///unserializable primitive value or neither of (for undefined) them should be specified.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CallArgument {
        ///Primitive value or serializable javascript object.
        #[serde(rename = "value")]
        pub value: Option<serde_json::Value>,
        ///Primitive value which can not be JSON-stringified.
        #[serde(rename = "unserializableValue")]
        pub unserializable_value: Option<UnserializableValue>,
        ///Remote object handle.
        #[serde(rename = "objectId")]
        pub object_id: Option<RemoteObjectId>,
    }
    ///Id of an execution context.
    pub type ExecutionContextId = i64;
    ///Description of an isolated world.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecutionContextDescription {
        ///Unique id of the execution context. It can be used to specify in which execution context
        ///script evaluation should be performed.
        #[serde(rename = "id")]
        pub id: ExecutionContextId,
        ///Execution context origin.
        #[serde(rename = "origin")]
        pub origin: String,
        ///Human readable name describing given context.
        #[serde(rename = "name")]
        pub name: String,
        ///A system-unique execution context identifier. Unlike the id, this is unique across
        ///multiple processes, so can be reliably used to identify specific context while backend
        ///performs a cross-process navigation.
        #[serde(rename = "uniqueId")]
        pub unique_id: String,
        ///Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
        #[serde(rename = "auxData")]
        pub aux_data: Option<serde_json::Map<String, serde_json::Value>>,
    }
    ///Detailed information about exception (or error) that was thrown during script compilation or
    ///execution.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExceptionDetails {
        ///Exception id.
        #[serde(rename = "exceptionId")]
        pub exception_id: i64,
        ///Exception text, which should be used together with exception object when available.
        #[serde(rename = "text")]
        pub text: String,
        ///Line number of the exception location (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        ///Column number of the exception location (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
        ///Script ID of the exception location.
        #[serde(rename = "scriptId")]
        pub script_id: Option<ScriptId>,
        ///URL of the exception location, to be used when the script was not reported.
        #[serde(rename = "url")]
        pub url: Option<String>,
        ///JavaScript stack trace if available.
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<StackTrace>,
        ///Exception object if available.
        #[serde(rename = "exception")]
        pub exception: Option<RemoteObject>,
        ///Identifier of the context where exception happened.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
        ///Dictionary with entries of meta data that the client associated
        ///with this exception, such as information about associated network
        ///requests, etc.
        #[serde(rename = "exceptionMetaData")]
        pub exception_meta_data: Option<serde_json::Map<String, serde_json::Value>>,
    }
    ///Number of milliseconds since epoch.
    pub type Timestamp = f64;
    ///Number of milliseconds.
    pub type TimeDelta = f64;
    ///Stack entry for runtime errors and assertions.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CallFrame {
        ///JavaScript function name.
        #[serde(rename = "functionName")]
        pub function_name: String,
        ///JavaScript script id.
        #[serde(rename = "scriptId")]
        pub script_id: ScriptId,
        ///JavaScript script name or url.
        #[serde(rename = "url")]
        pub url: String,
        ///JavaScript script line number (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        ///JavaScript script column number (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }
    ///Call frames for assertions or error messages.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StackTrace {
        ///String label of this stack trace. For async traces this may be a name of the function that
        ///initiated the async call.
        #[serde(rename = "description")]
        pub description: Option<String>,
        ///JavaScript function name.
        #[serde(rename = "callFrames")]
        pub call_frames: Vec<CallFrame>,
        ///Asynchronous JavaScript stack trace that preceded this stack, if available.
        #[serde(rename = "parent")]
        pub parent: Option<Box<StackTrace>>,
        ///Asynchronous JavaScript stack trace that preceded this stack, if available.
        #[serde(rename = "parentId")]
        pub parent_id: Option<StackTraceId>,
    }
    ///Unique identifier of current debugger.
    pub type UniqueDebuggerId = String;
    ///If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
    ///allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct StackTraceId {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "debuggerId")]
        pub debugger_id: Option<UniqueDebuggerId>,
    }
    ///
    /// Parameter value for [AwaitPromise].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AwaitPromiseParams {
        ///Identifier of the promise.
        #[serde(rename = "promiseObjectId")]
        pub promise_object_id: RemoteObjectId,
        ///Whether the result is expected to be a JSON object that should be sent by value.
        #[serde(rename = "returnByValue")]
        pub return_by_value: Option<bool>,
        ///Whether preview should be generated for the result.
        #[serde(rename = "generatePreview")]
        pub generate_preview: Option<bool>,
    }
    ///
    /// Return value for [AwaitPromise].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AwaitPromiseReturns {
        ///Promise result. Will contain rejected value if promise was rejected.
        #[serde(rename = "result")]
        pub result: RemoteObject,
        ///Exception details if stack strace is available.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }
    ///Add handler to promise with given promise object id.
    ///---
    ///Parameter Type: [AwaitPromiseParams]
    ///Return Type: [AwaitPromiseReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AwaitPromise;
    impl crate::util::Command for AwaitPromise {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "awaitPromise"
        }
    }
    ///
    /// Parameter value for [CallFunctionOn].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CallFunctionOnParams {
        ///Declaration of the function to call.
        #[serde(rename = "functionDeclaration")]
        pub function_declaration: String,
        ///Identifier of the object to call function on. Either objectId or executionContextId should
        ///be specified.
        #[serde(rename = "objectId")]
        pub object_id: Option<RemoteObjectId>,
        ///Call arguments. All call arguments must belong to the same JavaScript world as the target
        ///object.
        #[serde(rename = "arguments")]
        pub arguments: Option<Vec<CallArgument>>,
        ///In silent mode exceptions thrown during evaluation are not reported and do not pause
        ///execution. Overrides `setPauseOnException` state.
        #[serde(rename = "silent")]
        pub silent: Option<bool>,
        ///Whether the result is expected to be a JSON object which should be sent by value.
        ///Can be overriden by `serializationOptions`.
        #[serde(rename = "returnByValue")]
        pub return_by_value: Option<bool>,
        ///Whether preview should be generated for the result.
        #[serde(rename = "generatePreview")]
        pub generate_preview: Option<bool>,
        ///Whether execution should be treated as initiated by user in the UI.
        #[serde(rename = "userGesture")]
        pub user_gesture: Option<bool>,
        ///Whether execution should `await` for resulting value and return once awaited promise is
        ///resolved.
        #[serde(rename = "awaitPromise")]
        pub await_promise: Option<bool>,
        ///Specifies execution context which global object will be used to call function on. Either
        ///executionContextId or objectId should be specified.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
        ///Symbolic group name that can be used to release multiple objects. If objectGroup is not
        ///specified and objectId is, objectGroup will be inherited from object.
        #[serde(rename = "objectGroup")]
        pub object_group: Option<String>,
        ///Whether to throw an exception if side effect cannot be ruled out during evaluation.
        #[serde(rename = "throwOnSideEffect")]
        pub throw_on_side_effect: Option<bool>,
        ///An alternative way to specify the execution context to call function on.
        ///Compared to contextId that may be reused across processes, this is guaranteed to be
        ///system-unique, so it can be used to prevent accidental function call
        ///in context different than intended (e.g. as a result of navigation across process
        ///boundaries).
        ///This is mutually exclusive with `executionContextId`.
        #[serde(rename = "uniqueContextId")]
        pub unique_context_id: Option<String>,
        ///Deprecated. Use `serializationOptions: {serialization:"deep"}` instead.
        ///Whether the result should contain `webDriverValue`, serialized according to
        ///https://w3c.github.io/webdriver-bidi. This is mutually exclusive with `returnByValue`, but
        ///resulting `objectId` is still provided.
        #[deprecated]
        #[serde(rename = "generateWebDriverValue")]
        pub generate_web_driver_value: Option<bool>,
        ///Specifies the result serialization. If provided, overrides
        ///`generatePreview`, `returnByValue` and `generateWebDriverValue`.
        #[serde(rename = "serializationOptions")]
        pub serialization_options: Option<SerializationOptions>,
    }
    ///
    /// Return value for [CallFunctionOn].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CallFunctionOnReturns {
        ///Call result.
        #[serde(rename = "result")]
        pub result: RemoteObject,
        ///Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }
    ///Calls function with given declaration on the given object. Object group of the result is
    ///inherited from the target object.
    ///---
    ///Parameter Type: [CallFunctionOnParams]
    ///Return Type: [CallFunctionOnReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CallFunctionOn;
    impl crate::util::Command for CallFunctionOn {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "callFunctionOn"
        }
    }
    ///
    /// Parameter value for [CompileScript].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CompileScriptParams {
        ///Expression to compile.
        #[serde(rename = "expression")]
        pub expression: String,
        ///Source url to be set for the script.
        #[serde(rename = "sourceURL")]
        pub source_url: String,
        ///Specifies whether the compiled script should be persisted.
        #[serde(rename = "persistScript")]
        pub persist_script: bool,
        ///Specifies in which execution context to perform script run. If the parameter is omitted the
        ///evaluation will be performed in the context of the inspected page.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
    }
    ///
    /// Return value for [CompileScript].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CompileScriptReturns {
        ///Id of the script.
        #[serde(rename = "scriptId")]
        pub script_id: Option<ScriptId>,
        ///Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }
    ///Compiles expression.
    ///---
    ///Parameter Type: [CompileScriptParams]
    ///Return Type: [CompileScriptReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CompileScript;
    impl crate::util::Command for CompileScript {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "compileScript"
        }
    }
    ///Disables reporting of execution contexts creation.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Disable;
    impl crate::util::Command for Disable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "disable"
        }
    }
    ///Discards collected exceptions and console API calls.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DiscardConsoleEntries;
    impl crate::util::Command for DiscardConsoleEntries {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "discardConsoleEntries"
        }
    }
    ///Enables reporting of execution contexts creation by means of `executionContextCreated` event.
    ///When the reporting gets enabled the event will be sent immediately for each existing execution
    ///context.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Enable;
    impl crate::util::Command for Enable {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "enable"
        }
    }
    ///
    /// Parameter value for [Evaluate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EvaluateParams {
        ///Expression to evaluate.
        #[serde(rename = "expression")]
        pub expression: String,
        ///Symbolic group name that can be used to release multiple objects.
        #[serde(rename = "objectGroup")]
        pub object_group: Option<String>,
        ///Determines whether Command Line API should be available during the evaluation.
        #[serde(rename = "includeCommandLineAPI")]
        pub include_command_line_api: Option<bool>,
        ///In silent mode exceptions thrown during evaluation are not reported and do not pause
        ///execution. Overrides `setPauseOnException` state.
        #[serde(rename = "silent")]
        pub silent: Option<bool>,
        ///Specifies in which execution context to perform evaluation. If the parameter is omitted the
        ///evaluation will be performed in the context of the inspected page.
        ///This is mutually exclusive with `uniqueContextId`, which offers an
        ///alternative way to identify the execution context that is more reliable
        ///in a multi-process environment.
        #[serde(rename = "contextId")]
        pub context_id: Option<ExecutionContextId>,
        ///Whether the result is expected to be a JSON object that should be sent by value.
        #[serde(rename = "returnByValue")]
        pub return_by_value: Option<bool>,
        ///Whether preview should be generated for the result.
        #[serde(rename = "generatePreview")]
        pub generate_preview: Option<bool>,
        ///Whether execution should be treated as initiated by user in the UI.
        #[serde(rename = "userGesture")]
        pub user_gesture: Option<bool>,
        ///Whether execution should `await` for resulting value and return once awaited promise is
        ///resolved.
        #[serde(rename = "awaitPromise")]
        pub await_promise: Option<bool>,
        ///Whether to throw an exception if side effect cannot be ruled out during evaluation.
        ///This implies `disableBreaks` below.
        #[serde(rename = "throwOnSideEffect")]
        pub throw_on_side_effect: Option<bool>,
        ///Terminate execution after timing out (number of milliseconds).
        #[serde(rename = "timeout")]
        pub timeout: Option<TimeDelta>,
        ///Disable breakpoints during execution.
        #[serde(rename = "disableBreaks")]
        pub disable_breaks: Option<bool>,
        ///Setting this flag to true enables `let` re-declaration and top-level `await`.
        ///Note that `let` variables can only be re-declared if they originate from
        ///`replMode` themselves.
        #[serde(rename = "replMode")]
        pub repl_mode: Option<bool>,
        ///The Content Security Policy (CSP) for the target might block 'unsafe-eval'
        ///which includes eval(), Function(), setTimeout() and setInterval()
        ///when called with non-callable arguments. This flag bypasses CSP for this
        ///evaluation and allows unsafe-eval. Defaults to true.
        #[serde(rename = "allowUnsafeEvalBlockedByCSP")]
        pub allow_unsafe_eval_blocked_by_csp: Option<bool>,
        ///An alternative way to specify the execution context to evaluate in.
        ///Compared to contextId that may be reused across processes, this is guaranteed to be
        ///system-unique, so it can be used to prevent accidental evaluation of the expression
        ///in context different than intended (e.g. as a result of navigation across process
        ///boundaries).
        ///This is mutually exclusive with `contextId`.
        #[serde(rename = "uniqueContextId")]
        pub unique_context_id: Option<String>,
        ///Deprecated. Use `serializationOptions: {serialization:"deep"}` instead.
        ///Whether the result should contain `webDriverValue`, serialized
        ///according to
        ///https://w3c.github.io/webdriver-bidi. This is mutually exclusive with `returnByValue`, but
        ///resulting `objectId` is still provided.
        #[deprecated]
        #[serde(rename = "generateWebDriverValue")]
        pub generate_web_driver_value: Option<bool>,
        ///Specifies the result serialization. If provided, overrides
        ///`generatePreview`, `returnByValue` and `generateWebDriverValue`.
        #[serde(rename = "serializationOptions")]
        pub serialization_options: Option<SerializationOptions>,
    }
    ///
    /// Return value for [Evaluate].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EvaluateReturns {
        ///Evaluation result.
        #[serde(rename = "result")]
        pub result: RemoteObject,
        ///Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }
    ///Evaluates expression on global object.
    ///---
    ///Parameter Type: [EvaluateParams]
    ///Return Type: [EvaluateReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Evaluate;
    impl crate::util::Command for Evaluate {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "evaluate"
        }
    }
    ///
    /// Return value for [GetIsolateId].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetIsolateIdReturns {
        ///The isolate id.
        #[serde(rename = "id")]
        pub id: String,
    }
    ///Returns the isolate id.
    ///---
    ///Return Type: [GetIsolateIdReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetIsolateId;
    impl crate::util::Command for GetIsolateId {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getIsolateId"
        }
    }
    ///
    /// Return value for [GetHeapUsage].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHeapUsageReturns {
        ///Used heap size in bytes.
        #[serde(rename = "usedSize")]
        pub used_size: f64,
        ///Allocated heap size in bytes.
        #[serde(rename = "totalSize")]
        pub total_size: f64,
    }
    ///Returns the JavaScript heap usage.
    ///It is the total usage of the corresponding isolate not scoped to a particular Runtime.
    ///---
    ///Return Type: [GetHeapUsageReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetHeapUsage;
    impl crate::util::Command for GetHeapUsage {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getHeapUsage"
        }
    }
    ///
    /// Parameter value for [GetProperties].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPropertiesParams {
        ///Identifier of the object to return properties for.
        #[serde(rename = "objectId")]
        pub object_id: RemoteObjectId,
        ///If true, returns properties belonging only to the element itself, not to its prototype
        ///chain.
        #[serde(rename = "ownProperties")]
        pub own_properties: Option<bool>,
        ///If true, returns accessor properties (with getter/setter) only; internal properties are not
        ///returned either.
        #[serde(rename = "accessorPropertiesOnly")]
        pub accessor_properties_only: Option<bool>,
        ///Whether preview should be generated for the results.
        #[serde(rename = "generatePreview")]
        pub generate_preview: Option<bool>,
        ///If true, returns non-indexed properties only.
        #[serde(rename = "nonIndexedPropertiesOnly")]
        pub non_indexed_properties_only: Option<bool>,
    }
    ///
    /// Return value for [GetProperties].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetPropertiesReturns {
        ///Object properties.
        #[serde(rename = "result")]
        pub result: Vec<PropertyDescriptor>,
        ///Internal object properties (only of the element itself).
        #[serde(rename = "internalProperties")]
        pub internal_properties: Option<Vec<InternalPropertyDescriptor>>,
        ///Object private properties.
        #[serde(rename = "privateProperties")]
        pub private_properties: Option<Vec<PrivatePropertyDescriptor>>,
        ///Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }
    ///Returns properties of a given object. Object group of the result is inherited from the target
    ///object.
    ///---
    ///Parameter Type: [GetPropertiesParams]
    ///Return Type: [GetPropertiesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetProperties;
    impl crate::util::Command for GetProperties {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getProperties"
        }
    }
    ///
    /// Parameter value for [GlobalLexicalScopeNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GlobalLexicalScopeNamesParams {
        ///Specifies in which execution context to lookup global scope variables.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
    }
    ///
    /// Return value for [GlobalLexicalScopeNames].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GlobalLexicalScopeNamesReturns {
        #[serde(rename = "names")]
        pub names: Vec<String>,
    }
    ///Returns all let, const and class variables from global scope.
    ///---
    ///Parameter Type: [GlobalLexicalScopeNamesParams]
    ///Return Type: [GlobalLexicalScopeNamesReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GlobalLexicalScopeNames;
    impl crate::util::Command for GlobalLexicalScopeNames {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "globalLexicalScopeNames"
        }
    }
    ///
    /// Parameter value for [QueryObjects].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QueryObjectsParams {
        ///Identifier of the prototype to return objects for.
        #[serde(rename = "prototypeObjectId")]
        pub prototype_object_id: RemoteObjectId,
        ///Symbolic group name that can be used to release the results.
        #[serde(rename = "objectGroup")]
        pub object_group: Option<String>,
    }
    ///
    /// Return value for [QueryObjects].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QueryObjectsReturns {
        ///Array with objects.
        #[serde(rename = "objects")]
        pub objects: RemoteObject,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct QueryObjects;
    impl crate::util::Command for QueryObjects {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "queryObjects"
        }
    }
    ///
    /// Parameter value for [ReleaseObject].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReleaseObjectParams {
        ///Identifier of the object to release.
        #[serde(rename = "objectId")]
        pub object_id: RemoteObjectId,
    }
    ///Releases remote object with given id.
    ///---
    ///Parameter Type: [ReleaseObjectParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReleaseObject;
    impl crate::util::Command for ReleaseObject {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "releaseObject"
        }
    }
    ///
    /// Parameter value for [ReleaseObjectGroup].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReleaseObjectGroupParams {
        ///Symbolic object group name.
        #[serde(rename = "objectGroup")]
        pub object_group: String,
    }
    ///Releases all remote objects that belong to a given group.
    ///---
    ///Parameter Type: [ReleaseObjectGroupParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ReleaseObjectGroup;
    impl crate::util::Command for ReleaseObjectGroup {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "releaseObjectGroup"
        }
    }
    ///Tells inspected instance to run if it was waiting for debugger to attach.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RunIfWaitingForDebugger;
    impl crate::util::Command for RunIfWaitingForDebugger {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "runIfWaitingForDebugger"
        }
    }
    ///
    /// Parameter value for [RunScript].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RunScriptParams {
        ///Id of the script to run.
        #[serde(rename = "scriptId")]
        pub script_id: ScriptId,
        ///Specifies in which execution context to perform script run. If the parameter is omitted the
        ///evaluation will be performed in the context of the inspected page.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
        ///Symbolic group name that can be used to release multiple objects.
        #[serde(rename = "objectGroup")]
        pub object_group: Option<String>,
        ///In silent mode exceptions thrown during evaluation are not reported and do not pause
        ///execution. Overrides `setPauseOnException` state.
        #[serde(rename = "silent")]
        pub silent: Option<bool>,
        ///Determines whether Command Line API should be available during the evaluation.
        #[serde(rename = "includeCommandLineAPI")]
        pub include_command_line_api: Option<bool>,
        ///Whether the result is expected to be a JSON object which should be sent by value.
        #[serde(rename = "returnByValue")]
        pub return_by_value: Option<bool>,
        ///Whether preview should be generated for the result.
        #[serde(rename = "generatePreview")]
        pub generate_preview: Option<bool>,
        ///Whether execution should `await` for resulting value and return once awaited promise is
        ///resolved.
        #[serde(rename = "awaitPromise")]
        pub await_promise: Option<bool>,
    }
    ///
    /// Return value for [RunScript].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RunScriptReturns {
        ///Run result.
        #[serde(rename = "result")]
        pub result: RemoteObject,
        ///Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }
    ///Runs script with given id in a given context.
    ///---
    ///Parameter Type: [RunScriptParams]
    ///Return Type: [RunScriptReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RunScript;
    impl crate::util::Command for RunScript {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "runScript"
        }
    }
    ///
    /// Parameter value for [SetAsyncCallStackDepth].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAsyncCallStackDepthParams {
        ///Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
        ///call stacks (default).
        #[serde(rename = "maxDepth")]
        pub max_depth: i64,
    }
    ///Enables or disables async call stacks tracking.
    ///---
    ///Parameter Type: [SetAsyncCallStackDepthParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetAsyncCallStackDepth;
    impl crate::util::Command for SetAsyncCallStackDepth {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setAsyncCallStackDepth"
        }
    }
    ///
    /// Parameter value for [SetCustomObjectFormatterEnabled].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCustomObjectFormatterEnabledParams {
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetCustomObjectFormatterEnabled;
    impl crate::util::Command for SetCustomObjectFormatterEnabled {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setCustomObjectFormatterEnabled"
        }
    }
    ///
    /// Parameter value for [SetMaxCallStackSizeToCapture].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetMaxCallStackSizeToCaptureParams {
        #[serde(rename = "size")]
        pub size: i64,
    }
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetMaxCallStackSizeToCapture;
    impl crate::util::Command for SetMaxCallStackSizeToCapture {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "setMaxCallStackSizeToCapture"
        }
    }
    ///Terminate current or next JavaScript execution.
    ///Will cancel the termination when the outer-most script execution ends.
    ///---
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TerminateExecution;
    impl crate::util::Command for TerminateExecution {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "terminateExecution"
        }
    }
    ///
    /// Parameter value for [AddBinding].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddBindingParams {
        #[serde(rename = "name")]
        pub name: String,
        ///If specified, the binding would only be exposed to the specified
        ///execution context. If omitted and `executionContextName` is not set,
        ///the binding is exposed to all execution contexts of the target.
        ///This parameter is mutually exclusive with `executionContextName`.
        ///Deprecated in favor of `executionContextName` due to an unclear use case
        ///and bugs in implementation (crbug.com/1169639). `executionContextId` will be
        ///removed in the future.
        #[deprecated]
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
        ///If specified, the binding is exposed to the executionContext with
        ///matching name, even for contexts created after the binding is added.
        ///See also `ExecutionContext.name` and `worldName` parameter to
        ///`Page.addScriptToEvaluateOnNewDocument`.
        ///This parameter is mutually exclusive with `executionContextId`.
        #[serde(rename = "executionContextName")]
        pub execution_context_name: Option<String>,
    }
    ///If executionContextId is empty, adds binding with the given name on the
    ///global objects of all inspected contexts, including those created later,
    ///bindings survive reloads.
    ///Binding function takes exactly one argument, this argument should be string,
    ///in case of any other input, function throws an exception.
    ///Each binding function call produces Runtime.bindingCalled notification.
    ///---
    ///Parameter Type: [AddBindingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddBinding;
    impl crate::util::Command for AddBinding {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "addBinding"
        }
    }
    ///
    /// Parameter value for [RemoveBinding].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveBindingParams {
        #[serde(rename = "name")]
        pub name: String,
    }
    ///This method does not remove binding function from global object but
    ///unsubscribes current runtime agent from Runtime.bindingCalled notifications.
    ///---
    ///Parameter Type: [RemoveBindingParams]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RemoveBinding;
    impl crate::util::Command for RemoveBinding {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "removeBinding"
        }
    }
    ///
    /// Parameter value for [GetExceptionDetails].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetExceptionDetailsParams {
        ///The error object for which to resolve the exception details.
        #[serde(rename = "errorObjectId")]
        pub error_object_id: RemoteObjectId,
    }
    ///
    /// Return value for [GetExceptionDetails].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetExceptionDetailsReturns {
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }
    ///This method tries to lookup and populate exception details for a
    ///JavaScript Error object.
    ///Note that the stackTrace portion of the resulting exceptionDetails will
    ///only be populated if the Runtime domain was enabled at the time when the
    ///Error was thrown.
    ///---
    ///Parameter Type: [GetExceptionDetailsParams]
    ///Return Type: [GetExceptionDetailsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetExceptionDetails;
    impl crate::util::Command for GetExceptionDetails {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getExceptionDetails"
        }
    }
    ///Notification is issued every time when binding is called.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BindingCalledEvent {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "payload")]
        pub payload: String,
        ///Identifier of the context where the call was made.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: ExecutionContextId,
    }
    ///
    /// Enum for [ConsoleApiCalledEvent]'s `type_`
    /// ---
    /// ðŸ¤– Autogenerated
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub enum ConsoleApiCalledEventType {
        #[serde(rename = "log")]
        Log,
        #[serde(rename = "debug")]
        Debug,
        #[serde(rename = "info")]
        Info,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "warning")]
        Warning,
        #[serde(rename = "dir")]
        Dir,
        #[serde(rename = "dirxml")]
        Dirxml,
        #[serde(rename = "table")]
        Table,
        #[serde(rename = "trace")]
        Trace,
        #[serde(rename = "clear")]
        Clear,
        #[serde(rename = "startGroup")]
        StartGroup,
        #[serde(rename = "startGroupCollapsed")]
        StartGroupCollapsed,
        #[serde(rename = "endGroup")]
        EndGroup,
        #[serde(rename = "assert")]
        Assert,
        #[serde(rename = "profile")]
        Profile,
        #[serde(rename = "profileEnd")]
        ProfileEnd,
        #[serde(rename = "count")]
        Count,
        #[serde(rename = "timeEnd")]
        TimeEnd,
    }
    ///Issued when console API was called.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ConsoleApiCalledEvent {
        ///Type of the call.
        #[serde(rename = "type")]
        pub type_: ConsoleApiCalledEventType,
        ///Call arguments.
        #[serde(rename = "args")]
        pub args: Vec<RemoteObject>,
        ///Identifier of the context where the call was made.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: ExecutionContextId,
        ///Call timestamp.
        #[serde(rename = "timestamp")]
        pub timestamp: Timestamp,
        ///Stack trace captured when the call was made. The async stack chain is automatically reported for
        ///the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
        ///chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<StackTrace>,
        ///Console context descriptor for calls on non-default console context (not console.*):
        ///'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
        ///on named context.
        #[serde(rename = "context")]
        pub context: Option<String>,
    }
    ///Issued when unhandled exception was revoked.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExceptionRevokedEvent {
        ///Reason describing why exception was revoked.
        #[serde(rename = "reason")]
        pub reason: String,
        ///The id of revoked exception, as reported in `exceptionThrown`.
        #[serde(rename = "exceptionId")]
        pub exception_id: i64,
    }
    ///Issued when exception was thrown and unhandled.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExceptionThrownEvent {
        ///Timestamp of the exception.
        #[serde(rename = "timestamp")]
        pub timestamp: Timestamp,
        #[serde(rename = "exceptionDetails")]
        pub exception_details: ExceptionDetails,
    }
    ///Issued when new execution context is created.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecutionContextCreatedEvent {
        ///A newly created execution context.
        #[serde(rename = "context")]
        pub context: ExecutionContextDescription,
    }
    ///Issued when execution context is destroyed.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecutionContextDestroyedEvent {
        ///Id of the destroyed context
        #[deprecated]
        #[serde(rename = "executionContextId")]
        pub execution_context_id: ExecutionContextId,
        ///Unique Id of the destroyed context
        #[serde(rename = "executionContextUniqueId")]
        pub execution_context_unique_id: String,
    }
    ///Issued when all executionContexts were cleared in browser
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ExecutionContextsClearedEvent {}
    ///Issued when object should be inspected (for example, as a result of inspect() command line API
    ///call).
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct InspectRequestedEvent {
        #[serde(rename = "object")]
        pub object: RemoteObject,
        #[serde(rename = "hints")]
        pub hints: serde_json::Map<String, serde_json::Value>,
        ///Identifier of the context where the call was made.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
    }
}
///This domain is deprecated.
#[deprecated]
pub mod schema {
    ///Description of the protocol domain.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct Domain {
        ///Domain name.
        #[serde(rename = "name")]
        pub name: String,
        ///Domain version.
        #[serde(rename = "version")]
        pub version: String,
    }
    ///
    /// Return value for [GetDomains].
    ///
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDomainsReturns {
        ///List of supported domains.
        #[serde(rename = "domains")]
        pub domains: Vec<Domain>,
    }
    ///Returns supported domains.
    ///---
    ///Return Type: [GetDomainsReturns]
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetDomains;
    impl crate::util::Command for GetDomains {
        type Parameters = crate::util::Nothing;
        type Returns = crate::util::Nothing;
        type Error = crate::util::Infallible;
        fn id() -> &'static str {
            "getDomains"
        }
    }
}
